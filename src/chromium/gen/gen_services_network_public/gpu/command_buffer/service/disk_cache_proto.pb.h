// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: disk_cache_proto.proto

#ifndef PROTOBUF_INCLUDED_disk_5fcache_5fproto_2eproto
#define PROTOBUF_INCLUDED_disk_5fcache_5fproto_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_disk_5fcache_5fproto_2eproto 

namespace protobuf_disk_5fcache_5fproto_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_disk_5fcache_5fproto_2eproto
class GpuProgramProto;
class GpuProgramProtoDefaultTypeInternal;
extern GpuProgramProtoDefaultTypeInternal _GpuProgramProto_default_instance_;
class ShaderAttributeProto;
class ShaderAttributeProtoDefaultTypeInternal;
extern ShaderAttributeProtoDefaultTypeInternal _ShaderAttributeProto_default_instance_;
class ShaderInterfaceBlockFieldProto;
class ShaderInterfaceBlockFieldProtoDefaultTypeInternal;
extern ShaderInterfaceBlockFieldProtoDefaultTypeInternal _ShaderInterfaceBlockFieldProto_default_instance_;
class ShaderInterfaceBlockProto;
class ShaderInterfaceBlockProtoDefaultTypeInternal;
extern ShaderInterfaceBlockProtoDefaultTypeInternal _ShaderInterfaceBlockProto_default_instance_;
class ShaderOutputVariableProto;
class ShaderOutputVariableProtoDefaultTypeInternal;
extern ShaderOutputVariableProtoDefaultTypeInternal _ShaderOutputVariableProto_default_instance_;
class ShaderProto;
class ShaderProtoDefaultTypeInternal;
extern ShaderProtoDefaultTypeInternal _ShaderProto_default_instance_;
class ShaderUniformProto;
class ShaderUniformProtoDefaultTypeInternal;
extern ShaderUniformProtoDefaultTypeInternal _ShaderUniformProto_default_instance_;
class ShaderVariableProto;
class ShaderVariableProtoDefaultTypeInternal;
extern ShaderVariableProtoDefaultTypeInternal _ShaderVariableProto_default_instance_;
class ShaderVaryingProto;
class ShaderVaryingProtoDefaultTypeInternal;
extern ShaderVaryingProtoDefaultTypeInternal _ShaderVaryingProto_default_instance_;
namespace google {
namespace protobuf {
template<> ::GpuProgramProto* Arena::CreateMaybeMessage<::GpuProgramProto>(Arena*);
template<> ::ShaderAttributeProto* Arena::CreateMaybeMessage<::ShaderAttributeProto>(Arena*);
template<> ::ShaderInterfaceBlockFieldProto* Arena::CreateMaybeMessage<::ShaderInterfaceBlockFieldProto>(Arena*);
template<> ::ShaderInterfaceBlockProto* Arena::CreateMaybeMessage<::ShaderInterfaceBlockProto>(Arena*);
template<> ::ShaderOutputVariableProto* Arena::CreateMaybeMessage<::ShaderOutputVariableProto>(Arena*);
template<> ::ShaderProto* Arena::CreateMaybeMessage<::ShaderProto>(Arena*);
template<> ::ShaderUniformProto* Arena::CreateMaybeMessage<::ShaderUniformProto>(Arena*);
template<> ::ShaderVariableProto* Arena::CreateMaybeMessage<::ShaderVariableProto>(Arena*);
template<> ::ShaderVaryingProto* Arena::CreateMaybeMessage<::ShaderVaryingProto>(Arena*);
}  // namespace protobuf
}  // namespace google

// ===================================================================

class ShaderVariableProto : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ShaderVariableProto) */ {
 public:
  ShaderVariableProto();
  virtual ~ShaderVariableProto();

  ShaderVariableProto(const ShaderVariableProto& from);

  inline ShaderVariableProto& operator=(const ShaderVariableProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShaderVariableProto(ShaderVariableProto&& from) noexcept
    : ShaderVariableProto() {
    *this = ::std::move(from);
  }

  inline ShaderVariableProto& operator=(ShaderVariableProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ShaderVariableProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShaderVariableProto* internal_default_instance() {
    return reinterpret_cast<const ShaderVariableProto*>(
               &_ShaderVariableProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderVariableProto* other);
  friend void swap(ShaderVariableProto& a, ShaderVariableProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShaderVariableProto* New() const final {
    return CreateMaybeMessage<ShaderVariableProto>(NULL);
  }

  ShaderVariableProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShaderVariableProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ShaderVariableProto& from);
  void MergeFrom(const ShaderVariableProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderVariableProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ShaderVariableProto fields = 7;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 7;
  ::ShaderVariableProto* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::ShaderVariableProto >*
      mutable_fields();
  const ::ShaderVariableProto& fields(int index) const;
  ::ShaderVariableProto* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::ShaderVariableProto >&
      fields() const;

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string mapped_name = 4;
  bool has_mapped_name() const;
  void clear_mapped_name();
  static const int kMappedNameFieldNumber = 4;
  const ::std::string& mapped_name() const;
  void set_mapped_name(const ::std::string& value);
  #if LANG_CXX11
  void set_mapped_name(::std::string&& value);
  #endif
  void set_mapped_name(const char* value);
  void set_mapped_name(const char* value, size_t size);
  ::std::string* mutable_mapped_name();
  ::std::string* release_mapped_name();
  void set_allocated_mapped_name(::std::string* mapped_name);

  // optional string struct_name = 8;
  bool has_struct_name() const;
  void clear_struct_name();
  static const int kStructNameFieldNumber = 8;
  const ::std::string& struct_name() const;
  void set_struct_name(const ::std::string& value);
  #if LANG_CXX11
  void set_struct_name(::std::string&& value);
  #endif
  void set_struct_name(const char* value);
  void set_struct_name(const char* value, size_t size);
  ::std::string* mutable_struct_name();
  ::std::string* release_struct_name();
  void set_allocated_struct_name(::std::string* struct_name);

  // optional uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 precision = 2;
  bool has_precision() const;
  void clear_precision();
  static const int kPrecisionFieldNumber = 2;
  ::google::protobuf::uint32 precision() const;
  void set_precision(::google::protobuf::uint32 value);

  // optional uint32 array_size = 5;
  bool has_array_size() const;
  void clear_array_size();
  static const int kArraySizeFieldNumber = 5;
  ::google::protobuf::uint32 array_size() const;
  void set_array_size(::google::protobuf::uint32 value);

  // optional bool static_use = 6;
  bool has_static_use() const;
  void clear_static_use();
  static const int kStaticUseFieldNumber = 6;
  bool static_use() const;
  void set_static_use(bool value);

  // @@protoc_insertion_point(class_scope:ShaderVariableProto)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_precision();
  void clear_has_precision();
  void set_has_name();
  void clear_has_name();
  void set_has_mapped_name();
  void clear_has_mapped_name();
  void set_has_array_size();
  void clear_has_array_size();
  void set_has_static_use();
  void clear_has_static_use();
  void set_has_struct_name();
  void clear_has_struct_name();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ShaderVariableProto > fields_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr mapped_name_;
  ::google::protobuf::internal::ArenaStringPtr struct_name_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 precision_;
  ::google::protobuf::uint32 array_size_;
  bool static_use_;
  friend struct ::protobuf_disk_5fcache_5fproto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShaderAttributeProto : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ShaderAttributeProto) */ {
 public:
  ShaderAttributeProto();
  virtual ~ShaderAttributeProto();

  ShaderAttributeProto(const ShaderAttributeProto& from);

  inline ShaderAttributeProto& operator=(const ShaderAttributeProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShaderAttributeProto(ShaderAttributeProto&& from) noexcept
    : ShaderAttributeProto() {
    *this = ::std::move(from);
  }

  inline ShaderAttributeProto& operator=(ShaderAttributeProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ShaderAttributeProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShaderAttributeProto* internal_default_instance() {
    return reinterpret_cast<const ShaderAttributeProto*>(
               &_ShaderAttributeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderAttributeProto* other);
  friend void swap(ShaderAttributeProto& a, ShaderAttributeProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShaderAttributeProto* New() const final {
    return CreateMaybeMessage<ShaderAttributeProto>(NULL);
  }

  ShaderAttributeProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShaderAttributeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ShaderAttributeProto& from);
  void MergeFrom(const ShaderAttributeProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderAttributeProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ShaderVariableProto basic = 1;
  bool has_basic() const;
  void clear_basic();
  static const int kBasicFieldNumber = 1;
  private:
  const ::ShaderVariableProto& _internal_basic() const;
  public:
  const ::ShaderVariableProto& basic() const;
  ::ShaderVariableProto* release_basic();
  ::ShaderVariableProto* mutable_basic();
  void set_allocated_basic(::ShaderVariableProto* basic);

  // optional int32 location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  ::google::protobuf::int32 location() const;
  void set_location(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShaderAttributeProto)
 private:
  void set_has_basic();
  void clear_has_basic();
  void set_has_location();
  void clear_has_location();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ShaderVariableProto* basic_;
  ::google::protobuf::int32 location_;
  friend struct ::protobuf_disk_5fcache_5fproto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShaderUniformProto : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ShaderUniformProto) */ {
 public:
  ShaderUniformProto();
  virtual ~ShaderUniformProto();

  ShaderUniformProto(const ShaderUniformProto& from);

  inline ShaderUniformProto& operator=(const ShaderUniformProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShaderUniformProto(ShaderUniformProto&& from) noexcept
    : ShaderUniformProto() {
    *this = ::std::move(from);
  }

  inline ShaderUniformProto& operator=(ShaderUniformProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ShaderUniformProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShaderUniformProto* internal_default_instance() {
    return reinterpret_cast<const ShaderUniformProto*>(
               &_ShaderUniformProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderUniformProto* other);
  friend void swap(ShaderUniformProto& a, ShaderUniformProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShaderUniformProto* New() const final {
    return CreateMaybeMessage<ShaderUniformProto>(NULL);
  }

  ShaderUniformProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShaderUniformProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ShaderUniformProto& from);
  void MergeFrom(const ShaderUniformProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderUniformProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ShaderVariableProto basic = 1;
  bool has_basic() const;
  void clear_basic();
  static const int kBasicFieldNumber = 1;
  private:
  const ::ShaderVariableProto& _internal_basic() const;
  public:
  const ::ShaderVariableProto& basic() const;
  ::ShaderVariableProto* release_basic();
  ::ShaderVariableProto* mutable_basic();
  void set_allocated_basic(::ShaderVariableProto* basic);

  // @@protoc_insertion_point(class_scope:ShaderUniformProto)
 private:
  void set_has_basic();
  void clear_has_basic();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ShaderVariableProto* basic_;
  friend struct ::protobuf_disk_5fcache_5fproto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShaderVaryingProto : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ShaderVaryingProto) */ {
 public:
  ShaderVaryingProto();
  virtual ~ShaderVaryingProto();

  ShaderVaryingProto(const ShaderVaryingProto& from);

  inline ShaderVaryingProto& operator=(const ShaderVaryingProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShaderVaryingProto(ShaderVaryingProto&& from) noexcept
    : ShaderVaryingProto() {
    *this = ::std::move(from);
  }

  inline ShaderVaryingProto& operator=(ShaderVaryingProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ShaderVaryingProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShaderVaryingProto* internal_default_instance() {
    return reinterpret_cast<const ShaderVaryingProto*>(
               &_ShaderVaryingProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderVaryingProto* other);
  friend void swap(ShaderVaryingProto& a, ShaderVaryingProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShaderVaryingProto* New() const final {
    return CreateMaybeMessage<ShaderVaryingProto>(NULL);
  }

  ShaderVaryingProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShaderVaryingProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ShaderVaryingProto& from);
  void MergeFrom(const ShaderVaryingProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderVaryingProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ShaderVariableProto basic = 1;
  bool has_basic() const;
  void clear_basic();
  static const int kBasicFieldNumber = 1;
  private:
  const ::ShaderVariableProto& _internal_basic() const;
  public:
  const ::ShaderVariableProto& basic() const;
  ::ShaderVariableProto* release_basic();
  ::ShaderVariableProto* mutable_basic();
  void set_allocated_basic(::ShaderVariableProto* basic);

  // optional int32 interpolation = 2;
  bool has_interpolation() const;
  void clear_interpolation();
  static const int kInterpolationFieldNumber = 2;
  ::google::protobuf::int32 interpolation() const;
  void set_interpolation(::google::protobuf::int32 value);

  // optional bool is_invariant = 3;
  bool has_is_invariant() const;
  void clear_is_invariant();
  static const int kIsInvariantFieldNumber = 3;
  bool is_invariant() const;
  void set_is_invariant(bool value);

  // @@protoc_insertion_point(class_scope:ShaderVaryingProto)
 private:
  void set_has_basic();
  void clear_has_basic();
  void set_has_interpolation();
  void clear_has_interpolation();
  void set_has_is_invariant();
  void clear_has_is_invariant();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ShaderVariableProto* basic_;
  ::google::protobuf::int32 interpolation_;
  bool is_invariant_;
  friend struct ::protobuf_disk_5fcache_5fproto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShaderOutputVariableProto : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ShaderOutputVariableProto) */ {
 public:
  ShaderOutputVariableProto();
  virtual ~ShaderOutputVariableProto();

  ShaderOutputVariableProto(const ShaderOutputVariableProto& from);

  inline ShaderOutputVariableProto& operator=(const ShaderOutputVariableProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShaderOutputVariableProto(ShaderOutputVariableProto&& from) noexcept
    : ShaderOutputVariableProto() {
    *this = ::std::move(from);
  }

  inline ShaderOutputVariableProto& operator=(ShaderOutputVariableProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ShaderOutputVariableProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShaderOutputVariableProto* internal_default_instance() {
    return reinterpret_cast<const ShaderOutputVariableProto*>(
               &_ShaderOutputVariableProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderOutputVariableProto* other);
  friend void swap(ShaderOutputVariableProto& a, ShaderOutputVariableProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShaderOutputVariableProto* New() const final {
    return CreateMaybeMessage<ShaderOutputVariableProto>(NULL);
  }

  ShaderOutputVariableProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShaderOutputVariableProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ShaderOutputVariableProto& from);
  void MergeFrom(const ShaderOutputVariableProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderOutputVariableProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ShaderVariableProto basic = 1;
  bool has_basic() const;
  void clear_basic();
  static const int kBasicFieldNumber = 1;
  private:
  const ::ShaderVariableProto& _internal_basic() const;
  public:
  const ::ShaderVariableProto& basic() const;
  ::ShaderVariableProto* release_basic();
  ::ShaderVariableProto* mutable_basic();
  void set_allocated_basic(::ShaderVariableProto* basic);

  // optional int32 location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  ::google::protobuf::int32 location() const;
  void set_location(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShaderOutputVariableProto)
 private:
  void set_has_basic();
  void clear_has_basic();
  void set_has_location();
  void clear_has_location();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ShaderVariableProto* basic_;
  ::google::protobuf::int32 location_;
  friend struct ::protobuf_disk_5fcache_5fproto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShaderInterfaceBlockFieldProto : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ShaderInterfaceBlockFieldProto) */ {
 public:
  ShaderInterfaceBlockFieldProto();
  virtual ~ShaderInterfaceBlockFieldProto();

  ShaderInterfaceBlockFieldProto(const ShaderInterfaceBlockFieldProto& from);

  inline ShaderInterfaceBlockFieldProto& operator=(const ShaderInterfaceBlockFieldProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShaderInterfaceBlockFieldProto(ShaderInterfaceBlockFieldProto&& from) noexcept
    : ShaderInterfaceBlockFieldProto() {
    *this = ::std::move(from);
  }

  inline ShaderInterfaceBlockFieldProto& operator=(ShaderInterfaceBlockFieldProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ShaderInterfaceBlockFieldProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShaderInterfaceBlockFieldProto* internal_default_instance() {
    return reinterpret_cast<const ShaderInterfaceBlockFieldProto*>(
               &_ShaderInterfaceBlockFieldProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderInterfaceBlockFieldProto* other);
  friend void swap(ShaderInterfaceBlockFieldProto& a, ShaderInterfaceBlockFieldProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShaderInterfaceBlockFieldProto* New() const final {
    return CreateMaybeMessage<ShaderInterfaceBlockFieldProto>(NULL);
  }

  ShaderInterfaceBlockFieldProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShaderInterfaceBlockFieldProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ShaderInterfaceBlockFieldProto& from);
  void MergeFrom(const ShaderInterfaceBlockFieldProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderInterfaceBlockFieldProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ShaderVariableProto basic = 1;
  bool has_basic() const;
  void clear_basic();
  static const int kBasicFieldNumber = 1;
  private:
  const ::ShaderVariableProto& _internal_basic() const;
  public:
  const ::ShaderVariableProto& basic() const;
  ::ShaderVariableProto* release_basic();
  ::ShaderVariableProto* mutable_basic();
  void set_allocated_basic(::ShaderVariableProto* basic);

  // optional bool is_row_major_layout = 2;
  bool has_is_row_major_layout() const;
  void clear_is_row_major_layout();
  static const int kIsRowMajorLayoutFieldNumber = 2;
  bool is_row_major_layout() const;
  void set_is_row_major_layout(bool value);

  // @@protoc_insertion_point(class_scope:ShaderInterfaceBlockFieldProto)
 private:
  void set_has_basic();
  void clear_has_basic();
  void set_has_is_row_major_layout();
  void clear_has_is_row_major_layout();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ShaderVariableProto* basic_;
  bool is_row_major_layout_;
  friend struct ::protobuf_disk_5fcache_5fproto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShaderInterfaceBlockProto : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ShaderInterfaceBlockProto) */ {
 public:
  ShaderInterfaceBlockProto();
  virtual ~ShaderInterfaceBlockProto();

  ShaderInterfaceBlockProto(const ShaderInterfaceBlockProto& from);

  inline ShaderInterfaceBlockProto& operator=(const ShaderInterfaceBlockProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShaderInterfaceBlockProto(ShaderInterfaceBlockProto&& from) noexcept
    : ShaderInterfaceBlockProto() {
    *this = ::std::move(from);
  }

  inline ShaderInterfaceBlockProto& operator=(ShaderInterfaceBlockProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ShaderInterfaceBlockProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShaderInterfaceBlockProto* internal_default_instance() {
    return reinterpret_cast<const ShaderInterfaceBlockProto*>(
               &_ShaderInterfaceBlockProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderInterfaceBlockProto* other);
  friend void swap(ShaderInterfaceBlockProto& a, ShaderInterfaceBlockProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShaderInterfaceBlockProto* New() const final {
    return CreateMaybeMessage<ShaderInterfaceBlockProto>(NULL);
  }

  ShaderInterfaceBlockProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShaderInterfaceBlockProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ShaderInterfaceBlockProto& from);
  void MergeFrom(const ShaderInterfaceBlockProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderInterfaceBlockProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ShaderInterfaceBlockFieldProto fields = 8;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 8;
  ::ShaderInterfaceBlockFieldProto* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::ShaderInterfaceBlockFieldProto >*
      mutable_fields();
  const ::ShaderInterfaceBlockFieldProto& fields(int index) const;
  ::ShaderInterfaceBlockFieldProto* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::ShaderInterfaceBlockFieldProto >&
      fields() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string mapped_name = 2;
  bool has_mapped_name() const;
  void clear_mapped_name();
  static const int kMappedNameFieldNumber = 2;
  const ::std::string& mapped_name() const;
  void set_mapped_name(const ::std::string& value);
  #if LANG_CXX11
  void set_mapped_name(::std::string&& value);
  #endif
  void set_mapped_name(const char* value);
  void set_mapped_name(const char* value, size_t size);
  ::std::string* mutable_mapped_name();
  ::std::string* release_mapped_name();
  void set_allocated_mapped_name(::std::string* mapped_name);

  // optional string instance_name = 3;
  bool has_instance_name() const;
  void clear_instance_name();
  static const int kInstanceNameFieldNumber = 3;
  const ::std::string& instance_name() const;
  void set_instance_name(const ::std::string& value);
  #if LANG_CXX11
  void set_instance_name(::std::string&& value);
  #endif
  void set_instance_name(const char* value);
  void set_instance_name(const char* value, size_t size);
  ::std::string* mutable_instance_name();
  ::std::string* release_instance_name();
  void set_allocated_instance_name(::std::string* instance_name);

  // optional uint32 array_size = 4;
  bool has_array_size() const;
  void clear_array_size();
  static const int kArraySizeFieldNumber = 4;
  ::google::protobuf::uint32 array_size() const;
  void set_array_size(::google::protobuf::uint32 value);

  // optional int32 layout = 5;
  bool has_layout() const;
  void clear_layout();
  static const int kLayoutFieldNumber = 5;
  ::google::protobuf::int32 layout() const;
  void set_layout(::google::protobuf::int32 value);

  // optional bool is_row_major_layout = 6;
  bool has_is_row_major_layout() const;
  void clear_is_row_major_layout();
  static const int kIsRowMajorLayoutFieldNumber = 6;
  bool is_row_major_layout() const;
  void set_is_row_major_layout(bool value);

  // optional bool static_use = 7;
  bool has_static_use() const;
  void clear_static_use();
  static const int kStaticUseFieldNumber = 7;
  bool static_use() const;
  void set_static_use(bool value);

  // @@protoc_insertion_point(class_scope:ShaderInterfaceBlockProto)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_mapped_name();
  void clear_has_mapped_name();
  void set_has_instance_name();
  void clear_has_instance_name();
  void set_has_array_size();
  void clear_has_array_size();
  void set_has_layout();
  void clear_has_layout();
  void set_has_is_row_major_layout();
  void clear_has_is_row_major_layout();
  void set_has_static_use();
  void clear_has_static_use();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ShaderInterfaceBlockFieldProto > fields_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr mapped_name_;
  ::google::protobuf::internal::ArenaStringPtr instance_name_;
  ::google::protobuf::uint32 array_size_;
  ::google::protobuf::int32 layout_;
  bool is_row_major_layout_;
  bool static_use_;
  friend struct ::protobuf_disk_5fcache_5fproto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShaderProto : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ShaderProto) */ {
 public:
  ShaderProto();
  virtual ~ShaderProto();

  ShaderProto(const ShaderProto& from);

  inline ShaderProto& operator=(const ShaderProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShaderProto(ShaderProto&& from) noexcept
    : ShaderProto() {
    *this = ::std::move(from);
  }

  inline ShaderProto& operator=(ShaderProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ShaderProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShaderProto* internal_default_instance() {
    return reinterpret_cast<const ShaderProto*>(
               &_ShaderProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ShaderProto* other);
  friend void swap(ShaderProto& a, ShaderProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShaderProto* New() const final {
    return CreateMaybeMessage<ShaderProto>(NULL);
  }

  ShaderProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShaderProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ShaderProto& from);
  void MergeFrom(const ShaderProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ShaderAttributeProto attribs = 2;
  int attribs_size() const;
  void clear_attribs();
  static const int kAttribsFieldNumber = 2;
  ::ShaderAttributeProto* mutable_attribs(int index);
  ::google::protobuf::RepeatedPtrField< ::ShaderAttributeProto >*
      mutable_attribs();
  const ::ShaderAttributeProto& attribs(int index) const;
  ::ShaderAttributeProto* add_attribs();
  const ::google::protobuf::RepeatedPtrField< ::ShaderAttributeProto >&
      attribs() const;

  // repeated .ShaderUniformProto uniforms = 3;
  int uniforms_size() const;
  void clear_uniforms();
  static const int kUniformsFieldNumber = 3;
  ::ShaderUniformProto* mutable_uniforms(int index);
  ::google::protobuf::RepeatedPtrField< ::ShaderUniformProto >*
      mutable_uniforms();
  const ::ShaderUniformProto& uniforms(int index) const;
  ::ShaderUniformProto* add_uniforms();
  const ::google::protobuf::RepeatedPtrField< ::ShaderUniformProto >&
      uniforms() const;

  // repeated .ShaderVaryingProto varyings = 4;
  int varyings_size() const;
  void clear_varyings();
  static const int kVaryingsFieldNumber = 4;
  ::ShaderVaryingProto* mutable_varyings(int index);
  ::google::protobuf::RepeatedPtrField< ::ShaderVaryingProto >*
      mutable_varyings();
  const ::ShaderVaryingProto& varyings(int index) const;
  ::ShaderVaryingProto* add_varyings();
  const ::google::protobuf::RepeatedPtrField< ::ShaderVaryingProto >&
      varyings() const;

  // repeated .ShaderOutputVariableProto output_variables = 5;
  int output_variables_size() const;
  void clear_output_variables();
  static const int kOutputVariablesFieldNumber = 5;
  ::ShaderOutputVariableProto* mutable_output_variables(int index);
  ::google::protobuf::RepeatedPtrField< ::ShaderOutputVariableProto >*
      mutable_output_variables();
  const ::ShaderOutputVariableProto& output_variables(int index) const;
  ::ShaderOutputVariableProto* add_output_variables();
  const ::google::protobuf::RepeatedPtrField< ::ShaderOutputVariableProto >&
      output_variables() const;

  // repeated .ShaderInterfaceBlockProto interface_blocks = 6;
  int interface_blocks_size() const;
  void clear_interface_blocks();
  static const int kInterfaceBlocksFieldNumber = 6;
  ::ShaderInterfaceBlockProto* mutable_interface_blocks(int index);
  ::google::protobuf::RepeatedPtrField< ::ShaderInterfaceBlockProto >*
      mutable_interface_blocks();
  const ::ShaderInterfaceBlockProto& interface_blocks(int index) const;
  ::ShaderInterfaceBlockProto* add_interface_blocks();
  const ::google::protobuf::RepeatedPtrField< ::ShaderInterfaceBlockProto >&
      interface_blocks() const;

  // optional bytes sha = 1;
  bool has_sha() const;
  void clear_sha();
  static const int kShaFieldNumber = 1;
  const ::std::string& sha() const;
  void set_sha(const ::std::string& value);
  #if LANG_CXX11
  void set_sha(::std::string&& value);
  #endif
  void set_sha(const char* value);
  void set_sha(const void* value, size_t size);
  ::std::string* mutable_sha();
  ::std::string* release_sha();
  void set_allocated_sha(::std::string* sha);

  // @@protoc_insertion_point(class_scope:ShaderProto)
 private:
  void set_has_sha();
  void clear_has_sha();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ShaderAttributeProto > attribs_;
  ::google::protobuf::RepeatedPtrField< ::ShaderUniformProto > uniforms_;
  ::google::protobuf::RepeatedPtrField< ::ShaderVaryingProto > varyings_;
  ::google::protobuf::RepeatedPtrField< ::ShaderOutputVariableProto > output_variables_;
  ::google::protobuf::RepeatedPtrField< ::ShaderInterfaceBlockProto > interface_blocks_;
  ::google::protobuf::internal::ArenaStringPtr sha_;
  friend struct ::protobuf_disk_5fcache_5fproto_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GpuProgramProto : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GpuProgramProto) */ {
 public:
  GpuProgramProto();
  virtual ~GpuProgramProto();

  GpuProgramProto(const GpuProgramProto& from);

  inline GpuProgramProto& operator=(const GpuProgramProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GpuProgramProto(GpuProgramProto&& from) noexcept
    : GpuProgramProto() {
    *this = ::std::move(from);
  }

  inline GpuProgramProto& operator=(GpuProgramProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GpuProgramProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpuProgramProto* internal_default_instance() {
    return reinterpret_cast<const GpuProgramProto*>(
               &_GpuProgramProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(GpuProgramProto* other);
  friend void swap(GpuProgramProto& a, GpuProgramProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GpuProgramProto* New() const final {
    return CreateMaybeMessage<GpuProgramProto>(NULL);
  }

  GpuProgramProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GpuProgramProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GpuProgramProto& from);
  void MergeFrom(const GpuProgramProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpuProgramProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sha = 1;
  bool has_sha() const;
  void clear_sha();
  static const int kShaFieldNumber = 1;
  const ::std::string& sha() const;
  void set_sha(const ::std::string& value);
  #if LANG_CXX11
  void set_sha(::std::string&& value);
  #endif
  void set_sha(const char* value);
  void set_sha(const void* value, size_t size);
  ::std::string* mutable_sha();
  ::std::string* release_sha();
  void set_allocated_sha(::std::string* sha);

  // optional bytes program = 3;
  bool has_program() const;
  void clear_program();
  static const int kProgramFieldNumber = 3;
  const ::std::string& program() const;
  void set_program(const ::std::string& value);
  #if LANG_CXX11
  void set_program(::std::string&& value);
  #endif
  void set_program(const char* value);
  void set_program(const void* value, size_t size);
  ::std::string* mutable_program();
  ::std::string* release_program();
  void set_allocated_program(::std::string* program);

  // optional .ShaderProto vertex_shader = 4;
  bool has_vertex_shader() const;
  void clear_vertex_shader();
  static const int kVertexShaderFieldNumber = 4;
  private:
  const ::ShaderProto& _internal_vertex_shader() const;
  public:
  const ::ShaderProto& vertex_shader() const;
  ::ShaderProto* release_vertex_shader();
  ::ShaderProto* mutable_vertex_shader();
  void set_allocated_vertex_shader(::ShaderProto* vertex_shader);

  // optional .ShaderProto fragment_shader = 5;
  bool has_fragment_shader() const;
  void clear_fragment_shader();
  static const int kFragmentShaderFieldNumber = 5;
  private:
  const ::ShaderProto& _internal_fragment_shader() const;
  public:
  const ::ShaderProto& fragment_shader() const;
  ::ShaderProto* release_fragment_shader();
  ::ShaderProto* mutable_fragment_shader();
  void set_allocated_fragment_shader(::ShaderProto* fragment_shader);

  // optional uint32 format = 2;
  bool has_format() const;
  void clear_format();
  static const int kFormatFieldNumber = 2;
  ::google::protobuf::uint32 format() const;
  void set_format(::google::protobuf::uint32 value);

  // optional bool program_is_compressed = 6;
  bool has_program_is_compressed() const;
  void clear_program_is_compressed();
  static const int kProgramIsCompressedFieldNumber = 6;
  bool program_is_compressed() const;
  void set_program_is_compressed(bool value);

  // optional uint32 program_decompressed_length = 7;
  bool has_program_decompressed_length() const;
  void clear_program_decompressed_length();
  static const int kProgramDecompressedLengthFieldNumber = 7;
  ::google::protobuf::uint32 program_decompressed_length() const;
  void set_program_decompressed_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GpuProgramProto)
 private:
  void set_has_sha();
  void clear_has_sha();
  void set_has_format();
  void clear_has_format();
  void set_has_program();
  void clear_has_program();
  void set_has_program_is_compressed();
  void clear_has_program_is_compressed();
  void set_has_program_decompressed_length();
  void clear_has_program_decompressed_length();
  void set_has_vertex_shader();
  void clear_has_vertex_shader();
  void set_has_fragment_shader();
  void clear_has_fragment_shader();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sha_;
  ::google::protobuf::internal::ArenaStringPtr program_;
  ::ShaderProto* vertex_shader_;
  ::ShaderProto* fragment_shader_;
  ::google::protobuf::uint32 format_;
  bool program_is_compressed_;
  ::google::protobuf::uint32 program_decompressed_length_;
  friend struct ::protobuf_disk_5fcache_5fproto_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ShaderVariableProto

// optional uint32 type = 1;
inline bool ShaderVariableProto::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShaderVariableProto::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShaderVariableProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShaderVariableProto::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ShaderVariableProto::type() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.type)
  return type_;
}
inline void ShaderVariableProto::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ShaderVariableProto.type)
}

// optional uint32 precision = 2;
inline bool ShaderVariableProto::has_precision() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShaderVariableProto::set_has_precision() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShaderVariableProto::clear_has_precision() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShaderVariableProto::clear_precision() {
  precision_ = 0u;
  clear_has_precision();
}
inline ::google::protobuf::uint32 ShaderVariableProto::precision() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.precision)
  return precision_;
}
inline void ShaderVariableProto::set_precision(::google::protobuf::uint32 value) {
  set_has_precision();
  precision_ = value;
  // @@protoc_insertion_point(field_set:ShaderVariableProto.precision)
}

// optional string name = 3;
inline bool ShaderVariableProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderVariableProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderVariableProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderVariableProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ShaderVariableProto::name() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.name)
  return name_.GetNoArena();
}
inline void ShaderVariableProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShaderVariableProto.name)
}
#if LANG_CXX11
inline void ShaderVariableProto::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShaderVariableProto.name)
}
#endif
inline void ShaderVariableProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShaderVariableProto.name)
}
inline void ShaderVariableProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShaderVariableProto.name)
}
inline ::std::string* ShaderVariableProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:ShaderVariableProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderVariableProto::release_name() {
  // @@protoc_insertion_point(field_release:ShaderVariableProto.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderVariableProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ShaderVariableProto.name)
}

// optional string mapped_name = 4;
inline bool ShaderVariableProto::has_mapped_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderVariableProto::set_has_mapped_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShaderVariableProto::clear_has_mapped_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderVariableProto::clear_mapped_name() {
  mapped_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mapped_name();
}
inline const ::std::string& ShaderVariableProto::mapped_name() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.mapped_name)
  return mapped_name_.GetNoArena();
}
inline void ShaderVariableProto::set_mapped_name(const ::std::string& value) {
  set_has_mapped_name();
  mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShaderVariableProto.mapped_name)
}
#if LANG_CXX11
inline void ShaderVariableProto::set_mapped_name(::std::string&& value) {
  set_has_mapped_name();
  mapped_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShaderVariableProto.mapped_name)
}
#endif
inline void ShaderVariableProto::set_mapped_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mapped_name();
  mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShaderVariableProto.mapped_name)
}
inline void ShaderVariableProto::set_mapped_name(const char* value, size_t size) {
  set_has_mapped_name();
  mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShaderVariableProto.mapped_name)
}
inline ::std::string* ShaderVariableProto::mutable_mapped_name() {
  set_has_mapped_name();
  // @@protoc_insertion_point(field_mutable:ShaderVariableProto.mapped_name)
  return mapped_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderVariableProto::release_mapped_name() {
  // @@protoc_insertion_point(field_release:ShaderVariableProto.mapped_name)
  if (!has_mapped_name()) {
    return NULL;
  }
  clear_has_mapped_name();
  return mapped_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderVariableProto::set_allocated_mapped_name(::std::string* mapped_name) {
  if (mapped_name != NULL) {
    set_has_mapped_name();
  } else {
    clear_has_mapped_name();
  }
  mapped_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapped_name);
  // @@protoc_insertion_point(field_set_allocated:ShaderVariableProto.mapped_name)
}

// optional uint32 array_size = 5;
inline bool ShaderVariableProto::has_array_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShaderVariableProto::set_has_array_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ShaderVariableProto::clear_has_array_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ShaderVariableProto::clear_array_size() {
  array_size_ = 0u;
  clear_has_array_size();
}
inline ::google::protobuf::uint32 ShaderVariableProto::array_size() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.array_size)
  return array_size_;
}
inline void ShaderVariableProto::set_array_size(::google::protobuf::uint32 value) {
  set_has_array_size();
  array_size_ = value;
  // @@protoc_insertion_point(field_set:ShaderVariableProto.array_size)
}

// optional bool static_use = 6;
inline bool ShaderVariableProto::has_static_use() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ShaderVariableProto::set_has_static_use() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ShaderVariableProto::clear_has_static_use() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ShaderVariableProto::clear_static_use() {
  static_use_ = false;
  clear_has_static_use();
}
inline bool ShaderVariableProto::static_use() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.static_use)
  return static_use_;
}
inline void ShaderVariableProto::set_static_use(bool value) {
  set_has_static_use();
  static_use_ = value;
  // @@protoc_insertion_point(field_set:ShaderVariableProto.static_use)
}

// repeated .ShaderVariableProto fields = 7;
inline int ShaderVariableProto::fields_size() const {
  return fields_.size();
}
inline void ShaderVariableProto::clear_fields() {
  fields_.Clear();
}
inline ::ShaderVariableProto* ShaderVariableProto::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderVariableProto.fields)
  return fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ShaderVariableProto >*
ShaderVariableProto::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:ShaderVariableProto.fields)
  return &fields_;
}
inline const ::ShaderVariableProto& ShaderVariableProto::fields(int index) const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.fields)
  return fields_.Get(index);
}
inline ::ShaderVariableProto* ShaderVariableProto::add_fields() {
  // @@protoc_insertion_point(field_add:ShaderVariableProto.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShaderVariableProto >&
ShaderVariableProto::fields() const {
  // @@protoc_insertion_point(field_list:ShaderVariableProto.fields)
  return fields_;
}

// optional string struct_name = 8;
inline bool ShaderVariableProto::has_struct_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShaderVariableProto::set_has_struct_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShaderVariableProto::clear_has_struct_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShaderVariableProto::clear_struct_name() {
  struct_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_struct_name();
}
inline const ::std::string& ShaderVariableProto::struct_name() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.struct_name)
  return struct_name_.GetNoArena();
}
inline void ShaderVariableProto::set_struct_name(const ::std::string& value) {
  set_has_struct_name();
  struct_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShaderVariableProto.struct_name)
}
#if LANG_CXX11
inline void ShaderVariableProto::set_struct_name(::std::string&& value) {
  set_has_struct_name();
  struct_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShaderVariableProto.struct_name)
}
#endif
inline void ShaderVariableProto::set_struct_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_struct_name();
  struct_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShaderVariableProto.struct_name)
}
inline void ShaderVariableProto::set_struct_name(const char* value, size_t size) {
  set_has_struct_name();
  struct_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShaderVariableProto.struct_name)
}
inline ::std::string* ShaderVariableProto::mutable_struct_name() {
  set_has_struct_name();
  // @@protoc_insertion_point(field_mutable:ShaderVariableProto.struct_name)
  return struct_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderVariableProto::release_struct_name() {
  // @@protoc_insertion_point(field_release:ShaderVariableProto.struct_name)
  if (!has_struct_name()) {
    return NULL;
  }
  clear_has_struct_name();
  return struct_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderVariableProto::set_allocated_struct_name(::std::string* struct_name) {
  if (struct_name != NULL) {
    set_has_struct_name();
  } else {
    clear_has_struct_name();
  }
  struct_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), struct_name);
  // @@protoc_insertion_point(field_set_allocated:ShaderVariableProto.struct_name)
}

// -------------------------------------------------------------------

// ShaderAttributeProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderAttributeProto::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderAttributeProto::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderAttributeProto::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderAttributeProto::clear_basic() {
  if (basic_ != NULL) basic_->Clear();
  clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderAttributeProto::_internal_basic() const {
  return *basic_;
}
inline const ::ShaderVariableProto& ShaderAttributeProto::basic() const {
  const ::ShaderVariableProto* p = basic_;
  // @@protoc_insertion_point(field_get:ShaderAttributeProto.basic)
  return p != NULL ? *p : *reinterpret_cast<const ::ShaderVariableProto*>(
      &::_ShaderVariableProto_default_instance_);
}
inline ::ShaderVariableProto* ShaderAttributeProto::release_basic() {
  // @@protoc_insertion_point(field_release:ShaderAttributeProto.basic)
  clear_has_basic();
  ::ShaderVariableProto* temp = basic_;
  basic_ = NULL;
  return temp;
}
inline ::ShaderVariableProto* ShaderAttributeProto::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) {
    auto* p = CreateMaybeMessage<::ShaderVariableProto>(GetArenaNoVirtual());
    basic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ShaderAttributeProto.basic)
  return basic_;
}
inline void ShaderAttributeProto::set_allocated_basic(::ShaderVariableProto* basic) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete basic_;
  }
  if (basic) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      basic = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, basic, submessage_arena);
    }
    set_has_basic();
  } else {
    clear_has_basic();
  }
  basic_ = basic;
  // @@protoc_insertion_point(field_set_allocated:ShaderAttributeProto.basic)
}

// optional int32 location = 2;
inline bool ShaderAttributeProto::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderAttributeProto::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShaderAttributeProto::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderAttributeProto::clear_location() {
  location_ = 0;
  clear_has_location();
}
inline ::google::protobuf::int32 ShaderAttributeProto::location() const {
  // @@protoc_insertion_point(field_get:ShaderAttributeProto.location)
  return location_;
}
inline void ShaderAttributeProto::set_location(::google::protobuf::int32 value) {
  set_has_location();
  location_ = value;
  // @@protoc_insertion_point(field_set:ShaderAttributeProto.location)
}

// -------------------------------------------------------------------

// ShaderUniformProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderUniformProto::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderUniformProto::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderUniformProto::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderUniformProto::clear_basic() {
  if (basic_ != NULL) basic_->Clear();
  clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderUniformProto::_internal_basic() const {
  return *basic_;
}
inline const ::ShaderVariableProto& ShaderUniformProto::basic() const {
  const ::ShaderVariableProto* p = basic_;
  // @@protoc_insertion_point(field_get:ShaderUniformProto.basic)
  return p != NULL ? *p : *reinterpret_cast<const ::ShaderVariableProto*>(
      &::_ShaderVariableProto_default_instance_);
}
inline ::ShaderVariableProto* ShaderUniformProto::release_basic() {
  // @@protoc_insertion_point(field_release:ShaderUniformProto.basic)
  clear_has_basic();
  ::ShaderVariableProto* temp = basic_;
  basic_ = NULL;
  return temp;
}
inline ::ShaderVariableProto* ShaderUniformProto::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) {
    auto* p = CreateMaybeMessage<::ShaderVariableProto>(GetArenaNoVirtual());
    basic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ShaderUniformProto.basic)
  return basic_;
}
inline void ShaderUniformProto::set_allocated_basic(::ShaderVariableProto* basic) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete basic_;
  }
  if (basic) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      basic = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, basic, submessage_arena);
    }
    set_has_basic();
  } else {
    clear_has_basic();
  }
  basic_ = basic;
  // @@protoc_insertion_point(field_set_allocated:ShaderUniformProto.basic)
}

// -------------------------------------------------------------------

// ShaderVaryingProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderVaryingProto::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderVaryingProto::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderVaryingProto::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderVaryingProto::clear_basic() {
  if (basic_ != NULL) basic_->Clear();
  clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderVaryingProto::_internal_basic() const {
  return *basic_;
}
inline const ::ShaderVariableProto& ShaderVaryingProto::basic() const {
  const ::ShaderVariableProto* p = basic_;
  // @@protoc_insertion_point(field_get:ShaderVaryingProto.basic)
  return p != NULL ? *p : *reinterpret_cast<const ::ShaderVariableProto*>(
      &::_ShaderVariableProto_default_instance_);
}
inline ::ShaderVariableProto* ShaderVaryingProto::release_basic() {
  // @@protoc_insertion_point(field_release:ShaderVaryingProto.basic)
  clear_has_basic();
  ::ShaderVariableProto* temp = basic_;
  basic_ = NULL;
  return temp;
}
inline ::ShaderVariableProto* ShaderVaryingProto::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) {
    auto* p = CreateMaybeMessage<::ShaderVariableProto>(GetArenaNoVirtual());
    basic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ShaderVaryingProto.basic)
  return basic_;
}
inline void ShaderVaryingProto::set_allocated_basic(::ShaderVariableProto* basic) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete basic_;
  }
  if (basic) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      basic = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, basic, submessage_arena);
    }
    set_has_basic();
  } else {
    clear_has_basic();
  }
  basic_ = basic;
  // @@protoc_insertion_point(field_set_allocated:ShaderVaryingProto.basic)
}

// optional int32 interpolation = 2;
inline bool ShaderVaryingProto::has_interpolation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderVaryingProto::set_has_interpolation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShaderVaryingProto::clear_has_interpolation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderVaryingProto::clear_interpolation() {
  interpolation_ = 0;
  clear_has_interpolation();
}
inline ::google::protobuf::int32 ShaderVaryingProto::interpolation() const {
  // @@protoc_insertion_point(field_get:ShaderVaryingProto.interpolation)
  return interpolation_;
}
inline void ShaderVaryingProto::set_interpolation(::google::protobuf::int32 value) {
  set_has_interpolation();
  interpolation_ = value;
  // @@protoc_insertion_point(field_set:ShaderVaryingProto.interpolation)
}

// optional bool is_invariant = 3;
inline bool ShaderVaryingProto::has_is_invariant() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShaderVaryingProto::set_has_is_invariant() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShaderVaryingProto::clear_has_is_invariant() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShaderVaryingProto::clear_is_invariant() {
  is_invariant_ = false;
  clear_has_is_invariant();
}
inline bool ShaderVaryingProto::is_invariant() const {
  // @@protoc_insertion_point(field_get:ShaderVaryingProto.is_invariant)
  return is_invariant_;
}
inline void ShaderVaryingProto::set_is_invariant(bool value) {
  set_has_is_invariant();
  is_invariant_ = value;
  // @@protoc_insertion_point(field_set:ShaderVaryingProto.is_invariant)
}

// -------------------------------------------------------------------

// ShaderOutputVariableProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderOutputVariableProto::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderOutputVariableProto::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderOutputVariableProto::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderOutputVariableProto::clear_basic() {
  if (basic_ != NULL) basic_->Clear();
  clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderOutputVariableProto::_internal_basic() const {
  return *basic_;
}
inline const ::ShaderVariableProto& ShaderOutputVariableProto::basic() const {
  const ::ShaderVariableProto* p = basic_;
  // @@protoc_insertion_point(field_get:ShaderOutputVariableProto.basic)
  return p != NULL ? *p : *reinterpret_cast<const ::ShaderVariableProto*>(
      &::_ShaderVariableProto_default_instance_);
}
inline ::ShaderVariableProto* ShaderOutputVariableProto::release_basic() {
  // @@protoc_insertion_point(field_release:ShaderOutputVariableProto.basic)
  clear_has_basic();
  ::ShaderVariableProto* temp = basic_;
  basic_ = NULL;
  return temp;
}
inline ::ShaderVariableProto* ShaderOutputVariableProto::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) {
    auto* p = CreateMaybeMessage<::ShaderVariableProto>(GetArenaNoVirtual());
    basic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ShaderOutputVariableProto.basic)
  return basic_;
}
inline void ShaderOutputVariableProto::set_allocated_basic(::ShaderVariableProto* basic) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete basic_;
  }
  if (basic) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      basic = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, basic, submessage_arena);
    }
    set_has_basic();
  } else {
    clear_has_basic();
  }
  basic_ = basic;
  // @@protoc_insertion_point(field_set_allocated:ShaderOutputVariableProto.basic)
}

// optional int32 location = 2;
inline bool ShaderOutputVariableProto::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderOutputVariableProto::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShaderOutputVariableProto::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderOutputVariableProto::clear_location() {
  location_ = 0;
  clear_has_location();
}
inline ::google::protobuf::int32 ShaderOutputVariableProto::location() const {
  // @@protoc_insertion_point(field_get:ShaderOutputVariableProto.location)
  return location_;
}
inline void ShaderOutputVariableProto::set_location(::google::protobuf::int32 value) {
  set_has_location();
  location_ = value;
  // @@protoc_insertion_point(field_set:ShaderOutputVariableProto.location)
}

// -------------------------------------------------------------------

// ShaderInterfaceBlockFieldProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderInterfaceBlockFieldProto::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderInterfaceBlockFieldProto::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderInterfaceBlockFieldProto::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderInterfaceBlockFieldProto::clear_basic() {
  if (basic_ != NULL) basic_->Clear();
  clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderInterfaceBlockFieldProto::_internal_basic() const {
  return *basic_;
}
inline const ::ShaderVariableProto& ShaderInterfaceBlockFieldProto::basic() const {
  const ::ShaderVariableProto* p = basic_;
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockFieldProto.basic)
  return p != NULL ? *p : *reinterpret_cast<const ::ShaderVariableProto*>(
      &::_ShaderVariableProto_default_instance_);
}
inline ::ShaderVariableProto* ShaderInterfaceBlockFieldProto::release_basic() {
  // @@protoc_insertion_point(field_release:ShaderInterfaceBlockFieldProto.basic)
  clear_has_basic();
  ::ShaderVariableProto* temp = basic_;
  basic_ = NULL;
  return temp;
}
inline ::ShaderVariableProto* ShaderInterfaceBlockFieldProto::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) {
    auto* p = CreateMaybeMessage<::ShaderVariableProto>(GetArenaNoVirtual());
    basic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockFieldProto.basic)
  return basic_;
}
inline void ShaderInterfaceBlockFieldProto::set_allocated_basic(::ShaderVariableProto* basic) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete basic_;
  }
  if (basic) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      basic = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, basic, submessage_arena);
    }
    set_has_basic();
  } else {
    clear_has_basic();
  }
  basic_ = basic;
  // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockFieldProto.basic)
}

// optional bool is_row_major_layout = 2;
inline bool ShaderInterfaceBlockFieldProto::has_is_row_major_layout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderInterfaceBlockFieldProto::set_has_is_row_major_layout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShaderInterfaceBlockFieldProto::clear_has_is_row_major_layout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderInterfaceBlockFieldProto::clear_is_row_major_layout() {
  is_row_major_layout_ = false;
  clear_has_is_row_major_layout();
}
inline bool ShaderInterfaceBlockFieldProto::is_row_major_layout() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockFieldProto.is_row_major_layout)
  return is_row_major_layout_;
}
inline void ShaderInterfaceBlockFieldProto::set_is_row_major_layout(bool value) {
  set_has_is_row_major_layout();
  is_row_major_layout_ = value;
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockFieldProto.is_row_major_layout)
}

// -------------------------------------------------------------------

// ShaderInterfaceBlockProto

// optional string name = 1;
inline bool ShaderInterfaceBlockProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderInterfaceBlockProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderInterfaceBlockProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ShaderInterfaceBlockProto::name() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.name)
  return name_.GetNoArena();
}
inline void ShaderInterfaceBlockProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.name)
}
#if LANG_CXX11
inline void ShaderInterfaceBlockProto::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShaderInterfaceBlockProto.name)
}
#endif
inline void ShaderInterfaceBlockProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShaderInterfaceBlockProto.name)
}
inline void ShaderInterfaceBlockProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShaderInterfaceBlockProto.name)
}
inline ::std::string* ShaderInterfaceBlockProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderInterfaceBlockProto::release_name() {
  // @@protoc_insertion_point(field_release:ShaderInterfaceBlockProto.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderInterfaceBlockProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockProto.name)
}

// optional string mapped_name = 2;
inline bool ShaderInterfaceBlockProto::has_mapped_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_mapped_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShaderInterfaceBlockProto::clear_has_mapped_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderInterfaceBlockProto::clear_mapped_name() {
  mapped_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mapped_name();
}
inline const ::std::string& ShaderInterfaceBlockProto::mapped_name() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.mapped_name)
  return mapped_name_.GetNoArena();
}
inline void ShaderInterfaceBlockProto::set_mapped_name(const ::std::string& value) {
  set_has_mapped_name();
  mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.mapped_name)
}
#if LANG_CXX11
inline void ShaderInterfaceBlockProto::set_mapped_name(::std::string&& value) {
  set_has_mapped_name();
  mapped_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShaderInterfaceBlockProto.mapped_name)
}
#endif
inline void ShaderInterfaceBlockProto::set_mapped_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mapped_name();
  mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShaderInterfaceBlockProto.mapped_name)
}
inline void ShaderInterfaceBlockProto::set_mapped_name(const char* value, size_t size) {
  set_has_mapped_name();
  mapped_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShaderInterfaceBlockProto.mapped_name)
}
inline ::std::string* ShaderInterfaceBlockProto::mutable_mapped_name() {
  set_has_mapped_name();
  // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.mapped_name)
  return mapped_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderInterfaceBlockProto::release_mapped_name() {
  // @@protoc_insertion_point(field_release:ShaderInterfaceBlockProto.mapped_name)
  if (!has_mapped_name()) {
    return NULL;
  }
  clear_has_mapped_name();
  return mapped_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderInterfaceBlockProto::set_allocated_mapped_name(::std::string* mapped_name) {
  if (mapped_name != NULL) {
    set_has_mapped_name();
  } else {
    clear_has_mapped_name();
  }
  mapped_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapped_name);
  // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockProto.mapped_name)
}

// optional string instance_name = 3;
inline bool ShaderInterfaceBlockProto::has_instance_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_instance_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShaderInterfaceBlockProto::clear_has_instance_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShaderInterfaceBlockProto::clear_instance_name() {
  instance_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_instance_name();
}
inline const ::std::string& ShaderInterfaceBlockProto::instance_name() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.instance_name)
  return instance_name_.GetNoArena();
}
inline void ShaderInterfaceBlockProto::set_instance_name(const ::std::string& value) {
  set_has_instance_name();
  instance_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.instance_name)
}
#if LANG_CXX11
inline void ShaderInterfaceBlockProto::set_instance_name(::std::string&& value) {
  set_has_instance_name();
  instance_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShaderInterfaceBlockProto.instance_name)
}
#endif
inline void ShaderInterfaceBlockProto::set_instance_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_instance_name();
  instance_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShaderInterfaceBlockProto.instance_name)
}
inline void ShaderInterfaceBlockProto::set_instance_name(const char* value, size_t size) {
  set_has_instance_name();
  instance_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShaderInterfaceBlockProto.instance_name)
}
inline ::std::string* ShaderInterfaceBlockProto::mutable_instance_name() {
  set_has_instance_name();
  // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.instance_name)
  return instance_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderInterfaceBlockProto::release_instance_name() {
  // @@protoc_insertion_point(field_release:ShaderInterfaceBlockProto.instance_name)
  if (!has_instance_name()) {
    return NULL;
  }
  clear_has_instance_name();
  return instance_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderInterfaceBlockProto::set_allocated_instance_name(::std::string* instance_name) {
  if (instance_name != NULL) {
    set_has_instance_name();
  } else {
    clear_has_instance_name();
  }
  instance_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instance_name);
  // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockProto.instance_name)
}

// optional uint32 array_size = 4;
inline bool ShaderInterfaceBlockProto::has_array_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_array_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShaderInterfaceBlockProto::clear_has_array_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShaderInterfaceBlockProto::clear_array_size() {
  array_size_ = 0u;
  clear_has_array_size();
}
inline ::google::protobuf::uint32 ShaderInterfaceBlockProto::array_size() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.array_size)
  return array_size_;
}
inline void ShaderInterfaceBlockProto::set_array_size(::google::protobuf::uint32 value) {
  set_has_array_size();
  array_size_ = value;
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.array_size)
}

// optional int32 layout = 5;
inline bool ShaderInterfaceBlockProto::has_layout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_layout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShaderInterfaceBlockProto::clear_has_layout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShaderInterfaceBlockProto::clear_layout() {
  layout_ = 0;
  clear_has_layout();
}
inline ::google::protobuf::int32 ShaderInterfaceBlockProto::layout() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.layout)
  return layout_;
}
inline void ShaderInterfaceBlockProto::set_layout(::google::protobuf::int32 value) {
  set_has_layout();
  layout_ = value;
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.layout)
}

// optional bool is_row_major_layout = 6;
inline bool ShaderInterfaceBlockProto::has_is_row_major_layout() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_is_row_major_layout() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ShaderInterfaceBlockProto::clear_has_is_row_major_layout() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ShaderInterfaceBlockProto::clear_is_row_major_layout() {
  is_row_major_layout_ = false;
  clear_has_is_row_major_layout();
}
inline bool ShaderInterfaceBlockProto::is_row_major_layout() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.is_row_major_layout)
  return is_row_major_layout_;
}
inline void ShaderInterfaceBlockProto::set_is_row_major_layout(bool value) {
  set_has_is_row_major_layout();
  is_row_major_layout_ = value;
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.is_row_major_layout)
}

// optional bool static_use = 7;
inline bool ShaderInterfaceBlockProto::has_static_use() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ShaderInterfaceBlockProto::set_has_static_use() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ShaderInterfaceBlockProto::clear_has_static_use() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ShaderInterfaceBlockProto::clear_static_use() {
  static_use_ = false;
  clear_has_static_use();
}
inline bool ShaderInterfaceBlockProto::static_use() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.static_use)
  return static_use_;
}
inline void ShaderInterfaceBlockProto::set_static_use(bool value) {
  set_has_static_use();
  static_use_ = value;
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.static_use)
}

// repeated .ShaderInterfaceBlockFieldProto fields = 8;
inline int ShaderInterfaceBlockProto::fields_size() const {
  return fields_.size();
}
inline void ShaderInterfaceBlockProto::clear_fields() {
  fields_.Clear();
}
inline ::ShaderInterfaceBlockFieldProto* ShaderInterfaceBlockProto::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.fields)
  return fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ShaderInterfaceBlockFieldProto >*
ShaderInterfaceBlockProto::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:ShaderInterfaceBlockProto.fields)
  return &fields_;
}
inline const ::ShaderInterfaceBlockFieldProto& ShaderInterfaceBlockProto::fields(int index) const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.fields)
  return fields_.Get(index);
}
inline ::ShaderInterfaceBlockFieldProto* ShaderInterfaceBlockProto::add_fields() {
  // @@protoc_insertion_point(field_add:ShaderInterfaceBlockProto.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShaderInterfaceBlockFieldProto >&
ShaderInterfaceBlockProto::fields() const {
  // @@protoc_insertion_point(field_list:ShaderInterfaceBlockProto.fields)
  return fields_;
}

// -------------------------------------------------------------------

// ShaderProto

// optional bytes sha = 1;
inline bool ShaderProto::has_sha() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderProto::set_has_sha() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderProto::clear_has_sha() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderProto::clear_sha() {
  sha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sha();
}
inline const ::std::string& ShaderProto::sha() const {
  // @@protoc_insertion_point(field_get:ShaderProto.sha)
  return sha_.GetNoArena();
}
inline void ShaderProto::set_sha(const ::std::string& value) {
  set_has_sha();
  sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShaderProto.sha)
}
#if LANG_CXX11
inline void ShaderProto::set_sha(::std::string&& value) {
  set_has_sha();
  sha_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShaderProto.sha)
}
#endif
inline void ShaderProto::set_sha(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sha();
  sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShaderProto.sha)
}
inline void ShaderProto::set_sha(const void* value, size_t size) {
  set_has_sha();
  sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShaderProto.sha)
}
inline ::std::string* ShaderProto::mutable_sha() {
  set_has_sha();
  // @@protoc_insertion_point(field_mutable:ShaderProto.sha)
  return sha_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShaderProto::release_sha() {
  // @@protoc_insertion_point(field_release:ShaderProto.sha)
  if (!has_sha()) {
    return NULL;
  }
  clear_has_sha();
  return sha_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShaderProto::set_allocated_sha(::std::string* sha) {
  if (sha != NULL) {
    set_has_sha();
  } else {
    clear_has_sha();
  }
  sha_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha);
  // @@protoc_insertion_point(field_set_allocated:ShaderProto.sha)
}

// repeated .ShaderAttributeProto attribs = 2;
inline int ShaderProto::attribs_size() const {
  return attribs_.size();
}
inline void ShaderProto::clear_attribs() {
  attribs_.Clear();
}
inline ::ShaderAttributeProto* ShaderProto::mutable_attribs(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderProto.attribs)
  return attribs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ShaderAttributeProto >*
ShaderProto::mutable_attribs() {
  // @@protoc_insertion_point(field_mutable_list:ShaderProto.attribs)
  return &attribs_;
}
inline const ::ShaderAttributeProto& ShaderProto::attribs(int index) const {
  // @@protoc_insertion_point(field_get:ShaderProto.attribs)
  return attribs_.Get(index);
}
inline ::ShaderAttributeProto* ShaderProto::add_attribs() {
  // @@protoc_insertion_point(field_add:ShaderProto.attribs)
  return attribs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShaderAttributeProto >&
ShaderProto::attribs() const {
  // @@protoc_insertion_point(field_list:ShaderProto.attribs)
  return attribs_;
}

// repeated .ShaderUniformProto uniforms = 3;
inline int ShaderProto::uniforms_size() const {
  return uniforms_.size();
}
inline void ShaderProto::clear_uniforms() {
  uniforms_.Clear();
}
inline ::ShaderUniformProto* ShaderProto::mutable_uniforms(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderProto.uniforms)
  return uniforms_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ShaderUniformProto >*
ShaderProto::mutable_uniforms() {
  // @@protoc_insertion_point(field_mutable_list:ShaderProto.uniforms)
  return &uniforms_;
}
inline const ::ShaderUniformProto& ShaderProto::uniforms(int index) const {
  // @@protoc_insertion_point(field_get:ShaderProto.uniforms)
  return uniforms_.Get(index);
}
inline ::ShaderUniformProto* ShaderProto::add_uniforms() {
  // @@protoc_insertion_point(field_add:ShaderProto.uniforms)
  return uniforms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShaderUniformProto >&
ShaderProto::uniforms() const {
  // @@protoc_insertion_point(field_list:ShaderProto.uniforms)
  return uniforms_;
}

// repeated .ShaderVaryingProto varyings = 4;
inline int ShaderProto::varyings_size() const {
  return varyings_.size();
}
inline void ShaderProto::clear_varyings() {
  varyings_.Clear();
}
inline ::ShaderVaryingProto* ShaderProto::mutable_varyings(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderProto.varyings)
  return varyings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ShaderVaryingProto >*
ShaderProto::mutable_varyings() {
  // @@protoc_insertion_point(field_mutable_list:ShaderProto.varyings)
  return &varyings_;
}
inline const ::ShaderVaryingProto& ShaderProto::varyings(int index) const {
  // @@protoc_insertion_point(field_get:ShaderProto.varyings)
  return varyings_.Get(index);
}
inline ::ShaderVaryingProto* ShaderProto::add_varyings() {
  // @@protoc_insertion_point(field_add:ShaderProto.varyings)
  return varyings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShaderVaryingProto >&
ShaderProto::varyings() const {
  // @@protoc_insertion_point(field_list:ShaderProto.varyings)
  return varyings_;
}

// repeated .ShaderOutputVariableProto output_variables = 5;
inline int ShaderProto::output_variables_size() const {
  return output_variables_.size();
}
inline void ShaderProto::clear_output_variables() {
  output_variables_.Clear();
}
inline ::ShaderOutputVariableProto* ShaderProto::mutable_output_variables(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderProto.output_variables)
  return output_variables_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ShaderOutputVariableProto >*
ShaderProto::mutable_output_variables() {
  // @@protoc_insertion_point(field_mutable_list:ShaderProto.output_variables)
  return &output_variables_;
}
inline const ::ShaderOutputVariableProto& ShaderProto::output_variables(int index) const {
  // @@protoc_insertion_point(field_get:ShaderProto.output_variables)
  return output_variables_.Get(index);
}
inline ::ShaderOutputVariableProto* ShaderProto::add_output_variables() {
  // @@protoc_insertion_point(field_add:ShaderProto.output_variables)
  return output_variables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShaderOutputVariableProto >&
ShaderProto::output_variables() const {
  // @@protoc_insertion_point(field_list:ShaderProto.output_variables)
  return output_variables_;
}

// repeated .ShaderInterfaceBlockProto interface_blocks = 6;
inline int ShaderProto::interface_blocks_size() const {
  return interface_blocks_.size();
}
inline void ShaderProto::clear_interface_blocks() {
  interface_blocks_.Clear();
}
inline ::ShaderInterfaceBlockProto* ShaderProto::mutable_interface_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderProto.interface_blocks)
  return interface_blocks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ShaderInterfaceBlockProto >*
ShaderProto::mutable_interface_blocks() {
  // @@protoc_insertion_point(field_mutable_list:ShaderProto.interface_blocks)
  return &interface_blocks_;
}
inline const ::ShaderInterfaceBlockProto& ShaderProto::interface_blocks(int index) const {
  // @@protoc_insertion_point(field_get:ShaderProto.interface_blocks)
  return interface_blocks_.Get(index);
}
inline ::ShaderInterfaceBlockProto* ShaderProto::add_interface_blocks() {
  // @@protoc_insertion_point(field_add:ShaderProto.interface_blocks)
  return interface_blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShaderInterfaceBlockProto >&
ShaderProto::interface_blocks() const {
  // @@protoc_insertion_point(field_list:ShaderProto.interface_blocks)
  return interface_blocks_;
}

// -------------------------------------------------------------------

// GpuProgramProto

// optional bytes sha = 1;
inline bool GpuProgramProto::has_sha() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuProgramProto::set_has_sha() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuProgramProto::clear_has_sha() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuProgramProto::clear_sha() {
  sha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sha();
}
inline const ::std::string& GpuProgramProto::sha() const {
  // @@protoc_insertion_point(field_get:GpuProgramProto.sha)
  return sha_.GetNoArena();
}
inline void GpuProgramProto::set_sha(const ::std::string& value) {
  set_has_sha();
  sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GpuProgramProto.sha)
}
#if LANG_CXX11
inline void GpuProgramProto::set_sha(::std::string&& value) {
  set_has_sha();
  sha_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GpuProgramProto.sha)
}
#endif
inline void GpuProgramProto::set_sha(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sha();
  sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GpuProgramProto.sha)
}
inline void GpuProgramProto::set_sha(const void* value, size_t size) {
  set_has_sha();
  sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GpuProgramProto.sha)
}
inline ::std::string* GpuProgramProto::mutable_sha() {
  set_has_sha();
  // @@protoc_insertion_point(field_mutable:GpuProgramProto.sha)
  return sha_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuProgramProto::release_sha() {
  // @@protoc_insertion_point(field_release:GpuProgramProto.sha)
  if (!has_sha()) {
    return NULL;
  }
  clear_has_sha();
  return sha_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuProgramProto::set_allocated_sha(::std::string* sha) {
  if (sha != NULL) {
    set_has_sha();
  } else {
    clear_has_sha();
  }
  sha_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha);
  // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.sha)
}

// optional uint32 format = 2;
inline bool GpuProgramProto::has_format() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GpuProgramProto::set_has_format() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GpuProgramProto::clear_has_format() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GpuProgramProto::clear_format() {
  format_ = 0u;
  clear_has_format();
}
inline ::google::protobuf::uint32 GpuProgramProto::format() const {
  // @@protoc_insertion_point(field_get:GpuProgramProto.format)
  return format_;
}
inline void GpuProgramProto::set_format(::google::protobuf::uint32 value) {
  set_has_format();
  format_ = value;
  // @@protoc_insertion_point(field_set:GpuProgramProto.format)
}

// optional bytes program = 3;
inline bool GpuProgramProto::has_program() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuProgramProto::set_has_program() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpuProgramProto::clear_has_program() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpuProgramProto::clear_program() {
  program_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_program();
}
inline const ::std::string& GpuProgramProto::program() const {
  // @@protoc_insertion_point(field_get:GpuProgramProto.program)
  return program_.GetNoArena();
}
inline void GpuProgramProto::set_program(const ::std::string& value) {
  set_has_program();
  program_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GpuProgramProto.program)
}
#if LANG_CXX11
inline void GpuProgramProto::set_program(::std::string&& value) {
  set_has_program();
  program_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GpuProgramProto.program)
}
#endif
inline void GpuProgramProto::set_program(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_program();
  program_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GpuProgramProto.program)
}
inline void GpuProgramProto::set_program(const void* value, size_t size) {
  set_has_program();
  program_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GpuProgramProto.program)
}
inline ::std::string* GpuProgramProto::mutable_program() {
  set_has_program();
  // @@protoc_insertion_point(field_mutable:GpuProgramProto.program)
  return program_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuProgramProto::release_program() {
  // @@protoc_insertion_point(field_release:GpuProgramProto.program)
  if (!has_program()) {
    return NULL;
  }
  clear_has_program();
  return program_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuProgramProto::set_allocated_program(::std::string* program) {
  if (program != NULL) {
    set_has_program();
  } else {
    clear_has_program();
  }
  program_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), program);
  // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.program)
}

// optional bool program_is_compressed = 6;
inline bool GpuProgramProto::has_program_is_compressed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GpuProgramProto::set_has_program_is_compressed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GpuProgramProto::clear_has_program_is_compressed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GpuProgramProto::clear_program_is_compressed() {
  program_is_compressed_ = false;
  clear_has_program_is_compressed();
}
inline bool GpuProgramProto::program_is_compressed() const {
  // @@protoc_insertion_point(field_get:GpuProgramProto.program_is_compressed)
  return program_is_compressed_;
}
inline void GpuProgramProto::set_program_is_compressed(bool value) {
  set_has_program_is_compressed();
  program_is_compressed_ = value;
  // @@protoc_insertion_point(field_set:GpuProgramProto.program_is_compressed)
}

// optional uint32 program_decompressed_length = 7;
inline bool GpuProgramProto::has_program_decompressed_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GpuProgramProto::set_has_program_decompressed_length() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GpuProgramProto::clear_has_program_decompressed_length() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GpuProgramProto::clear_program_decompressed_length() {
  program_decompressed_length_ = 0u;
  clear_has_program_decompressed_length();
}
inline ::google::protobuf::uint32 GpuProgramProto::program_decompressed_length() const {
  // @@protoc_insertion_point(field_get:GpuProgramProto.program_decompressed_length)
  return program_decompressed_length_;
}
inline void GpuProgramProto::set_program_decompressed_length(::google::protobuf::uint32 value) {
  set_has_program_decompressed_length();
  program_decompressed_length_ = value;
  // @@protoc_insertion_point(field_set:GpuProgramProto.program_decompressed_length)
}

// optional .ShaderProto vertex_shader = 4;
inline bool GpuProgramProto::has_vertex_shader() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpuProgramProto::set_has_vertex_shader() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpuProgramProto::clear_has_vertex_shader() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpuProgramProto::clear_vertex_shader() {
  if (vertex_shader_ != NULL) vertex_shader_->Clear();
  clear_has_vertex_shader();
}
inline const ::ShaderProto& GpuProgramProto::_internal_vertex_shader() const {
  return *vertex_shader_;
}
inline const ::ShaderProto& GpuProgramProto::vertex_shader() const {
  const ::ShaderProto* p = vertex_shader_;
  // @@protoc_insertion_point(field_get:GpuProgramProto.vertex_shader)
  return p != NULL ? *p : *reinterpret_cast<const ::ShaderProto*>(
      &::_ShaderProto_default_instance_);
}
inline ::ShaderProto* GpuProgramProto::release_vertex_shader() {
  // @@protoc_insertion_point(field_release:GpuProgramProto.vertex_shader)
  clear_has_vertex_shader();
  ::ShaderProto* temp = vertex_shader_;
  vertex_shader_ = NULL;
  return temp;
}
inline ::ShaderProto* GpuProgramProto::mutable_vertex_shader() {
  set_has_vertex_shader();
  if (vertex_shader_ == NULL) {
    auto* p = CreateMaybeMessage<::ShaderProto>(GetArenaNoVirtual());
    vertex_shader_ = p;
  }
  // @@protoc_insertion_point(field_mutable:GpuProgramProto.vertex_shader)
  return vertex_shader_;
}
inline void GpuProgramProto::set_allocated_vertex_shader(::ShaderProto* vertex_shader) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vertex_shader_;
  }
  if (vertex_shader) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vertex_shader = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vertex_shader, submessage_arena);
    }
    set_has_vertex_shader();
  } else {
    clear_has_vertex_shader();
  }
  vertex_shader_ = vertex_shader;
  // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.vertex_shader)
}

// optional .ShaderProto fragment_shader = 5;
inline bool GpuProgramProto::has_fragment_shader() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GpuProgramProto::set_has_fragment_shader() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GpuProgramProto::clear_has_fragment_shader() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GpuProgramProto::clear_fragment_shader() {
  if (fragment_shader_ != NULL) fragment_shader_->Clear();
  clear_has_fragment_shader();
}
inline const ::ShaderProto& GpuProgramProto::_internal_fragment_shader() const {
  return *fragment_shader_;
}
inline const ::ShaderProto& GpuProgramProto::fragment_shader() const {
  const ::ShaderProto* p = fragment_shader_;
  // @@protoc_insertion_point(field_get:GpuProgramProto.fragment_shader)
  return p != NULL ? *p : *reinterpret_cast<const ::ShaderProto*>(
      &::_ShaderProto_default_instance_);
}
inline ::ShaderProto* GpuProgramProto::release_fragment_shader() {
  // @@protoc_insertion_point(field_release:GpuProgramProto.fragment_shader)
  clear_has_fragment_shader();
  ::ShaderProto* temp = fragment_shader_;
  fragment_shader_ = NULL;
  return temp;
}
inline ::ShaderProto* GpuProgramProto::mutable_fragment_shader() {
  set_has_fragment_shader();
  if (fragment_shader_ == NULL) {
    auto* p = CreateMaybeMessage<::ShaderProto>(GetArenaNoVirtual());
    fragment_shader_ = p;
  }
  // @@protoc_insertion_point(field_mutable:GpuProgramProto.fragment_shader)
  return fragment_shader_;
}
inline void GpuProgramProto::set_allocated_fragment_shader(::ShaderProto* fragment_shader) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fragment_shader_;
  }
  if (fragment_shader) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fragment_shader = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fragment_shader, submessage_arena);
    }
    set_has_fragment_shader();
  } else {
    clear_has_fragment_shader();
  }
  fragment_shader_ = fragment_shader;
  // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.fragment_shader)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_disk_5fcache_5fproto_2eproto
