// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef content_protocol_BackgroundService_h
#define content_protocol_BackgroundService_h

#include "content/common/content_export.h"
#include "content/browser/devtools/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.

namespace content {
namespace protocol {
namespace BackgroundService {

// ------------- Forward and enum declarations.
using ServiceName = String;
class EventMetadata;
class BackgroundServiceEvent;
class RecordingStateChangedNotification;
class BackgroundServiceEventReceivedNotification;

namespace ServiceNameEnum {
CONTENT_EXPORT extern const char BackgroundFetch[];
CONTENT_EXPORT extern const char BackgroundSync[];
} // namespace ServiceNameEnum

// ------------- Type and builder declarations.

class CONTENT_EXPORT EventMetadata : public Serializable{
    PROTOCOL_DISALLOW_COPY(EventMetadata);
public:
    static std::unique_ptr<EventMetadata> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~EventMetadata() override { }

    String GetKey() { return m_key; }
    void SetKey(const String& value) { m_key = value; }

    String GetValue() { return m_value; }
    void SetValue(const String& value) { m_value = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<EventMetadata> clone() const;

    template<int STATE>
    class EventMetadataBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            KeySet = 1 << 1,
            ValueSet = 1 << 2,
            AllFieldsSet = (KeySet | ValueSet | 0)};


        EventMetadataBuilder<STATE | KeySet>& SetKey(const String& value)
        {
            static_assert(!(STATE & KeySet), "property key should not be set yet");
            m_result->SetKey(value);
            return castState<KeySet>();
        }

        EventMetadataBuilder<STATE | ValueSet>& SetValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->SetValue(value);
            return castState<ValueSet>();
        }

        std::unique_ptr<EventMetadata> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class EventMetadata;
        EventMetadataBuilder() : m_result(new EventMetadata()) { }

        template<int STEP> EventMetadataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<EventMetadataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::BackgroundService::EventMetadata> m_result;
    };

    static EventMetadataBuilder<0> Create()
    {
        return EventMetadataBuilder<0>();
    }

private:
    EventMetadata()
    {
    }

    String m_key;
    String m_value;
};


class CONTENT_EXPORT BackgroundServiceEvent : public Serializable{
    PROTOCOL_DISALLOW_COPY(BackgroundServiceEvent);
public:
    static std::unique_ptr<BackgroundServiceEvent> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~BackgroundServiceEvent() override { }

    double GetTimestamp() { return m_timestamp; }
    void SetTimestamp(double value) { m_timestamp = value; }

    String GetOrigin() { return m_origin; }
    void SetOrigin(const String& value) { m_origin = value; }

    String GetServiceWorkerRegistrationId() { return m_serviceWorkerRegistrationId; }
    void SetServiceWorkerRegistrationId(const String& value) { m_serviceWorkerRegistrationId = value; }

    String GetService() { return m_service; }
    void SetService(const String& value) { m_service = value; }

    String GetEventName() { return m_eventName; }
    void SetEventName(const String& value) { m_eventName = value; }

    String GetInstanceId() { return m_instanceId; }
    void SetInstanceId(const String& value) { m_instanceId = value; }

    protocol::Array<protocol::BackgroundService::EventMetadata>* GetEventMetadata() { return m_eventMetadata.get(); }
    void SetEventMetadata(std::unique_ptr<protocol::Array<protocol::BackgroundService::EventMetadata>> value) { m_eventMetadata = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<BackgroundServiceEvent> clone() const;

    template<int STATE>
    class BackgroundServiceEventBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            TimestampSet = 1 << 1,
            OriginSet = 1 << 2,
            ServiceWorkerRegistrationIdSet = 1 << 3,
            ServiceSet = 1 << 4,
            EventNameSet = 1 << 5,
            InstanceIdSet = 1 << 6,
            EventMetadataSet = 1 << 7,
            AllFieldsSet = (TimestampSet | OriginSet | ServiceWorkerRegistrationIdSet | ServiceSet | EventNameSet | InstanceIdSet | EventMetadataSet | 0)};


        BackgroundServiceEventBuilder<STATE | TimestampSet>& SetTimestamp(double value)
        {
            static_assert(!(STATE & TimestampSet), "property timestamp should not be set yet");
            m_result->SetTimestamp(value);
            return castState<TimestampSet>();
        }

        BackgroundServiceEventBuilder<STATE | OriginSet>& SetOrigin(const String& value)
        {
            static_assert(!(STATE & OriginSet), "property origin should not be set yet");
            m_result->SetOrigin(value);
            return castState<OriginSet>();
        }

        BackgroundServiceEventBuilder<STATE | ServiceWorkerRegistrationIdSet>& SetServiceWorkerRegistrationId(const String& value)
        {
            static_assert(!(STATE & ServiceWorkerRegistrationIdSet), "property serviceWorkerRegistrationId should not be set yet");
            m_result->SetServiceWorkerRegistrationId(value);
            return castState<ServiceWorkerRegistrationIdSet>();
        }

        BackgroundServiceEventBuilder<STATE | ServiceSet>& SetService(const String& value)
        {
            static_assert(!(STATE & ServiceSet), "property service should not be set yet");
            m_result->SetService(value);
            return castState<ServiceSet>();
        }

        BackgroundServiceEventBuilder<STATE | EventNameSet>& SetEventName(const String& value)
        {
            static_assert(!(STATE & EventNameSet), "property eventName should not be set yet");
            m_result->SetEventName(value);
            return castState<EventNameSet>();
        }

        BackgroundServiceEventBuilder<STATE | InstanceIdSet>& SetInstanceId(const String& value)
        {
            static_assert(!(STATE & InstanceIdSet), "property instanceId should not be set yet");
            m_result->SetInstanceId(value);
            return castState<InstanceIdSet>();
        }

        BackgroundServiceEventBuilder<STATE | EventMetadataSet>& SetEventMetadata(std::unique_ptr<protocol::Array<protocol::BackgroundService::EventMetadata>> value)
        {
            static_assert(!(STATE & EventMetadataSet), "property eventMetadata should not be set yet");
            m_result->SetEventMetadata(std::move(value));
            return castState<EventMetadataSet>();
        }

        std::unique_ptr<BackgroundServiceEvent> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BackgroundServiceEvent;
        BackgroundServiceEventBuilder() : m_result(new BackgroundServiceEvent()) { }

        template<int STEP> BackgroundServiceEventBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BackgroundServiceEventBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::BackgroundService::BackgroundServiceEvent> m_result;
    };

    static BackgroundServiceEventBuilder<0> Create()
    {
        return BackgroundServiceEventBuilder<0>();
    }

private:
    BackgroundServiceEvent()
    {
          m_timestamp = 0;
    }

    double m_timestamp;
    String m_origin;
    String m_serviceWorkerRegistrationId;
    String m_service;
    String m_eventName;
    String m_instanceId;
    std::unique_ptr<protocol::Array<protocol::BackgroundService::EventMetadata>> m_eventMetadata;
};


class CONTENT_EXPORT RecordingStateChangedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(RecordingStateChangedNotification);
public:
    static std::unique_ptr<RecordingStateChangedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~RecordingStateChangedNotification() override { }

    bool GetIsRecording() { return m_isRecording; }
    void SetIsRecording(bool value) { m_isRecording = value; }

    String GetService() { return m_service; }
    void SetService(const String& value) { m_service = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<RecordingStateChangedNotification> clone() const;

    template<int STATE>
    class RecordingStateChangedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IsRecordingSet = 1 << 1,
            ServiceSet = 1 << 2,
            AllFieldsSet = (IsRecordingSet | ServiceSet | 0)};


        RecordingStateChangedNotificationBuilder<STATE | IsRecordingSet>& SetIsRecording(bool value)
        {
            static_assert(!(STATE & IsRecordingSet), "property isRecording should not be set yet");
            m_result->SetIsRecording(value);
            return castState<IsRecordingSet>();
        }

        RecordingStateChangedNotificationBuilder<STATE | ServiceSet>& SetService(const String& value)
        {
            static_assert(!(STATE & ServiceSet), "property service should not be set yet");
            m_result->SetService(value);
            return castState<ServiceSet>();
        }

        std::unique_ptr<RecordingStateChangedNotification> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class RecordingStateChangedNotification;
        RecordingStateChangedNotificationBuilder() : m_result(new RecordingStateChangedNotification()) { }

        template<int STEP> RecordingStateChangedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<RecordingStateChangedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::BackgroundService::RecordingStateChangedNotification> m_result;
    };

    static RecordingStateChangedNotificationBuilder<0> Create()
    {
        return RecordingStateChangedNotificationBuilder<0>();
    }

private:
    RecordingStateChangedNotification()
    {
          m_isRecording = false;
    }

    bool m_isRecording;
    String m_service;
};


class CONTENT_EXPORT BackgroundServiceEventReceivedNotification : public Serializable{
    PROTOCOL_DISALLOW_COPY(BackgroundServiceEventReceivedNotification);
public:
    static std::unique_ptr<BackgroundServiceEventReceivedNotification> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~BackgroundServiceEventReceivedNotification() override { }

    protocol::BackgroundService::BackgroundServiceEvent* GetBackgroundServiceEvent() { return m_backgroundServiceEvent.get(); }
    void SetBackgroundServiceEvent(std::unique_ptr<protocol::BackgroundService::BackgroundServiceEvent> value) { m_backgroundServiceEvent = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<BackgroundServiceEventReceivedNotification> clone() const;

    template<int STATE>
    class BackgroundServiceEventReceivedNotificationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            BackgroundServiceEventSet = 1 << 1,
            AllFieldsSet = (BackgroundServiceEventSet | 0)};


        BackgroundServiceEventReceivedNotificationBuilder<STATE | BackgroundServiceEventSet>& SetBackgroundServiceEvent(std::unique_ptr<protocol::BackgroundService::BackgroundServiceEvent> value)
        {
            static_assert(!(STATE & BackgroundServiceEventSet), "property backgroundServiceEvent should not be set yet");
            m_result->SetBackgroundServiceEvent(std::move(value));
            return castState<BackgroundServiceEventSet>();
        }

        std::unique_ptr<BackgroundServiceEventReceivedNotification> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BackgroundServiceEventReceivedNotification;
        BackgroundServiceEventReceivedNotificationBuilder() : m_result(new BackgroundServiceEventReceivedNotification()) { }

        template<int STEP> BackgroundServiceEventReceivedNotificationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BackgroundServiceEventReceivedNotificationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::BackgroundService::BackgroundServiceEventReceivedNotification> m_result;
    };

    static BackgroundServiceEventReceivedNotificationBuilder<0> Create()
    {
        return BackgroundServiceEventReceivedNotificationBuilder<0>();
    }

private:
    BackgroundServiceEventReceivedNotification()
    {
    }

    std::unique_ptr<protocol::BackgroundService::BackgroundServiceEvent> m_backgroundServiceEvent;
};


// ------------- Backend interface.

class CONTENT_EXPORT Backend {
public:
    virtual ~Backend() { }

    class CONTENT_EXPORT StartObservingCallback {
    public:
        virtual void sendSuccess() = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~StartObservingCallback() { }
    };
    virtual void StartObserving(const String& in_service, std::unique_ptr<StartObservingCallback> callback) = 0;
    virtual DispatchResponse StopObserving(const String& in_service) = 0;
    virtual DispatchResponse SetRecording(bool in_shouldRecord, const String& in_service) = 0;
    virtual DispatchResponse ClearEvents(const String& in_service) = 0;

    virtual DispatchResponse Disable()
    {
        return DispatchResponse::OK();
    }
};

// ------------- Frontend interface.

class CONTENT_EXPORT Frontend {
public:
    explicit Frontend(FrontendChannel* frontendChannel) : m_frontendChannel(frontendChannel) { }
    void RecordingStateChanged(bool isRecording, const String& service);
    void BackgroundServiceEventReceived(std::unique_ptr<protocol::BackgroundService::BackgroundServiceEvent> backgroundServiceEvent);

    void flush();
    void sendRawJSONNotification(String);
    void sendRawCBORNotification(std::vector<uint8_t>);
private:
    FrontendChannel* m_frontendChannel;
};

// ------------- Dispatcher.

class CONTENT_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CONTENT_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace BackgroundService
} // namespace content
} // namespace protocol

#endif // !defined(content_protocol_BackgroundService_h)
