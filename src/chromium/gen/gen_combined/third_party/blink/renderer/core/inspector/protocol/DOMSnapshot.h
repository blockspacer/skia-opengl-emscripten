// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_DOMSnapshot_h
#define blink_protocol_DOMSnapshot_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/Protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "third_party/blink/renderer/core/inspector/protocol/CSS.h"
#include "third_party/blink/renderer/core/inspector/protocol/DOM.h"
#include "third_party/blink/renderer/core/inspector/protocol/DOMDebugger.h"
#include "third_party/blink/renderer/core/inspector/protocol/Page.h"

namespace blink {
namespace protocol {
namespace DOMSnapshot {

// ------------- Forward and enum declarations.
class DOMNode;
class InlineTextBox;
class LayoutTreeNode;
class ComputedStyle;
class NameValue;
using StringIndex = int;
class RareStringData;
class RareBooleanData;
class RareIntegerData;
class DocumentSnapshot;
class NodeTreeSnapshot;
class LayoutTreeSnapshot;
class TextBoxSnapshot;

// ------------- Type and builder declarations.

class CORE_EXPORT DOMNode : public Serializable{
    PROTOCOL_DISALLOW_COPY(DOMNode);
public:
    static std::unique_ptr<DOMNode> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~DOMNode() override { }

    int getNodeType() { return m_nodeType; }
    void setNodeType(int value) { m_nodeType = value; }

    String getNodeName() { return m_nodeName; }
    void setNodeName(const String& value) { m_nodeName = value; }

    String getNodeValue() { return m_nodeValue; }
    void setNodeValue(const String& value) { m_nodeValue = value; }

    bool hasTextValue() { return m_textValue.isJust(); }
    String getTextValue(const String& defaultValue) { return m_textValue.isJust() ? m_textValue.fromJust() : defaultValue; }
    void setTextValue(const String& value) { m_textValue = value; }

    bool hasInputValue() { return m_inputValue.isJust(); }
    String getInputValue(const String& defaultValue) { return m_inputValue.isJust() ? m_inputValue.fromJust() : defaultValue; }
    void setInputValue(const String& value) { m_inputValue = value; }

    bool hasInputChecked() { return m_inputChecked.isJust(); }
    bool getInputChecked(bool defaultValue) { return m_inputChecked.isJust() ? m_inputChecked.fromJust() : defaultValue; }
    void setInputChecked(bool value) { m_inputChecked = value; }

    bool hasOptionSelected() { return m_optionSelected.isJust(); }
    bool getOptionSelected(bool defaultValue) { return m_optionSelected.isJust() ? m_optionSelected.fromJust() : defaultValue; }
    void setOptionSelected(bool value) { m_optionSelected = value; }

    int getBackendNodeId() { return m_backendNodeId; }
    void setBackendNodeId(int value) { m_backendNodeId = value; }

    bool hasChildNodeIndexes() { return m_childNodeIndexes.isJust(); }
    protocol::Array<int>* getChildNodeIndexes(protocol::Array<int>* defaultValue) { return m_childNodeIndexes.isJust() ? m_childNodeIndexes.fromJust() : defaultValue; }
    void setChildNodeIndexes(std::unique_ptr<protocol::Array<int>> value) { m_childNodeIndexes = std::move(value); }

    bool hasAttributes() { return m_attributes.isJust(); }
    protocol::Array<protocol::DOMSnapshot::NameValue>* getAttributes(protocol::Array<protocol::DOMSnapshot::NameValue>* defaultValue) { return m_attributes.isJust() ? m_attributes.fromJust() : defaultValue; }
    void setAttributes(std::unique_ptr<protocol::Array<protocol::DOMSnapshot::NameValue>> value) { m_attributes = std::move(value); }

    bool hasPseudoElementIndexes() { return m_pseudoElementIndexes.isJust(); }
    protocol::Array<int>* getPseudoElementIndexes(protocol::Array<int>* defaultValue) { return m_pseudoElementIndexes.isJust() ? m_pseudoElementIndexes.fromJust() : defaultValue; }
    void setPseudoElementIndexes(std::unique_ptr<protocol::Array<int>> value) { m_pseudoElementIndexes = std::move(value); }

    bool hasLayoutNodeIndex() { return m_layoutNodeIndex.isJust(); }
    int getLayoutNodeIndex(int defaultValue) { return m_layoutNodeIndex.isJust() ? m_layoutNodeIndex.fromJust() : defaultValue; }
    void setLayoutNodeIndex(int value) { m_layoutNodeIndex = value; }

    bool hasDocumentURL() { return m_documentURL.isJust(); }
    String getDocumentURL(const String& defaultValue) { return m_documentURL.isJust() ? m_documentURL.fromJust() : defaultValue; }
    void setDocumentURL(const String& value) { m_documentURL = value; }

    bool hasBaseURL() { return m_baseURL.isJust(); }
    String getBaseURL(const String& defaultValue) { return m_baseURL.isJust() ? m_baseURL.fromJust() : defaultValue; }
    void setBaseURL(const String& value) { m_baseURL = value; }

    bool hasContentLanguage() { return m_contentLanguage.isJust(); }
    String getContentLanguage(const String& defaultValue) { return m_contentLanguage.isJust() ? m_contentLanguage.fromJust() : defaultValue; }
    void setContentLanguage(const String& value) { m_contentLanguage = value; }

    bool hasDocumentEncoding() { return m_documentEncoding.isJust(); }
    String getDocumentEncoding(const String& defaultValue) { return m_documentEncoding.isJust() ? m_documentEncoding.fromJust() : defaultValue; }
    void setDocumentEncoding(const String& value) { m_documentEncoding = value; }

    bool hasPublicId() { return m_publicId.isJust(); }
    String getPublicId(const String& defaultValue) { return m_publicId.isJust() ? m_publicId.fromJust() : defaultValue; }
    void setPublicId(const String& value) { m_publicId = value; }

    bool hasSystemId() { return m_systemId.isJust(); }
    String getSystemId(const String& defaultValue) { return m_systemId.isJust() ? m_systemId.fromJust() : defaultValue; }
    void setSystemId(const String& value) { m_systemId = value; }

    bool hasFrameId() { return m_frameId.isJust(); }
    String getFrameId(const String& defaultValue) { return m_frameId.isJust() ? m_frameId.fromJust() : defaultValue; }
    void setFrameId(const String& value) { m_frameId = value; }

    bool hasContentDocumentIndex() { return m_contentDocumentIndex.isJust(); }
    int getContentDocumentIndex(int defaultValue) { return m_contentDocumentIndex.isJust() ? m_contentDocumentIndex.fromJust() : defaultValue; }
    void setContentDocumentIndex(int value) { m_contentDocumentIndex = value; }

    bool hasPseudoType() { return m_pseudoType.isJust(); }
    String getPseudoType(const String& defaultValue) { return m_pseudoType.isJust() ? m_pseudoType.fromJust() : defaultValue; }
    void setPseudoType(const String& value) { m_pseudoType = value; }

    bool hasShadowRootType() { return m_shadowRootType.isJust(); }
    String getShadowRootType(const String& defaultValue) { return m_shadowRootType.isJust() ? m_shadowRootType.fromJust() : defaultValue; }
    void setShadowRootType(const String& value) { m_shadowRootType = value; }

    bool hasIsClickable() { return m_isClickable.isJust(); }
    bool getIsClickable(bool defaultValue) { return m_isClickable.isJust() ? m_isClickable.fromJust() : defaultValue; }
    void setIsClickable(bool value) { m_isClickable = value; }

    bool hasEventListeners() { return m_eventListeners.isJust(); }
    protocol::Array<protocol::DOMDebugger::EventListener>* getEventListeners(protocol::Array<protocol::DOMDebugger::EventListener>* defaultValue) { return m_eventListeners.isJust() ? m_eventListeners.fromJust() : defaultValue; }
    void setEventListeners(std::unique_ptr<protocol::Array<protocol::DOMDebugger::EventListener>> value) { m_eventListeners = std::move(value); }

    bool hasCurrentSourceURL() { return m_currentSourceURL.isJust(); }
    String getCurrentSourceURL(const String& defaultValue) { return m_currentSourceURL.isJust() ? m_currentSourceURL.fromJust() : defaultValue; }
    void setCurrentSourceURL(const String& value) { m_currentSourceURL = value; }

    bool hasOriginURL() { return m_originURL.isJust(); }
    String getOriginURL(const String& defaultValue) { return m_originURL.isJust() ? m_originURL.fromJust() : defaultValue; }
    void setOriginURL(const String& value) { m_originURL = value; }

    bool hasScrollOffsetX() { return m_scrollOffsetX.isJust(); }
    double getScrollOffsetX(double defaultValue) { return m_scrollOffsetX.isJust() ? m_scrollOffsetX.fromJust() : defaultValue; }
    void setScrollOffsetX(double value) { m_scrollOffsetX = value; }

    bool hasScrollOffsetY() { return m_scrollOffsetY.isJust(); }
    double getScrollOffsetY(double defaultValue) { return m_scrollOffsetY.isJust() ? m_scrollOffsetY.fromJust() : defaultValue; }
    void setScrollOffsetY(double value) { m_scrollOffsetY = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<DOMNode> clone() const;

    template<int STATE>
    class DOMNodeBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NodeTypeSet = 1 << 1,
            NodeNameSet = 1 << 2,
            NodeValueSet = 1 << 3,
            BackendNodeIdSet = 1 << 4,
            AllFieldsSet = (NodeTypeSet | NodeNameSet | NodeValueSet | BackendNodeIdSet | 0)};


        DOMNodeBuilder<STATE | NodeTypeSet>& setNodeType(int value)
        {
            static_assert(!(STATE & NodeTypeSet), "property nodeType should not be set yet");
            m_result->setNodeType(value);
            return castState<NodeTypeSet>();
        }

        DOMNodeBuilder<STATE | NodeNameSet>& setNodeName(const String& value)
        {
            static_assert(!(STATE & NodeNameSet), "property nodeName should not be set yet");
            m_result->setNodeName(value);
            return castState<NodeNameSet>();
        }

        DOMNodeBuilder<STATE | NodeValueSet>& setNodeValue(const String& value)
        {
            static_assert(!(STATE & NodeValueSet), "property nodeValue should not be set yet");
            m_result->setNodeValue(value);
            return castState<NodeValueSet>();
        }

        DOMNodeBuilder<STATE>& setTextValue(const String& value)
        {
            m_result->setTextValue(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setInputValue(const String& value)
        {
            m_result->setInputValue(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setInputChecked(bool value)
        {
            m_result->setInputChecked(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setOptionSelected(bool value)
        {
            m_result->setOptionSelected(value);
            return *this;
        }

        DOMNodeBuilder<STATE | BackendNodeIdSet>& setBackendNodeId(int value)
        {
            static_assert(!(STATE & BackendNodeIdSet), "property backendNodeId should not be set yet");
            m_result->setBackendNodeId(value);
            return castState<BackendNodeIdSet>();
        }

        DOMNodeBuilder<STATE>& setChildNodeIndexes(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setChildNodeIndexes(std::move(value));
            return *this;
        }

        DOMNodeBuilder<STATE>& setAttributes(std::unique_ptr<protocol::Array<protocol::DOMSnapshot::NameValue>> value)
        {
            m_result->setAttributes(std::move(value));
            return *this;
        }

        DOMNodeBuilder<STATE>& setPseudoElementIndexes(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setPseudoElementIndexes(std::move(value));
            return *this;
        }

        DOMNodeBuilder<STATE>& setLayoutNodeIndex(int value)
        {
            m_result->setLayoutNodeIndex(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setDocumentURL(const String& value)
        {
            m_result->setDocumentURL(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setBaseURL(const String& value)
        {
            m_result->setBaseURL(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setContentLanguage(const String& value)
        {
            m_result->setContentLanguage(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setDocumentEncoding(const String& value)
        {
            m_result->setDocumentEncoding(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setPublicId(const String& value)
        {
            m_result->setPublicId(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setSystemId(const String& value)
        {
            m_result->setSystemId(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setFrameId(const String& value)
        {
            m_result->setFrameId(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setContentDocumentIndex(int value)
        {
            m_result->setContentDocumentIndex(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setPseudoType(const String& value)
        {
            m_result->setPseudoType(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setShadowRootType(const String& value)
        {
            m_result->setShadowRootType(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setIsClickable(bool value)
        {
            m_result->setIsClickable(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setEventListeners(std::unique_ptr<protocol::Array<protocol::DOMDebugger::EventListener>> value)
        {
            m_result->setEventListeners(std::move(value));
            return *this;
        }

        DOMNodeBuilder<STATE>& setCurrentSourceURL(const String& value)
        {
            m_result->setCurrentSourceURL(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setOriginURL(const String& value)
        {
            m_result->setOriginURL(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setScrollOffsetX(double value)
        {
            m_result->setScrollOffsetX(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setScrollOffsetY(double value)
        {
            m_result->setScrollOffsetY(value);
            return *this;
        }

        std::unique_ptr<DOMNode> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class DOMNode;
        DOMNodeBuilder() : m_result(new DOMNode()) { }

        template<int STEP> DOMNodeBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<DOMNodeBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::DOMNode> m_result;
    };

    static DOMNodeBuilder<0> create()
    {
        return DOMNodeBuilder<0>();
    }

private:
    DOMNode()
    {
          m_nodeType = 0;
          m_backendNodeId = 0;
    }

    int m_nodeType;
    String m_nodeName;
    String m_nodeValue;
    Maybe<String> m_textValue;
    Maybe<String> m_inputValue;
    Maybe<bool> m_inputChecked;
    Maybe<bool> m_optionSelected;
    int m_backendNodeId;
    Maybe<protocol::Array<int>> m_childNodeIndexes;
    Maybe<protocol::Array<protocol::DOMSnapshot::NameValue>> m_attributes;
    Maybe<protocol::Array<int>> m_pseudoElementIndexes;
    Maybe<int> m_layoutNodeIndex;
    Maybe<String> m_documentURL;
    Maybe<String> m_baseURL;
    Maybe<String> m_contentLanguage;
    Maybe<String> m_documentEncoding;
    Maybe<String> m_publicId;
    Maybe<String> m_systemId;
    Maybe<String> m_frameId;
    Maybe<int> m_contentDocumentIndex;
    Maybe<String> m_pseudoType;
    Maybe<String> m_shadowRootType;
    Maybe<bool> m_isClickable;
    Maybe<protocol::Array<protocol::DOMDebugger::EventListener>> m_eventListeners;
    Maybe<String> m_currentSourceURL;
    Maybe<String> m_originURL;
    Maybe<double> m_scrollOffsetX;
    Maybe<double> m_scrollOffsetY;
};


class CORE_EXPORT InlineTextBox : public Serializable{
    PROTOCOL_DISALLOW_COPY(InlineTextBox);
public:
    static std::unique_ptr<InlineTextBox> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~InlineTextBox() override { }

    protocol::DOM::Rect* getBoundingBox() { return m_boundingBox.get(); }
    void setBoundingBox(std::unique_ptr<protocol::DOM::Rect> value) { m_boundingBox = std::move(value); }

    int getStartCharacterIndex() { return m_startCharacterIndex; }
    void setStartCharacterIndex(int value) { m_startCharacterIndex = value; }

    int getNumCharacters() { return m_numCharacters; }
    void setNumCharacters(int value) { m_numCharacters = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<InlineTextBox> clone() const;

    template<int STATE>
    class InlineTextBoxBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            BoundingBoxSet = 1 << 1,
            StartCharacterIndexSet = 1 << 2,
            NumCharactersSet = 1 << 3,
            AllFieldsSet = (BoundingBoxSet | StartCharacterIndexSet | NumCharactersSet | 0)};


        InlineTextBoxBuilder<STATE | BoundingBoxSet>& setBoundingBox(std::unique_ptr<protocol::DOM::Rect> value)
        {
            static_assert(!(STATE & BoundingBoxSet), "property boundingBox should not be set yet");
            m_result->setBoundingBox(std::move(value));
            return castState<BoundingBoxSet>();
        }

        InlineTextBoxBuilder<STATE | StartCharacterIndexSet>& setStartCharacterIndex(int value)
        {
            static_assert(!(STATE & StartCharacterIndexSet), "property startCharacterIndex should not be set yet");
            m_result->setStartCharacterIndex(value);
            return castState<StartCharacterIndexSet>();
        }

        InlineTextBoxBuilder<STATE | NumCharactersSet>& setNumCharacters(int value)
        {
            static_assert(!(STATE & NumCharactersSet), "property numCharacters should not be set yet");
            m_result->setNumCharacters(value);
            return castState<NumCharactersSet>();
        }

        std::unique_ptr<InlineTextBox> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InlineTextBox;
        InlineTextBoxBuilder() : m_result(new InlineTextBox()) { }

        template<int STEP> InlineTextBoxBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InlineTextBoxBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::InlineTextBox> m_result;
    };

    static InlineTextBoxBuilder<0> create()
    {
        return InlineTextBoxBuilder<0>();
    }

private:
    InlineTextBox()
    {
          m_startCharacterIndex = 0;
          m_numCharacters = 0;
    }

    std::unique_ptr<protocol::DOM::Rect> m_boundingBox;
    int m_startCharacterIndex;
    int m_numCharacters;
};


class CORE_EXPORT LayoutTreeNode : public Serializable{
    PROTOCOL_DISALLOW_COPY(LayoutTreeNode);
public:
    static std::unique_ptr<LayoutTreeNode> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~LayoutTreeNode() override { }

    int getDomNodeIndex() { return m_domNodeIndex; }
    void setDomNodeIndex(int value) { m_domNodeIndex = value; }

    protocol::DOM::Rect* getBoundingBox() { return m_boundingBox.get(); }
    void setBoundingBox(std::unique_ptr<protocol::DOM::Rect> value) { m_boundingBox = std::move(value); }

    bool hasLayoutText() { return m_layoutText.isJust(); }
    String getLayoutText(const String& defaultValue) { return m_layoutText.isJust() ? m_layoutText.fromJust() : defaultValue; }
    void setLayoutText(const String& value) { m_layoutText = value; }

    bool hasInlineTextNodes() { return m_inlineTextNodes.isJust(); }
    protocol::Array<protocol::DOMSnapshot::InlineTextBox>* getInlineTextNodes(protocol::Array<protocol::DOMSnapshot::InlineTextBox>* defaultValue) { return m_inlineTextNodes.isJust() ? m_inlineTextNodes.fromJust() : defaultValue; }
    void setInlineTextNodes(std::unique_ptr<protocol::Array<protocol::DOMSnapshot::InlineTextBox>> value) { m_inlineTextNodes = std::move(value); }

    bool hasStyleIndex() { return m_styleIndex.isJust(); }
    int getStyleIndex(int defaultValue) { return m_styleIndex.isJust() ? m_styleIndex.fromJust() : defaultValue; }
    void setStyleIndex(int value) { m_styleIndex = value; }

    bool hasPaintOrder() { return m_paintOrder.isJust(); }
    int getPaintOrder(int defaultValue) { return m_paintOrder.isJust() ? m_paintOrder.fromJust() : defaultValue; }
    void setPaintOrder(int value) { m_paintOrder = value; }

    bool hasIsStackingContext() { return m_isStackingContext.isJust(); }
    bool getIsStackingContext(bool defaultValue) { return m_isStackingContext.isJust() ? m_isStackingContext.fromJust() : defaultValue; }
    void setIsStackingContext(bool value) { m_isStackingContext = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<LayoutTreeNode> clone() const;

    template<int STATE>
    class LayoutTreeNodeBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            DomNodeIndexSet = 1 << 1,
            BoundingBoxSet = 1 << 2,
            AllFieldsSet = (DomNodeIndexSet | BoundingBoxSet | 0)};


        LayoutTreeNodeBuilder<STATE | DomNodeIndexSet>& setDomNodeIndex(int value)
        {
            static_assert(!(STATE & DomNodeIndexSet), "property domNodeIndex should not be set yet");
            m_result->setDomNodeIndex(value);
            return castState<DomNodeIndexSet>();
        }

        LayoutTreeNodeBuilder<STATE | BoundingBoxSet>& setBoundingBox(std::unique_ptr<protocol::DOM::Rect> value)
        {
            static_assert(!(STATE & BoundingBoxSet), "property boundingBox should not be set yet");
            m_result->setBoundingBox(std::move(value));
            return castState<BoundingBoxSet>();
        }

        LayoutTreeNodeBuilder<STATE>& setLayoutText(const String& value)
        {
            m_result->setLayoutText(value);
            return *this;
        }

        LayoutTreeNodeBuilder<STATE>& setInlineTextNodes(std::unique_ptr<protocol::Array<protocol::DOMSnapshot::InlineTextBox>> value)
        {
            m_result->setInlineTextNodes(std::move(value));
            return *this;
        }

        LayoutTreeNodeBuilder<STATE>& setStyleIndex(int value)
        {
            m_result->setStyleIndex(value);
            return *this;
        }

        LayoutTreeNodeBuilder<STATE>& setPaintOrder(int value)
        {
            m_result->setPaintOrder(value);
            return *this;
        }

        LayoutTreeNodeBuilder<STATE>& setIsStackingContext(bool value)
        {
            m_result->setIsStackingContext(value);
            return *this;
        }

        std::unique_ptr<LayoutTreeNode> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class LayoutTreeNode;
        LayoutTreeNodeBuilder() : m_result(new LayoutTreeNode()) { }

        template<int STEP> LayoutTreeNodeBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<LayoutTreeNodeBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::LayoutTreeNode> m_result;
    };

    static LayoutTreeNodeBuilder<0> create()
    {
        return LayoutTreeNodeBuilder<0>();
    }

private:
    LayoutTreeNode()
    {
          m_domNodeIndex = 0;
    }

    int m_domNodeIndex;
    std::unique_ptr<protocol::DOM::Rect> m_boundingBox;
    Maybe<String> m_layoutText;
    Maybe<protocol::Array<protocol::DOMSnapshot::InlineTextBox>> m_inlineTextNodes;
    Maybe<int> m_styleIndex;
    Maybe<int> m_paintOrder;
    Maybe<bool> m_isStackingContext;
};


class CORE_EXPORT ComputedStyle : public Serializable{
    PROTOCOL_DISALLOW_COPY(ComputedStyle);
public:
    static std::unique_ptr<ComputedStyle> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~ComputedStyle() override { }

    protocol::Array<protocol::DOMSnapshot::NameValue>* getProperties() { return m_properties.get(); }
    void setProperties(std::unique_ptr<protocol::Array<protocol::DOMSnapshot::NameValue>> value) { m_properties = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<ComputedStyle> clone() const;

    template<int STATE>
    class ComputedStyleBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            PropertiesSet = 1 << 1,
            AllFieldsSet = (PropertiesSet | 0)};


        ComputedStyleBuilder<STATE | PropertiesSet>& setProperties(std::unique_ptr<protocol::Array<protocol::DOMSnapshot::NameValue>> value)
        {
            static_assert(!(STATE & PropertiesSet), "property properties should not be set yet");
            m_result->setProperties(std::move(value));
            return castState<PropertiesSet>();
        }

        std::unique_ptr<ComputedStyle> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ComputedStyle;
        ComputedStyleBuilder() : m_result(new ComputedStyle()) { }

        template<int STEP> ComputedStyleBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ComputedStyleBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::ComputedStyle> m_result;
    };

    static ComputedStyleBuilder<0> create()
    {
        return ComputedStyleBuilder<0>();
    }

private:
    ComputedStyle()
    {
    }

    std::unique_ptr<protocol::Array<protocol::DOMSnapshot::NameValue>> m_properties;
};


class CORE_EXPORT NameValue : public Serializable{
    PROTOCOL_DISALLOW_COPY(NameValue);
public:
    static std::unique_ptr<NameValue> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~NameValue() override { }

    String getName() { return m_name; }
    void setName(const String& value) { m_name = value; }

    String getValue() { return m_value; }
    void setValue(const String& value) { m_value = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<NameValue> clone() const;

    template<int STATE>
    class NameValueBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            ValueSet = 1 << 2,
            AllFieldsSet = (NameSet | ValueSet | 0)};


        NameValueBuilder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setName(value);
            return castState<NameSet>();
        }

        NameValueBuilder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        std::unique_ptr<NameValue> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class NameValue;
        NameValueBuilder() : m_result(new NameValue()) { }

        template<int STEP> NameValueBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<NameValueBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::NameValue> m_result;
    };

    static NameValueBuilder<0> create()
    {
        return NameValueBuilder<0>();
    }

private:
    NameValue()
    {
    }

    String m_name;
    String m_value;
};


class CORE_EXPORT RareStringData : public Serializable{
    PROTOCOL_DISALLOW_COPY(RareStringData);
public:
    static std::unique_ptr<RareStringData> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~RareStringData() override { }

    protocol::Array<int>* getIndex() { return m_index.get(); }
    void setIndex(std::unique_ptr<protocol::Array<int>> value) { m_index = std::move(value); }

    protocol::Array<int>* getValue() { return m_value.get(); }
    void setValue(std::unique_ptr<protocol::Array<int>> value) { m_value = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<RareStringData> clone() const;

    template<int STATE>
    class RareStringDataBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IndexSet = 1 << 1,
            ValueSet = 1 << 2,
            AllFieldsSet = (IndexSet | ValueSet | 0)};


        RareStringDataBuilder<STATE | IndexSet>& setIndex(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & IndexSet), "property index should not be set yet");
            m_result->setIndex(std::move(value));
            return castState<IndexSet>();
        }

        RareStringDataBuilder<STATE | ValueSet>& setValue(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(std::move(value));
            return castState<ValueSet>();
        }

        std::unique_ptr<RareStringData> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class RareStringData;
        RareStringDataBuilder() : m_result(new RareStringData()) { }

        template<int STEP> RareStringDataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<RareStringDataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::RareStringData> m_result;
    };

    static RareStringDataBuilder<0> create()
    {
        return RareStringDataBuilder<0>();
    }

private:
    RareStringData()
    {
    }

    std::unique_ptr<protocol::Array<int>> m_index;
    std::unique_ptr<protocol::Array<int>> m_value;
};


class CORE_EXPORT RareBooleanData : public Serializable{
    PROTOCOL_DISALLOW_COPY(RareBooleanData);
public:
    static std::unique_ptr<RareBooleanData> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~RareBooleanData() override { }

    protocol::Array<int>* getIndex() { return m_index.get(); }
    void setIndex(std::unique_ptr<protocol::Array<int>> value) { m_index = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<RareBooleanData> clone() const;

    template<int STATE>
    class RareBooleanDataBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IndexSet = 1 << 1,
            AllFieldsSet = (IndexSet | 0)};


        RareBooleanDataBuilder<STATE | IndexSet>& setIndex(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & IndexSet), "property index should not be set yet");
            m_result->setIndex(std::move(value));
            return castState<IndexSet>();
        }

        std::unique_ptr<RareBooleanData> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class RareBooleanData;
        RareBooleanDataBuilder() : m_result(new RareBooleanData()) { }

        template<int STEP> RareBooleanDataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<RareBooleanDataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> m_result;
    };

    static RareBooleanDataBuilder<0> create()
    {
        return RareBooleanDataBuilder<0>();
    }

private:
    RareBooleanData()
    {
    }

    std::unique_ptr<protocol::Array<int>> m_index;
};


class CORE_EXPORT RareIntegerData : public Serializable{
    PROTOCOL_DISALLOW_COPY(RareIntegerData);
public:
    static std::unique_ptr<RareIntegerData> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~RareIntegerData() override { }

    protocol::Array<int>* getIndex() { return m_index.get(); }
    void setIndex(std::unique_ptr<protocol::Array<int>> value) { m_index = std::move(value); }

    protocol::Array<int>* getValue() { return m_value.get(); }
    void setValue(std::unique_ptr<protocol::Array<int>> value) { m_value = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<RareIntegerData> clone() const;

    template<int STATE>
    class RareIntegerDataBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IndexSet = 1 << 1,
            ValueSet = 1 << 2,
            AllFieldsSet = (IndexSet | ValueSet | 0)};


        RareIntegerDataBuilder<STATE | IndexSet>& setIndex(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & IndexSet), "property index should not be set yet");
            m_result->setIndex(std::move(value));
            return castState<IndexSet>();
        }

        RareIntegerDataBuilder<STATE | ValueSet>& setValue(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(std::move(value));
            return castState<ValueSet>();
        }

        std::unique_ptr<RareIntegerData> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class RareIntegerData;
        RareIntegerDataBuilder() : m_result(new RareIntegerData()) { }

        template<int STEP> RareIntegerDataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<RareIntegerDataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::RareIntegerData> m_result;
    };

    static RareIntegerDataBuilder<0> create()
    {
        return RareIntegerDataBuilder<0>();
    }

private:
    RareIntegerData()
    {
    }

    std::unique_ptr<protocol::Array<int>> m_index;
    std::unique_ptr<protocol::Array<int>> m_value;
};


class CORE_EXPORT DocumentSnapshot : public Serializable{
    PROTOCOL_DISALLOW_COPY(DocumentSnapshot);
public:
    static std::unique_ptr<DocumentSnapshot> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~DocumentSnapshot() override { }

    int getDocumentURL() { return m_documentURL; }
    void setDocumentURL(int value) { m_documentURL = value; }

    int getBaseURL() { return m_baseURL; }
    void setBaseURL(int value) { m_baseURL = value; }

    int getContentLanguage() { return m_contentLanguage; }
    void setContentLanguage(int value) { m_contentLanguage = value; }

    int getEncodingName() { return m_encodingName; }
    void setEncodingName(int value) { m_encodingName = value; }

    int getPublicId() { return m_publicId; }
    void setPublicId(int value) { m_publicId = value; }

    int getSystemId() { return m_systemId; }
    void setSystemId(int value) { m_systemId = value; }

    int getFrameId() { return m_frameId; }
    void setFrameId(int value) { m_frameId = value; }

    protocol::DOMSnapshot::NodeTreeSnapshot* getNodes() { return m_nodes.get(); }
    void setNodes(std::unique_ptr<protocol::DOMSnapshot::NodeTreeSnapshot> value) { m_nodes = std::move(value); }

    protocol::DOMSnapshot::LayoutTreeSnapshot* getLayout() { return m_layout.get(); }
    void setLayout(std::unique_ptr<protocol::DOMSnapshot::LayoutTreeSnapshot> value) { m_layout = std::move(value); }

    protocol::DOMSnapshot::TextBoxSnapshot* getTextBoxes() { return m_textBoxes.get(); }
    void setTextBoxes(std::unique_ptr<protocol::DOMSnapshot::TextBoxSnapshot> value) { m_textBoxes = std::move(value); }

    bool hasScrollOffsetX() { return m_scrollOffsetX.isJust(); }
    double getScrollOffsetX(double defaultValue) { return m_scrollOffsetX.isJust() ? m_scrollOffsetX.fromJust() : defaultValue; }
    void setScrollOffsetX(double value) { m_scrollOffsetX = value; }

    bool hasScrollOffsetY() { return m_scrollOffsetY.isJust(); }
    double getScrollOffsetY(double defaultValue) { return m_scrollOffsetY.isJust() ? m_scrollOffsetY.fromJust() : defaultValue; }
    void setScrollOffsetY(double value) { m_scrollOffsetY = value; }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<DocumentSnapshot> clone() const;

    template<int STATE>
    class DocumentSnapshotBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            DocumentURLSet = 1 << 1,
            BaseURLSet = 1 << 2,
            ContentLanguageSet = 1 << 3,
            EncodingNameSet = 1 << 4,
            PublicIdSet = 1 << 5,
            SystemIdSet = 1 << 6,
            FrameIdSet = 1 << 7,
            NodesSet = 1 << 8,
            LayoutSet = 1 << 9,
            TextBoxesSet = 1 << 10,
            AllFieldsSet = (DocumentURLSet | BaseURLSet | ContentLanguageSet | EncodingNameSet | PublicIdSet | SystemIdSet | FrameIdSet | NodesSet | LayoutSet | TextBoxesSet | 0)};


        DocumentSnapshotBuilder<STATE | DocumentURLSet>& setDocumentURL(int value)
        {
            static_assert(!(STATE & DocumentURLSet), "property documentURL should not be set yet");
            m_result->setDocumentURL(value);
            return castState<DocumentURLSet>();
        }

        DocumentSnapshotBuilder<STATE | BaseURLSet>& setBaseURL(int value)
        {
            static_assert(!(STATE & BaseURLSet), "property baseURL should not be set yet");
            m_result->setBaseURL(value);
            return castState<BaseURLSet>();
        }

        DocumentSnapshotBuilder<STATE | ContentLanguageSet>& setContentLanguage(int value)
        {
            static_assert(!(STATE & ContentLanguageSet), "property contentLanguage should not be set yet");
            m_result->setContentLanguage(value);
            return castState<ContentLanguageSet>();
        }

        DocumentSnapshotBuilder<STATE | EncodingNameSet>& setEncodingName(int value)
        {
            static_assert(!(STATE & EncodingNameSet), "property encodingName should not be set yet");
            m_result->setEncodingName(value);
            return castState<EncodingNameSet>();
        }

        DocumentSnapshotBuilder<STATE | PublicIdSet>& setPublicId(int value)
        {
            static_assert(!(STATE & PublicIdSet), "property publicId should not be set yet");
            m_result->setPublicId(value);
            return castState<PublicIdSet>();
        }

        DocumentSnapshotBuilder<STATE | SystemIdSet>& setSystemId(int value)
        {
            static_assert(!(STATE & SystemIdSet), "property systemId should not be set yet");
            m_result->setSystemId(value);
            return castState<SystemIdSet>();
        }

        DocumentSnapshotBuilder<STATE | FrameIdSet>& setFrameId(int value)
        {
            static_assert(!(STATE & FrameIdSet), "property frameId should not be set yet");
            m_result->setFrameId(value);
            return castState<FrameIdSet>();
        }

        DocumentSnapshotBuilder<STATE | NodesSet>& setNodes(std::unique_ptr<protocol::DOMSnapshot::NodeTreeSnapshot> value)
        {
            static_assert(!(STATE & NodesSet), "property nodes should not be set yet");
            m_result->setNodes(std::move(value));
            return castState<NodesSet>();
        }

        DocumentSnapshotBuilder<STATE | LayoutSet>& setLayout(std::unique_ptr<protocol::DOMSnapshot::LayoutTreeSnapshot> value)
        {
            static_assert(!(STATE & LayoutSet), "property layout should not be set yet");
            m_result->setLayout(std::move(value));
            return castState<LayoutSet>();
        }

        DocumentSnapshotBuilder<STATE | TextBoxesSet>& setTextBoxes(std::unique_ptr<protocol::DOMSnapshot::TextBoxSnapshot> value)
        {
            static_assert(!(STATE & TextBoxesSet), "property textBoxes should not be set yet");
            m_result->setTextBoxes(std::move(value));
            return castState<TextBoxesSet>();
        }

        DocumentSnapshotBuilder<STATE>& setScrollOffsetX(double value)
        {
            m_result->setScrollOffsetX(value);
            return *this;
        }

        DocumentSnapshotBuilder<STATE>& setScrollOffsetY(double value)
        {
            m_result->setScrollOffsetY(value);
            return *this;
        }

        std::unique_ptr<DocumentSnapshot> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class DocumentSnapshot;
        DocumentSnapshotBuilder() : m_result(new DocumentSnapshot()) { }

        template<int STEP> DocumentSnapshotBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<DocumentSnapshotBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::DocumentSnapshot> m_result;
    };

    static DocumentSnapshotBuilder<0> create()
    {
        return DocumentSnapshotBuilder<0>();
    }

private:
    DocumentSnapshot()
    {
          m_documentURL = 0;
          m_baseURL = 0;
          m_contentLanguage = 0;
          m_encodingName = 0;
          m_publicId = 0;
          m_systemId = 0;
          m_frameId = 0;
    }

    int m_documentURL;
    int m_baseURL;
    int m_contentLanguage;
    int m_encodingName;
    int m_publicId;
    int m_systemId;
    int m_frameId;
    std::unique_ptr<protocol::DOMSnapshot::NodeTreeSnapshot> m_nodes;
    std::unique_ptr<protocol::DOMSnapshot::LayoutTreeSnapshot> m_layout;
    std::unique_ptr<protocol::DOMSnapshot::TextBoxSnapshot> m_textBoxes;
    Maybe<double> m_scrollOffsetX;
    Maybe<double> m_scrollOffsetY;
};


class CORE_EXPORT NodeTreeSnapshot : public Serializable{
    PROTOCOL_DISALLOW_COPY(NodeTreeSnapshot);
public:
    static std::unique_ptr<NodeTreeSnapshot> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~NodeTreeSnapshot() override { }

    bool hasParentIndex() { return m_parentIndex.isJust(); }
    protocol::Array<int>* getParentIndex(protocol::Array<int>* defaultValue) { return m_parentIndex.isJust() ? m_parentIndex.fromJust() : defaultValue; }
    void setParentIndex(std::unique_ptr<protocol::Array<int>> value) { m_parentIndex = std::move(value); }

    bool hasNodeType() { return m_nodeType.isJust(); }
    protocol::Array<int>* getNodeType(protocol::Array<int>* defaultValue) { return m_nodeType.isJust() ? m_nodeType.fromJust() : defaultValue; }
    void setNodeType(std::unique_ptr<protocol::Array<int>> value) { m_nodeType = std::move(value); }

    bool hasNodeName() { return m_nodeName.isJust(); }
    protocol::Array<int>* getNodeName(protocol::Array<int>* defaultValue) { return m_nodeName.isJust() ? m_nodeName.fromJust() : defaultValue; }
    void setNodeName(std::unique_ptr<protocol::Array<int>> value) { m_nodeName = std::move(value); }

    bool hasNodeValue() { return m_nodeValue.isJust(); }
    protocol::Array<int>* getNodeValue(protocol::Array<int>* defaultValue) { return m_nodeValue.isJust() ? m_nodeValue.fromJust() : defaultValue; }
    void setNodeValue(std::unique_ptr<protocol::Array<int>> value) { m_nodeValue = std::move(value); }

    bool hasBackendNodeId() { return m_backendNodeId.isJust(); }
    protocol::Array<int>* getBackendNodeId(protocol::Array<int>* defaultValue) { return m_backendNodeId.isJust() ? m_backendNodeId.fromJust() : defaultValue; }
    void setBackendNodeId(std::unique_ptr<protocol::Array<int>> value) { m_backendNodeId = std::move(value); }

    bool hasAttributes() { return m_attributes.isJust(); }
    protocol::Array<protocol::Array<int>>* getAttributes(protocol::Array<protocol::Array<int>>* defaultValue) { return m_attributes.isJust() ? m_attributes.fromJust() : defaultValue; }
    void setAttributes(std::unique_ptr<protocol::Array<protocol::Array<int>>> value) { m_attributes = std::move(value); }

    bool hasTextValue() { return m_textValue.isJust(); }
    protocol::DOMSnapshot::RareStringData* getTextValue(protocol::DOMSnapshot::RareStringData* defaultValue) { return m_textValue.isJust() ? m_textValue.fromJust() : defaultValue; }
    void setTextValue(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value) { m_textValue = std::move(value); }

    bool hasInputValue() { return m_inputValue.isJust(); }
    protocol::DOMSnapshot::RareStringData* getInputValue(protocol::DOMSnapshot::RareStringData* defaultValue) { return m_inputValue.isJust() ? m_inputValue.fromJust() : defaultValue; }
    void setInputValue(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value) { m_inputValue = std::move(value); }

    bool hasInputChecked() { return m_inputChecked.isJust(); }
    protocol::DOMSnapshot::RareBooleanData* getInputChecked(protocol::DOMSnapshot::RareBooleanData* defaultValue) { return m_inputChecked.isJust() ? m_inputChecked.fromJust() : defaultValue; }
    void setInputChecked(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value) { m_inputChecked = std::move(value); }

    bool hasOptionSelected() { return m_optionSelected.isJust(); }
    protocol::DOMSnapshot::RareBooleanData* getOptionSelected(protocol::DOMSnapshot::RareBooleanData* defaultValue) { return m_optionSelected.isJust() ? m_optionSelected.fromJust() : defaultValue; }
    void setOptionSelected(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value) { m_optionSelected = std::move(value); }

    bool hasContentDocumentIndex() { return m_contentDocumentIndex.isJust(); }
    protocol::DOMSnapshot::RareIntegerData* getContentDocumentIndex(protocol::DOMSnapshot::RareIntegerData* defaultValue) { return m_contentDocumentIndex.isJust() ? m_contentDocumentIndex.fromJust() : defaultValue; }
    void setContentDocumentIndex(std::unique_ptr<protocol::DOMSnapshot::RareIntegerData> value) { m_contentDocumentIndex = std::move(value); }

    bool hasPseudoType() { return m_pseudoType.isJust(); }
    protocol::DOMSnapshot::RareStringData* getPseudoType(protocol::DOMSnapshot::RareStringData* defaultValue) { return m_pseudoType.isJust() ? m_pseudoType.fromJust() : defaultValue; }
    void setPseudoType(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value) { m_pseudoType = std::move(value); }

    bool hasIsClickable() { return m_isClickable.isJust(); }
    protocol::DOMSnapshot::RareBooleanData* getIsClickable(protocol::DOMSnapshot::RareBooleanData* defaultValue) { return m_isClickable.isJust() ? m_isClickable.fromJust() : defaultValue; }
    void setIsClickable(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value) { m_isClickable = std::move(value); }

    bool hasCurrentSourceURL() { return m_currentSourceURL.isJust(); }
    protocol::DOMSnapshot::RareStringData* getCurrentSourceURL(protocol::DOMSnapshot::RareStringData* defaultValue) { return m_currentSourceURL.isJust() ? m_currentSourceURL.fromJust() : defaultValue; }
    void setCurrentSourceURL(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value) { m_currentSourceURL = std::move(value); }

    bool hasOriginURL() { return m_originURL.isJust(); }
    protocol::DOMSnapshot::RareStringData* getOriginURL(protocol::DOMSnapshot::RareStringData* defaultValue) { return m_originURL.isJust() ? m_originURL.fromJust() : defaultValue; }
    void setOriginURL(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value) { m_originURL = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<NodeTreeSnapshot> clone() const;

    template<int STATE>
    class NodeTreeSnapshotBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        NodeTreeSnapshotBuilder<STATE>& setParentIndex(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setParentIndex(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setNodeType(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setNodeType(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setNodeName(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setNodeName(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setNodeValue(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setNodeValue(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setBackendNodeId(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setBackendNodeId(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setAttributes(std::unique_ptr<protocol::Array<protocol::Array<int>>> value)
        {
            m_result->setAttributes(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setTextValue(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
        {
            m_result->setTextValue(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setInputValue(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
        {
            m_result->setInputValue(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setInputChecked(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value)
        {
            m_result->setInputChecked(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setOptionSelected(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value)
        {
            m_result->setOptionSelected(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setContentDocumentIndex(std::unique_ptr<protocol::DOMSnapshot::RareIntegerData> value)
        {
            m_result->setContentDocumentIndex(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setPseudoType(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
        {
            m_result->setPseudoType(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setIsClickable(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value)
        {
            m_result->setIsClickable(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setCurrentSourceURL(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
        {
            m_result->setCurrentSourceURL(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setOriginURL(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
        {
            m_result->setOriginURL(std::move(value));
            return *this;
        }

        std::unique_ptr<NodeTreeSnapshot> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class NodeTreeSnapshot;
        NodeTreeSnapshotBuilder() : m_result(new NodeTreeSnapshot()) { }

        template<int STEP> NodeTreeSnapshotBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<NodeTreeSnapshotBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::NodeTreeSnapshot> m_result;
    };

    static NodeTreeSnapshotBuilder<0> create()
    {
        return NodeTreeSnapshotBuilder<0>();
    }

private:
    NodeTreeSnapshot()
    {
    }

    Maybe<protocol::Array<int>> m_parentIndex;
    Maybe<protocol::Array<int>> m_nodeType;
    Maybe<protocol::Array<int>> m_nodeName;
    Maybe<protocol::Array<int>> m_nodeValue;
    Maybe<protocol::Array<int>> m_backendNodeId;
    Maybe<protocol::Array<protocol::Array<int>>> m_attributes;
    Maybe<protocol::DOMSnapshot::RareStringData> m_textValue;
    Maybe<protocol::DOMSnapshot::RareStringData> m_inputValue;
    Maybe<protocol::DOMSnapshot::RareBooleanData> m_inputChecked;
    Maybe<protocol::DOMSnapshot::RareBooleanData> m_optionSelected;
    Maybe<protocol::DOMSnapshot::RareIntegerData> m_contentDocumentIndex;
    Maybe<protocol::DOMSnapshot::RareStringData> m_pseudoType;
    Maybe<protocol::DOMSnapshot::RareBooleanData> m_isClickable;
    Maybe<protocol::DOMSnapshot::RareStringData> m_currentSourceURL;
    Maybe<protocol::DOMSnapshot::RareStringData> m_originURL;
};


class CORE_EXPORT LayoutTreeSnapshot : public Serializable{
    PROTOCOL_DISALLOW_COPY(LayoutTreeSnapshot);
public:
    static std::unique_ptr<LayoutTreeSnapshot> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~LayoutTreeSnapshot() override { }

    protocol::Array<int>* getNodeIndex() { return m_nodeIndex.get(); }
    void setNodeIndex(std::unique_ptr<protocol::Array<int>> value) { m_nodeIndex = std::move(value); }

    protocol::Array<protocol::Array<int>>* getStyles() { return m_styles.get(); }
    void setStyles(std::unique_ptr<protocol::Array<protocol::Array<int>>> value) { m_styles = std::move(value); }

    protocol::Array<protocol::Array<double>>* getBounds() { return m_bounds.get(); }
    void setBounds(std::unique_ptr<protocol::Array<protocol::Array<double>>> value) { m_bounds = std::move(value); }

    protocol::Array<int>* getText() { return m_text.get(); }
    void setText(std::unique_ptr<protocol::Array<int>> value) { m_text = std::move(value); }

    protocol::DOMSnapshot::RareBooleanData* getStackingContexts() { return m_stackingContexts.get(); }
    void setStackingContexts(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value) { m_stackingContexts = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<LayoutTreeSnapshot> clone() const;

    template<int STATE>
    class LayoutTreeSnapshotBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NodeIndexSet = 1 << 1,
            StylesSet = 1 << 2,
            BoundsSet = 1 << 3,
            TextSet = 1 << 4,
            StackingContextsSet = 1 << 5,
            AllFieldsSet = (NodeIndexSet | StylesSet | BoundsSet | TextSet | StackingContextsSet | 0)};


        LayoutTreeSnapshotBuilder<STATE | NodeIndexSet>& setNodeIndex(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & NodeIndexSet), "property nodeIndex should not be set yet");
            m_result->setNodeIndex(std::move(value));
            return castState<NodeIndexSet>();
        }

        LayoutTreeSnapshotBuilder<STATE | StylesSet>& setStyles(std::unique_ptr<protocol::Array<protocol::Array<int>>> value)
        {
            static_assert(!(STATE & StylesSet), "property styles should not be set yet");
            m_result->setStyles(std::move(value));
            return castState<StylesSet>();
        }

        LayoutTreeSnapshotBuilder<STATE | BoundsSet>& setBounds(std::unique_ptr<protocol::Array<protocol::Array<double>>> value)
        {
            static_assert(!(STATE & BoundsSet), "property bounds should not be set yet");
            m_result->setBounds(std::move(value));
            return castState<BoundsSet>();
        }

        LayoutTreeSnapshotBuilder<STATE | TextSet>& setText(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & TextSet), "property text should not be set yet");
            m_result->setText(std::move(value));
            return castState<TextSet>();
        }

        LayoutTreeSnapshotBuilder<STATE | StackingContextsSet>& setStackingContexts(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value)
        {
            static_assert(!(STATE & StackingContextsSet), "property stackingContexts should not be set yet");
            m_result->setStackingContexts(std::move(value));
            return castState<StackingContextsSet>();
        }

        std::unique_ptr<LayoutTreeSnapshot> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class LayoutTreeSnapshot;
        LayoutTreeSnapshotBuilder() : m_result(new LayoutTreeSnapshot()) { }

        template<int STEP> LayoutTreeSnapshotBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<LayoutTreeSnapshotBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::LayoutTreeSnapshot> m_result;
    };

    static LayoutTreeSnapshotBuilder<0> create()
    {
        return LayoutTreeSnapshotBuilder<0>();
    }

private:
    LayoutTreeSnapshot()
    {
    }

    std::unique_ptr<protocol::Array<int>> m_nodeIndex;
    std::unique_ptr<protocol::Array<protocol::Array<int>>> m_styles;
    std::unique_ptr<protocol::Array<protocol::Array<double>>> m_bounds;
    std::unique_ptr<protocol::Array<int>> m_text;
    std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> m_stackingContexts;
};


class CORE_EXPORT TextBoxSnapshot : public Serializable{
    PROTOCOL_DISALLOW_COPY(TextBoxSnapshot);
public:
    static std::unique_ptr<TextBoxSnapshot> fromValue(protocol::Value* value, ErrorSupport* errors);

    ~TextBoxSnapshot() override { }

    protocol::Array<int>* getLayoutIndex() { return m_layoutIndex.get(); }
    void setLayoutIndex(std::unique_ptr<protocol::Array<int>> value) { m_layoutIndex = std::move(value); }

    protocol::Array<protocol::Array<double>>* getBounds() { return m_bounds.get(); }
    void setBounds(std::unique_ptr<protocol::Array<protocol::Array<double>>> value) { m_bounds = std::move(value); }

    protocol::Array<int>* getStart() { return m_start.get(); }
    void setStart(std::unique_ptr<protocol::Array<int>> value) { m_start = std::move(value); }

    protocol::Array<int>* getLength() { return m_length.get(); }
    void setLength(std::unique_ptr<protocol::Array<int>> value) { m_length = std::move(value); }

    std::unique_ptr<protocol::DictionaryValue> toValue() const;
    String serializeToJSON() override { return toValue()->serializeToJSON(); }
    std::vector<uint8_t> serializeToBinary() override { return toValue()->serializeToBinary(); }
    String toJSON() const { return toValue()->toJSONString(); }
    std::unique_ptr<TextBoxSnapshot> clone() const;

    template<int STATE>
    class TextBoxSnapshotBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            LayoutIndexSet = 1 << 1,
            BoundsSet = 1 << 2,
            StartSet = 1 << 3,
            LengthSet = 1 << 4,
            AllFieldsSet = (LayoutIndexSet | BoundsSet | StartSet | LengthSet | 0)};


        TextBoxSnapshotBuilder<STATE | LayoutIndexSet>& setLayoutIndex(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & LayoutIndexSet), "property layoutIndex should not be set yet");
            m_result->setLayoutIndex(std::move(value));
            return castState<LayoutIndexSet>();
        }

        TextBoxSnapshotBuilder<STATE | BoundsSet>& setBounds(std::unique_ptr<protocol::Array<protocol::Array<double>>> value)
        {
            static_assert(!(STATE & BoundsSet), "property bounds should not be set yet");
            m_result->setBounds(std::move(value));
            return castState<BoundsSet>();
        }

        TextBoxSnapshotBuilder<STATE | StartSet>& setStart(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & StartSet), "property start should not be set yet");
            m_result->setStart(std::move(value));
            return castState<StartSet>();
        }

        TextBoxSnapshotBuilder<STATE | LengthSet>& setLength(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & LengthSet), "property length should not be set yet");
            m_result->setLength(std::move(value));
            return castState<LengthSet>();
        }

        std::unique_ptr<TextBoxSnapshot> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class TextBoxSnapshot;
        TextBoxSnapshotBuilder() : m_result(new TextBoxSnapshot()) { }

        template<int STEP> TextBoxSnapshotBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<TextBoxSnapshotBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::TextBoxSnapshot> m_result;
    };

    static TextBoxSnapshotBuilder<0> create()
    {
        return TextBoxSnapshotBuilder<0>();
    }

private:
    TextBoxSnapshot()
    {
    }

    std::unique_ptr<protocol::Array<int>> m_layoutIndex;
    std::unique_ptr<protocol::Array<protocol::Array<double>>> m_bounds;
    std::unique_ptr<protocol::Array<int>> m_start;
    std::unique_ptr<protocol::Array<int>> m_length;
};


// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse getSnapshot(std::unique_ptr<protocol::Array<String>> in_computedStyleWhitelist, Maybe<bool> in_includeEventListeners, Maybe<bool> in_includePaintOrder, Maybe<bool> in_includeUserAgentShadowTree, std::unique_ptr<protocol::Array<protocol::DOMSnapshot::DOMNode>>* out_domNodes, std::unique_ptr<protocol::Array<protocol::DOMSnapshot::LayoutTreeNode>>* out_layoutTreeNodes, std::unique_ptr<protocol::Array<protocol::DOMSnapshot::ComputedStyle>>* out_computedStyles) = 0;
    virtual DispatchResponse captureSnapshot(std::unique_ptr<protocol::Array<String>> in_computedStyles, std::unique_ptr<protocol::Array<protocol::DOMSnapshot::DocumentSnapshot>>* out_documents, std::unique_ptr<protocol::Array<String>>* out_strings) = 0;

};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
    explicit Frontend(FrontendChannel* frontendChannel) : m_frontendChannel(frontendChannel) { }

    void flush();
    void sendRawJSONNotification(String);
    void sendRawCBORNotification(std::vector<uint8_t>);
private:
    FrontendChannel* m_frontendChannel;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace DOMSnapshot
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_DOMSnapshot_h)
