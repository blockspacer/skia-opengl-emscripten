// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PERFETTO_TRACE_FTRACE_KMEM_PROTO_H_
#define PERFETTO_PROTOS_PERFETTO_TRACE_FTRACE_KMEM_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/base/export.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/message.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class PERFETTO_EXPORT IonHeapGrowFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_heap_name() const { return at<1>().valid(); }
    ::protozero::ConstChars heap_name() const { return at<1>().as_string(); }
    bool has_len() const { return at<2>().valid(); }
    uint64_t len() const { return at<2>().as_uint64(); }
    bool has_total_allocated() const { return at<3>().valid(); }
    int64_t total_allocated() const { return at<3>().as_int64(); }
  };
  void set_heap_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_total_allocated(int64_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT IonHeapShrinkFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_heap_name() const { return at<1>().valid(); }
    ::protozero::ConstChars heap_name() const { return at<1>().as_string(); }
    bool has_len() const { return at<2>().valid(); }
    uint64_t len() const { return at<2>().as_uint64(); }
    bool has_total_allocated() const { return at<3>().valid(); }
    int64_t total_allocated() const { return at<3>().as_int64(); }
  };
  void set_heap_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_total_allocated(int64_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT RssStatFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kMemberFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_member() const { return at<1>().valid(); }
    int32_t member() const { return at<1>().as_int32(); }
    bool has_size() const { return at<2>().valid(); }
    int64_t size() const { return at<2>().as_int64(); }
  };
  void set_member(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(2, value);
  }
};

class PERFETTO_EXPORT MmPagePcpuDrainFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_migratetype() const { return at<1>().valid(); }
    int32_t migratetype() const { return at<1>().as_int32(); }
    bool has_order() const { return at<2>().valid(); }
    uint32_t order() const { return at<2>().as_uint32(); }
    bool has_page() const { return at<3>().valid(); }
    uint64_t page() const { return at<3>().as_uint64(); }
    bool has_pfn() const { return at<4>().valid(); }
    uint64_t pfn() const { return at<4>().as_uint64(); }
  };
  void set_migratetype(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class PERFETTO_EXPORT MmPageFreeBatchedFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kColdFieldNumber = 1,
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_cold() const { return at<1>().valid(); }
    int32_t cold() const { return at<1>().as_int32(); }
    bool has_page() const { return at<2>().valid(); }
    uint64_t page() const { return at<2>().as_uint64(); }
    bool has_pfn() const { return at<3>().valid(); }
    uint64_t pfn() const { return at<3>().as_uint64(); }
  };
  void set_cold(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT MmPageFreeFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kOrderFieldNumber = 1,
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_order() const { return at<1>().valid(); }
    uint32_t order() const { return at<1>().as_uint32(); }
    bool has_page() const { return at<2>().valid(); }
    uint64_t page() const { return at<2>().as_uint64(); }
    bool has_pfn() const { return at<3>().valid(); }
    uint64_t pfn() const { return at<3>().as_uint64(); }
  };
  void set_order(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT MmPageAllocZoneLockedFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_migratetype() const { return at<1>().valid(); }
    int32_t migratetype() const { return at<1>().as_int32(); }
    bool has_order() const { return at<2>().valid(); }
    uint32_t order() const { return at<2>().as_uint32(); }
    bool has_page() const { return at<3>().valid(); }
    uint64_t page() const { return at<3>().as_uint64(); }
    bool has_pfn() const { return at<4>().valid(); }
    uint64_t pfn() const { return at<4>().as_uint64(); }
  };
  void set_migratetype(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class PERFETTO_EXPORT MmPageAllocExtfragFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kAllocMigratetypeFieldNumber = 1,
    kAllocOrderFieldNumber = 2,
    kFallbackMigratetypeFieldNumber = 3,
    kFallbackOrderFieldNumber = 4,
    kPageFieldNumber = 5,
    kChangeOwnershipFieldNumber = 6,
    kPfnFieldNumber = 7,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_alloc_migratetype() const { return at<1>().valid(); }
    int32_t alloc_migratetype() const { return at<1>().as_int32(); }
    bool has_alloc_order() const { return at<2>().valid(); }
    int32_t alloc_order() const { return at<2>().as_int32(); }
    bool has_fallback_migratetype() const { return at<3>().valid(); }
    int32_t fallback_migratetype() const { return at<3>().as_int32(); }
    bool has_fallback_order() const { return at<4>().valid(); }
    int32_t fallback_order() const { return at<4>().as_int32(); }
    bool has_page() const { return at<5>().valid(); }
    uint64_t page() const { return at<5>().as_uint64(); }
    bool has_change_ownership() const { return at<6>().valid(); }
    int32_t change_ownership() const { return at<6>().as_int32(); }
    bool has_pfn() const { return at<7>().valid(); }
    uint64_t pfn() const { return at<7>().as_uint64(); }
  };
  void set_alloc_migratetype(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_alloc_order(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_fallback_migratetype(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_fallback_order(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_change_ownership(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(7, value);
  }
};

class PERFETTO_EXPORT MmPageAllocFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kMigratetypeFieldNumber = 2,
    kOrderFieldNumber = 3,
    kPageFieldNumber = 4,
    kPfnFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_gfp_flags() const { return at<1>().valid(); }
    uint32_t gfp_flags() const { return at<1>().as_uint32(); }
    bool has_migratetype() const { return at<2>().valid(); }
    int32_t migratetype() const { return at<2>().as_int32(); }
    bool has_order() const { return at<3>().valid(); }
    uint32_t order() const { return at<3>().as_uint32(); }
    bool has_page() const { return at<4>().valid(); }
    uint64_t page() const { return at<4>().as_uint64(); }
    bool has_pfn() const { return at<5>().valid(); }
    uint64_t pfn() const { return at<5>().as_uint64(); }
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_migratetype(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT MigrateRetryFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kTriesFieldNumber = 1,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_tries() const { return at<1>().valid(); }
    int32_t tries() const { return at<1>().as_int32(); }
  };
  void set_tries(int32_t value) {
    AppendVarInt(1, value);
  }
};

class PERFETTO_EXPORT MigratePagesStartFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kModeFieldNumber = 1,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_mode() const { return at<1>().valid(); }
    int32_t mode() const { return at<1>().as_int32(); }
  };
  void set_mode(int32_t value) {
    AppendVarInt(1, value);
  }
};

class PERFETTO_EXPORT MigratePagesEndFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kModeFieldNumber = 1,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_mode() const { return at<1>().valid(); }
    int32_t mode() const { return at<1>().as_int32(); }
  };
  void set_mode(int32_t value) {
    AppendVarInt(1, value);
  }
};

class PERFETTO_EXPORT KmemCacheFreeFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_call_site() const { return at<1>().valid(); }
    uint64_t call_site() const { return at<1>().as_uint64(); }
    bool has_ptr() const { return at<2>().valid(); }
    uint64_t ptr() const { return at<2>().as_uint64(); }
  };
  void set_call_site(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class PERFETTO_EXPORT KmemCacheAllocNodeFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_bytes_alloc() const { return at<1>().valid(); }
    uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
    bool has_bytes_req() const { return at<2>().valid(); }
    uint64_t bytes_req() const { return at<2>().as_uint64(); }
    bool has_call_site() const { return at<3>().valid(); }
    uint64_t call_site() const { return at<3>().as_uint64(); }
    bool has_gfp_flags() const { return at<4>().valid(); }
    uint32_t gfp_flags() const { return at<4>().as_uint32(); }
    bool has_node() const { return at<5>().valid(); }
    int32_t node() const { return at<5>().as_int32(); }
    bool has_ptr() const { return at<6>().valid(); }
    uint64_t ptr() const { return at<6>().as_uint64(); }
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_node(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class PERFETTO_EXPORT KmemCacheAllocFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kPtrFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_bytes_alloc() const { return at<1>().valid(); }
    uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
    bool has_bytes_req() const { return at<2>().valid(); }
    uint64_t bytes_req() const { return at<2>().as_uint64(); }
    bool has_call_site() const { return at<3>().valid(); }
    uint64_t call_site() const { return at<3>().as_uint64(); }
    bool has_gfp_flags() const { return at<4>().valid(); }
    uint32_t gfp_flags() const { return at<4>().as_uint32(); }
    bool has_ptr() const { return at<5>().valid(); }
    uint64_t ptr() const { return at<5>().as_uint64(); }
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT KmallocNodeFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_bytes_alloc() const { return at<1>().valid(); }
    uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
    bool has_bytes_req() const { return at<2>().valid(); }
    uint64_t bytes_req() const { return at<2>().as_uint64(); }
    bool has_call_site() const { return at<3>().valid(); }
    uint64_t call_site() const { return at<3>().as_uint64(); }
    bool has_gfp_flags() const { return at<4>().valid(); }
    uint32_t gfp_flags() const { return at<4>().as_uint32(); }
    bool has_node() const { return at<5>().valid(); }
    int32_t node() const { return at<5>().as_int32(); }
    bool has_ptr() const { return at<6>().valid(); }
    uint64_t ptr() const { return at<6>().as_uint64(); }
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_node(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class PERFETTO_EXPORT KmallocFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kPtrFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_bytes_alloc() const { return at<1>().valid(); }
    uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
    bool has_bytes_req() const { return at<2>().valid(); }
    uint64_t bytes_req() const { return at<2>().as_uint64(); }
    bool has_call_site() const { return at<3>().valid(); }
    uint64_t call_site() const { return at<3>().as_uint64(); }
    bool has_gfp_flags() const { return at<4>().valid(); }
    uint32_t gfp_flags() const { return at<4>().as_uint32(); }
    bool has_ptr() const { return at<5>().valid(); }
    uint64_t ptr() const { return at<5>().as_uint64(); }
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT KfreeFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_call_site() const { return at<1>().valid(); }
    uint64_t call_site() const { return at<1>().as_uint64(); }
    bool has_ptr() const { return at<2>().valid(); }
    uint64_t ptr() const { return at<2>().as_uint64(); }
  };
  void set_call_site(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class PERFETTO_EXPORT IonSecureCmaShrinkPoolStartFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_drained_size() const { return at<1>().valid(); }
    uint64_t drained_size() const { return at<1>().as_uint64(); }
    bool has_skipped_size() const { return at<2>().valid(); }
    uint64_t skipped_size() const { return at<2>().as_uint64(); }
  };
  void set_drained_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_skipped_size(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class PERFETTO_EXPORT IonSecureCmaShrinkPoolEndFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_drained_size() const { return at<1>().valid(); }
    uint64_t drained_size() const { return at<1>().as_uint64(); }
    bool has_skipped_size() const { return at<2>().valid(); }
    uint64_t skipped_size() const { return at<2>().as_uint64(); }
  };
  void set_drained_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_skipped_size(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class PERFETTO_EXPORT IonSecureCmaAllocateStartFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_align() const { return at<1>().valid(); }
    uint64_t align() const { return at<1>().as_uint64(); }
    bool has_flags() const { return at<2>().valid(); }
    uint64_t flags() const { return at<2>().as_uint64(); }
    bool has_heap_name() const { return at<3>().valid(); }
    ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
    bool has_len() const { return at<4>().valid(); }
    uint64_t len() const { return at<4>().as_uint64(); }
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class PERFETTO_EXPORT IonSecureCmaAllocateEndFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_align() const { return at<1>().valid(); }
    uint64_t align() const { return at<1>().as_uint64(); }
    bool has_flags() const { return at<2>().valid(); }
    uint64_t flags() const { return at<2>().as_uint64(); }
    bool has_heap_name() const { return at<3>().valid(); }
    ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
    bool has_len() const { return at<4>().valid(); }
    uint64_t len() const { return at<4>().as_uint64(); }
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class PERFETTO_EXPORT IonSecureCmaAddToPoolStartFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kIsPrefetchFieldNumber = 1,
    kLenFieldNumber = 2,
    kPoolTotalFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_is_prefetch() const { return at<1>().valid(); }
    uint32_t is_prefetch() const { return at<1>().as_uint32(); }
    bool has_len() const { return at<2>().valid(); }
    uint64_t len() const { return at<2>().as_uint64(); }
    bool has_pool_total() const { return at<3>().valid(); }
    int32_t pool_total() const { return at<3>().as_int32(); }
  };
  void set_is_prefetch(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pool_total(int32_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT IonSecureCmaAddToPoolEndFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kIsPrefetchFieldNumber = 1,
    kLenFieldNumber = 2,
    kPoolTotalFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_is_prefetch() const { return at<1>().valid(); }
    uint32_t is_prefetch() const { return at<1>().as_uint32(); }
    bool has_len() const { return at<2>().valid(); }
    uint64_t len() const { return at<2>().as_uint64(); }
    bool has_pool_total() const { return at<3>().valid(); }
    int32_t pool_total() const { return at<3>().as_int32(); }
  };
  void set_is_prefetch(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pool_total(int32_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT IonPrefetchingFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kLenFieldNumber = 1,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_len() const { return at<1>().valid(); }
    uint64_t len() const { return at<1>().as_uint64(); }
  };
  void set_len(uint64_t value) {
    AppendVarInt(1, value);
  }
};

class PERFETTO_EXPORT IonCpSecureBufferStartFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_align() const { return at<1>().valid(); }
    uint64_t align() const { return at<1>().as_uint64(); }
    bool has_flags() const { return at<2>().valid(); }
    uint64_t flags() const { return at<2>().as_uint64(); }
    bool has_heap_name() const { return at<3>().valid(); }
    ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
    bool has_len() const { return at<4>().valid(); }
    uint64_t len() const { return at<4>().as_uint64(); }
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class PERFETTO_EXPORT IonCpSecureBufferEndFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_align() const { return at<1>().valid(); }
    uint64_t align() const { return at<1>().as_uint64(); }
    bool has_flags() const { return at<2>().valid(); }
    uint64_t flags() const { return at<2>().as_uint64(); }
    bool has_heap_name() const { return at<3>().valid(); }
    ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
    bool has_len() const { return at<4>().valid(); }
    uint64_t len() const { return at<4>().as_uint64(); }
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class PERFETTO_EXPORT IonCpAllocRetryFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kTriesFieldNumber = 1,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_tries() const { return at<1>().valid(); }
    int32_t tries() const { return at<1>().as_int32(); }
  };
  void set_tries(int32_t value) {
    AppendVarInt(1, value);
  }
};

class PERFETTO_EXPORT IonAllocBufferStartFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
    kMaskFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_client_name() const { return at<1>().valid(); }
    ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
    bool has_flags() const { return at<2>().valid(); }
    uint32_t flags() const { return at<2>().as_uint32(); }
    bool has_heap_name() const { return at<3>().valid(); }
    ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
    bool has_len() const { return at<4>().valid(); }
    uint64_t len() const { return at<4>().as_uint64(); }
    bool has_mask() const { return at<5>().valid(); }
    uint32_t mask() const { return at<5>().as_uint32(); }
  };
  void set_client_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_client_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT IonAllocBufferFallbackFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kHeapNameFieldNumber = 4,
    kLenFieldNumber = 5,
    kMaskFieldNumber = 6,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_client_name() const { return at<1>().valid(); }
    ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
    bool has_error() const { return at<2>().valid(); }
    int64_t error() const { return at<2>().as_int64(); }
    bool has_flags() const { return at<3>().valid(); }
    uint32_t flags() const { return at<3>().as_uint32(); }
    bool has_heap_name() const { return at<4>().valid(); }
    ::protozero::ConstChars heap_name() const { return at<4>().as_string(); }
    bool has_len() const { return at<5>().valid(); }
    uint64_t len() const { return at<5>().as_uint64(); }
    bool has_mask() const { return at<6>().valid(); }
    uint32_t mask() const { return at<6>().as_uint32(); }
  };
  void set_client_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_client_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_error(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_heap_name(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class PERFETTO_EXPORT IonAllocBufferFailFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kHeapNameFieldNumber = 4,
    kLenFieldNumber = 5,
    kMaskFieldNumber = 6,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_client_name() const { return at<1>().valid(); }
    ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
    bool has_error() const { return at<2>().valid(); }
    int64_t error() const { return at<2>().as_int64(); }
    bool has_flags() const { return at<3>().valid(); }
    uint32_t flags() const { return at<3>().as_uint32(); }
    bool has_heap_name() const { return at<4>().valid(); }
    ::protozero::ConstChars heap_name() const { return at<4>().as_string(); }
    bool has_len() const { return at<5>().valid(); }
    uint64_t len() const { return at<5>().as_uint64(); }
    bool has_mask() const { return at<6>().valid(); }
    uint32_t mask() const { return at<6>().as_uint32(); }
  };
  void set_client_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_client_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_error(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_heap_name(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class PERFETTO_EXPORT IonAllocBufferEndFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
    kMaskFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_client_name() const { return at<1>().valid(); }
    ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
    bool has_flags() const { return at<2>().valid(); }
    uint32_t flags() const { return at<2>().as_uint32(); }
    bool has_heap_name() const { return at<3>().valid(); }
    ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
    bool has_len() const { return at<4>().valid(); }
    uint64_t len() const { return at<4>().as_uint64(); }
    bool has_mask() const { return at<5>().valid(); }
    uint32_t mask() const { return at<5>().as_uint32(); }
  };
  void set_client_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_client_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT IommuSecPtblMapRangeStartFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kSecIdFieldNumber = 4,
    kVaFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_len() const { return at<1>().valid(); }
    uint64_t len() const { return at<1>().as_uint64(); }
    bool has_num() const { return at<2>().valid(); }
    int32_t num() const { return at<2>().as_int32(); }
    bool has_pa() const { return at<3>().valid(); }
    uint32_t pa() const { return at<3>().as_uint32(); }
    bool has_sec_id() const { return at<4>().valid(); }
    int32_t sec_id() const { return at<4>().as_int32(); }
    bool has_va() const { return at<5>().valid(); }
    uint64_t va() const { return at<5>().as_uint64(); }
  };
  void set_len(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_num(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pa(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_sec_id(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_va(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT IommuSecPtblMapRangeEndFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kSecIdFieldNumber = 4,
    kVaFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_len() const { return at<1>().valid(); }
    uint64_t len() const { return at<1>().as_uint64(); }
    bool has_num() const { return at<2>().valid(); }
    int32_t num() const { return at<2>().as_int32(); }
    bool has_pa() const { return at<3>().valid(); }
    uint32_t pa() const { return at<3>().as_uint32(); }
    bool has_sec_id() const { return at<4>().valid(); }
    int32_t sec_id() const { return at<4>().as_int32(); }
    bool has_va() const { return at<5>().valid(); }
    uint64_t va() const { return at<5>().as_uint64(); }
  };
  void set_len(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_num(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pa(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_sec_id(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_va(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT IommuMapRangeFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kChunkSizeFieldNumber = 1,
    kLenFieldNumber = 2,
    kPaFieldNumber = 3,
    kVaFieldNumber = 4,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_chunk_size() const { return at<1>().valid(); }
    uint64_t chunk_size() const { return at<1>().as_uint64(); }
    bool has_len() const { return at<2>().valid(); }
    uint64_t len() const { return at<2>().as_uint64(); }
    bool has_pa() const { return at<3>().valid(); }
    uint64_t pa() const { return at<3>().as_uint64(); }
    bool has_va() const { return at<4>().valid(); }
    uint64_t va() const { return at<4>().as_uint64(); }
  };
  void set_chunk_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pa(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_va(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class PERFETTO_EXPORT DmaAllocContiguousRetryFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kTriesFieldNumber = 1,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_tries() const { return at<1>().valid(); }
    int32_t tries() const { return at<1>().as_int32(); }
  };
  void set_tries(int32_t value) {
    AppendVarInt(1, value);
  }
};

class PERFETTO_EXPORT AllocPagesSysStartFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_gfp_flags() const { return at<1>().valid(); }
    uint32_t gfp_flags() const { return at<1>().as_uint32(); }
    bool has_order() const { return at<2>().valid(); }
    uint32_t order() const { return at<2>().as_uint32(); }
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class PERFETTO_EXPORT AllocPagesSysFailFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_gfp_flags() const { return at<1>().valid(); }
    uint32_t gfp_flags() const { return at<1>().as_uint32(); }
    bool has_order() const { return at<2>().valid(); }
    uint32_t order() const { return at<2>().as_uint32(); }
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class PERFETTO_EXPORT AllocPagesSysEndFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_gfp_flags() const { return at<1>().valid(); }
    uint32_t gfp_flags() const { return at<1>().as_uint32(); }
    bool has_order() const { return at<2>().valid(); }
    uint32_t order() const { return at<2>().as_uint32(); }
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class PERFETTO_EXPORT AllocPagesIommuStartFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_gfp_flags() const { return at<1>().valid(); }
    uint32_t gfp_flags() const { return at<1>().as_uint32(); }
    bool has_order() const { return at<2>().valid(); }
    uint32_t order() const { return at<2>().as_uint32(); }
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class PERFETTO_EXPORT AllocPagesIommuFailFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_gfp_flags() const { return at<1>().valid(); }
    uint32_t gfp_flags() const { return at<1>().as_uint32(); }
    bool has_order() const { return at<2>().valid(); }
    uint32_t order() const { return at<2>().as_uint32(); }
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class PERFETTO_EXPORT AllocPagesIommuEndFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_gfp_flags() const { return at<1>().valid(); }
    uint32_t gfp_flags() const { return at<1>().as_uint32(); }
    bool has_order() const { return at<2>().valid(); }
    uint32_t order() const { return at<2>().as_uint32(); }
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
