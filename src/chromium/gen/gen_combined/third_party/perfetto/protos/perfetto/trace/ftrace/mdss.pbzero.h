// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PERFETTO_TRACE_FTRACE_MDSS_PROTO_H_
#define PERFETTO_PROTOS_PERFETTO_TRACE_FTRACE_MDSS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/base/export.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/message.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class PERFETTO_EXPORT RotatorBwAoAsContextFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kStateFieldNumber = 1,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_state() const { return at<1>().valid(); }
    uint32_t state() const { return at<1>().as_uint32(); }
  };
  void set_state(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class PERFETTO_EXPORT MdpPerfUpdateBusFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kClientFieldNumber = 1,
    kAbQuotaFieldNumber = 2,
    kIbQuotaFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_client() const { return at<1>().valid(); }
    int32_t client() const { return at<1>().as_int32(); }
    bool has_ab_quota() const { return at<2>().valid(); }
    uint64_t ab_quota() const { return at<2>().as_uint64(); }
    bool has_ib_quota() const { return at<3>().valid(); }
    uint64_t ib_quota() const { return at<3>().as_uint64(); }
  };
  void set_client(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ab_quota(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ib_quota(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT MdpPerfPrefillCalcFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kPnumFieldNumber = 1,
    kLatencyBufFieldNumber = 2,
    kOtFieldNumber = 3,
    kYBufFieldNumber = 4,
    kYScalerFieldNumber = 5,
    kPpLinesFieldNumber = 6,
    kPpBytesFieldNumber = 7,
    kPostScFieldNumber = 8,
    kFbcBytesFieldNumber = 9,
    kPrefillBytesFieldNumber = 10,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_pnum() const { return at<1>().valid(); }
    uint32_t pnum() const { return at<1>().as_uint32(); }
    bool has_latency_buf() const { return at<2>().valid(); }
    uint32_t latency_buf() const { return at<2>().as_uint32(); }
    bool has_ot() const { return at<3>().valid(); }
    uint32_t ot() const { return at<3>().as_uint32(); }
    bool has_y_buf() const { return at<4>().valid(); }
    uint32_t y_buf() const { return at<4>().as_uint32(); }
    bool has_y_scaler() const { return at<5>().valid(); }
    uint32_t y_scaler() const { return at<5>().as_uint32(); }
    bool has_pp_lines() const { return at<6>().valid(); }
    uint32_t pp_lines() const { return at<6>().as_uint32(); }
    bool has_pp_bytes() const { return at<7>().valid(); }
    uint32_t pp_bytes() const { return at<7>().as_uint32(); }
    bool has_post_sc() const { return at<8>().valid(); }
    uint32_t post_sc() const { return at<8>().as_uint32(); }
    bool has_fbc_bytes() const { return at<9>().valid(); }
    uint32_t fbc_bytes() const { return at<9>().as_uint32(); }
    bool has_prefill_bytes() const { return at<10>().valid(); }
    uint32_t prefill_bytes() const { return at<10>().as_uint32(); }
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_latency_buf(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_ot(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_y_buf(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_y_scaler(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_pp_lines(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_pp_bytes(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_post_sc(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_fbc_bytes(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_prefill_bytes(uint32_t value) {
    AppendVarInt(10, value);
  }
};

class PERFETTO_EXPORT MdpCmdWaitPingpongFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kKickoffCntFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_ctl_num() const { return at<1>().valid(); }
    uint32_t ctl_num() const { return at<1>().as_uint32(); }
    bool has_kickoff_cnt() const { return at<2>().valid(); }
    int32_t kickoff_cnt() const { return at<2>().as_int32(); }
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_kickoff_cnt(int32_t value) {
    AppendVarInt(2, value);
  }
};

class PERFETTO_EXPORT MdpVideoUnderrunDoneFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kUnderrunCntFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_ctl_num() const { return at<1>().valid(); }
    uint32_t ctl_num() const { return at<1>().as_uint32(); }
    bool has_underrun_cnt() const { return at<2>().valid(); }
    uint32_t underrun_cnt() const { return at<2>().as_uint32(); }
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_underrun_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class PERFETTO_EXPORT MdpPerfSetWmLevelsFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kPnumFieldNumber = 1,
    kUseSpaceFieldNumber = 2,
    kPriorityBytesFieldNumber = 3,
    kWm0FieldNumber = 4,
    kWm1FieldNumber = 5,
    kWm2FieldNumber = 6,
    kMbCntFieldNumber = 7,
    kMbSizeFieldNumber = 8,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_pnum() const { return at<1>().valid(); }
    uint32_t pnum() const { return at<1>().as_uint32(); }
    bool has_use_space() const { return at<2>().valid(); }
    uint32_t use_space() const { return at<2>().as_uint32(); }
    bool has_priority_bytes() const { return at<3>().valid(); }
    uint32_t priority_bytes() const { return at<3>().as_uint32(); }
    bool has_wm0() const { return at<4>().valid(); }
    uint32_t wm0() const { return at<4>().as_uint32(); }
    bool has_wm1() const { return at<5>().valid(); }
    uint32_t wm1() const { return at<5>().as_uint32(); }
    bool has_wm2() const { return at<6>().valid(); }
    uint32_t wm2() const { return at<6>().as_uint32(); }
    bool has_mb_cnt() const { return at<7>().valid(); }
    uint32_t mb_cnt() const { return at<7>().as_uint32(); }
    bool has_mb_size() const { return at<8>().valid(); }
    uint32_t mb_size() const { return at<8>().as_uint32(); }
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_use_space(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_priority_bytes(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_wm0(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_wm1(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_wm2(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_mb_cnt(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_mb_size(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class PERFETTO_EXPORT MdpMixerUpdateFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kMixerNumFieldNumber = 1,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_mixer_num() const { return at<1>().valid(); }
    uint32_t mixer_num() const { return at<1>().as_uint32(); }
  };
  void set_mixer_num(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class PERFETTO_EXPORT MdpCmdReleaseBwFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kCtlNumFieldNumber = 1,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_ctl_num() const { return at<1>().valid(); }
    uint32_t ctl_num() const { return at<1>().as_uint32(); }
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class PERFETTO_EXPORT MdpTraceCounterFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kPidFieldNumber = 1,
    kCounterNameFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_pid() const { return at<1>().valid(); }
    int32_t pid() const { return at<1>().as_int32(); }
    bool has_counter_name() const { return at<2>().valid(); }
    ::protozero::ConstChars counter_name() const { return at<2>().as_string(); }
    bool has_value() const { return at<3>().valid(); }
    int32_t value() const { return at<3>().as_int32(); }
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_counter_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_counter_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_value(int32_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT MdpPerfSetQosLutsFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kPnumFieldNumber = 1,
    kFmtFieldNumber = 2,
    kIntfFieldNumber = 3,
    kRotFieldNumber = 4,
    kFlFieldNumber = 5,
    kLutFieldNumber = 6,
    kLinearFieldNumber = 7,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_pnum() const { return at<1>().valid(); }
    uint32_t pnum() const { return at<1>().as_uint32(); }
    bool has_fmt() const { return at<2>().valid(); }
    uint32_t fmt() const { return at<2>().as_uint32(); }
    bool has_intf() const { return at<3>().valid(); }
    uint32_t intf() const { return at<3>().as_uint32(); }
    bool has_rot() const { return at<4>().valid(); }
    uint32_t rot() const { return at<4>().as_uint32(); }
    bool has_fl() const { return at<5>().valid(); }
    uint32_t fl() const { return at<5>().as_uint32(); }
    bool has_lut() const { return at<6>().valid(); }
    uint32_t lut() const { return at<6>().as_uint32(); }
    bool has_linear() const { return at<7>().valid(); }
    uint32_t linear() const { return at<7>().as_uint32(); }
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_fmt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_intf(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rot(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_fl(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_lut(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_linear(uint32_t value) {
    AppendVarInt(7, value);
  }
};

class PERFETTO_EXPORT MdpMisrCrcFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kBlockIdFieldNumber = 1,
    kVsyncCntFieldNumber = 2,
    kCrcFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_block_id() const { return at<1>().valid(); }
    uint32_t block_id() const { return at<1>().as_uint32(); }
    bool has_vsync_cnt() const { return at<2>().valid(); }
    uint32_t vsync_cnt() const { return at<2>().as_uint32(); }
    bool has_crc() const { return at<3>().valid(); }
    uint32_t crc() const { return at<3>().as_uint32(); }
  };
  void set_block_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_vsync_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_crc(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT MdpCmdReadptrDoneFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kKoffCntFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_ctl_num() const { return at<1>().valid(); }
    uint32_t ctl_num() const { return at<1>().as_uint32(); }
    bool has_koff_cnt() const { return at<2>().valid(); }
    int32_t koff_cnt() const { return at<2>().as_int32(); }
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_koff_cnt(int32_t value) {
    AppendVarInt(2, value);
  }
};

class PERFETTO_EXPORT MdpSsppSetFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kMixerFieldNumber = 3,
    kStageFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kFormatFieldNumber = 6,
    kImgWFieldNumber = 7,
    kImgHFieldNumber = 8,
    kSrcXFieldNumber = 9,
    kSrcYFieldNumber = 10,
    kSrcWFieldNumber = 11,
    kSrcHFieldNumber = 12,
    kDstXFieldNumber = 13,
    kDstYFieldNumber = 14,
    kDstWFieldNumber = 15,
    kDstHFieldNumber = 16,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/16, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_num() const { return at<1>().valid(); }
    uint32_t num() const { return at<1>().as_uint32(); }
    bool has_play_cnt() const { return at<2>().valid(); }
    uint32_t play_cnt() const { return at<2>().as_uint32(); }
    bool has_mixer() const { return at<3>().valid(); }
    uint32_t mixer() const { return at<3>().as_uint32(); }
    bool has_stage() const { return at<4>().valid(); }
    uint32_t stage() const { return at<4>().as_uint32(); }
    bool has_flags() const { return at<5>().valid(); }
    uint32_t flags() const { return at<5>().as_uint32(); }
    bool has_format() const { return at<6>().valid(); }
    uint32_t format() const { return at<6>().as_uint32(); }
    bool has_img_w() const { return at<7>().valid(); }
    uint32_t img_w() const { return at<7>().as_uint32(); }
    bool has_img_h() const { return at<8>().valid(); }
    uint32_t img_h() const { return at<8>().as_uint32(); }
    bool has_src_x() const { return at<9>().valid(); }
    uint32_t src_x() const { return at<9>().as_uint32(); }
    bool has_src_y() const { return at<10>().valid(); }
    uint32_t src_y() const { return at<10>().as_uint32(); }
    bool has_src_w() const { return at<11>().valid(); }
    uint32_t src_w() const { return at<11>().as_uint32(); }
    bool has_src_h() const { return at<12>().valid(); }
    uint32_t src_h() const { return at<12>().as_uint32(); }
    bool has_dst_x() const { return at<13>().valid(); }
    uint32_t dst_x() const { return at<13>().as_uint32(); }
    bool has_dst_y() const { return at<14>().valid(); }
    uint32_t dst_y() const { return at<14>().as_uint32(); }
    bool has_dst_w() const { return at<15>().valid(); }
    uint32_t dst_w() const { return at<15>().as_uint32(); }
    bool has_dst_h() const { return at<16>().valid(); }
    uint32_t dst_h() const { return at<16>().as_uint32(); }
  };
  void set_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_play_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mixer(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_stage(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_format(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_img_w(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_img_h(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_src_x(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_src_y(uint32_t value) {
    AppendVarInt(10, value);
  }
  void set_src_w(uint32_t value) {
    AppendVarInt(11, value);
  }
  void set_src_h(uint32_t value) {
    AppendVarInt(12, value);
  }
  void set_dst_x(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_dst_y(uint32_t value) {
    AppendVarInt(14, value);
  }
  void set_dst_w(uint32_t value) {
    AppendVarInt(15, value);
  }
  void set_dst_h(uint32_t value) {
    AppendVarInt(16, value);
  }
};

class PERFETTO_EXPORT MdpPerfSetPanicLutsFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kPnumFieldNumber = 1,
    kFmtFieldNumber = 2,
    kModeFieldNumber = 3,
    kPanicLutFieldNumber = 4,
    kRobustLutFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_pnum() const { return at<1>().valid(); }
    uint32_t pnum() const { return at<1>().as_uint32(); }
    bool has_fmt() const { return at<2>().valid(); }
    uint32_t fmt() const { return at<2>().as_uint32(); }
    bool has_mode() const { return at<3>().valid(); }
    uint32_t mode() const { return at<3>().as_uint32(); }
    bool has_panic_lut() const { return at<4>().valid(); }
    uint32_t panic_lut() const { return at<4>().as_uint32(); }
    bool has_robust_lut() const { return at<5>().valid(); }
    uint32_t robust_lut() const { return at<5>().as_uint32(); }
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_fmt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_panic_lut(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_robust_lut(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT MdpCompareBwFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kNewAbFieldNumber = 1,
    kNewIbFieldNumber = 2,
    kNewWbFieldNumber = 3,
    kOldAbFieldNumber = 4,
    kOldIbFieldNumber = 5,
    kOldWbFieldNumber = 6,
    kParamsChangedFieldNumber = 7,
    kUpdateBwFieldNumber = 8,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_new_ab() const { return at<1>().valid(); }
    uint64_t new_ab() const { return at<1>().as_uint64(); }
    bool has_new_ib() const { return at<2>().valid(); }
    uint64_t new_ib() const { return at<2>().as_uint64(); }
    bool has_new_wb() const { return at<3>().valid(); }
    uint64_t new_wb() const { return at<3>().as_uint64(); }
    bool has_old_ab() const { return at<4>().valid(); }
    uint64_t old_ab() const { return at<4>().as_uint64(); }
    bool has_old_ib() const { return at<5>().valid(); }
    uint64_t old_ib() const { return at<5>().as_uint64(); }
    bool has_old_wb() const { return at<6>().valid(); }
    uint64_t old_wb() const { return at<6>().as_uint64(); }
    bool has_params_changed() const { return at<7>().valid(); }
    uint32_t params_changed() const { return at<7>().as_uint32(); }
    bool has_update_bw() const { return at<8>().valid(); }
    uint32_t update_bw() const { return at<8>().as_uint32(); }
  };
  void set_new_ab(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_new_ib(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_new_wb(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_old_ab(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_old_ib(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_old_wb(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_params_changed(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_update_bw(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class PERFETTO_EXPORT MdpCmdPingpongDoneFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kIntfNumFieldNumber = 2,
    kPpNumFieldNumber = 3,
    kKoffCntFieldNumber = 4,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_ctl_num() const { return at<1>().valid(); }
    uint32_t ctl_num() const { return at<1>().as_uint32(); }
    bool has_intf_num() const { return at<2>().valid(); }
    uint32_t intf_num() const { return at<2>().as_uint32(); }
    bool has_pp_num() const { return at<3>().valid(); }
    uint32_t pp_num() const { return at<3>().as_uint32(); }
    bool has_koff_cnt() const { return at<4>().valid(); }
    int32_t koff_cnt() const { return at<4>().as_int32(); }
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_intf_num(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_pp_num(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_koff_cnt(int32_t value) {
    AppendVarInt(4, value);
  }
};

class PERFETTO_EXPORT TracingMarkWriteFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kPidFieldNumber = 1,
    kTraceNameFieldNumber = 2,
    kTraceBeginFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_pid() const { return at<1>().valid(); }
    int32_t pid() const { return at<1>().as_int32(); }
    bool has_trace_name() const { return at<2>().valid(); }
    ::protozero::ConstChars trace_name() const { return at<2>().as_string(); }
    bool has_trace_begin() const { return at<3>().valid(); }
    uint32_t trace_begin() const { return at<3>().as_uint32(); }
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_trace_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_trace_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_trace_begin(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT MdpSsppChangeFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kMixerFieldNumber = 3,
    kStageFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kFormatFieldNumber = 6,
    kImgWFieldNumber = 7,
    kImgHFieldNumber = 8,
    kSrcXFieldNumber = 9,
    kSrcYFieldNumber = 10,
    kSrcWFieldNumber = 11,
    kSrcHFieldNumber = 12,
    kDstXFieldNumber = 13,
    kDstYFieldNumber = 14,
    kDstWFieldNumber = 15,
    kDstHFieldNumber = 16,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/16, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_num() const { return at<1>().valid(); }
    uint32_t num() const { return at<1>().as_uint32(); }
    bool has_play_cnt() const { return at<2>().valid(); }
    uint32_t play_cnt() const { return at<2>().as_uint32(); }
    bool has_mixer() const { return at<3>().valid(); }
    uint32_t mixer() const { return at<3>().as_uint32(); }
    bool has_stage() const { return at<4>().valid(); }
    uint32_t stage() const { return at<4>().as_uint32(); }
    bool has_flags() const { return at<5>().valid(); }
    uint32_t flags() const { return at<5>().as_uint32(); }
    bool has_format() const { return at<6>().valid(); }
    uint32_t format() const { return at<6>().as_uint32(); }
    bool has_img_w() const { return at<7>().valid(); }
    uint32_t img_w() const { return at<7>().as_uint32(); }
    bool has_img_h() const { return at<8>().valid(); }
    uint32_t img_h() const { return at<8>().as_uint32(); }
    bool has_src_x() const { return at<9>().valid(); }
    uint32_t src_x() const { return at<9>().as_uint32(); }
    bool has_src_y() const { return at<10>().valid(); }
    uint32_t src_y() const { return at<10>().as_uint32(); }
    bool has_src_w() const { return at<11>().valid(); }
    uint32_t src_w() const { return at<11>().as_uint32(); }
    bool has_src_h() const { return at<12>().valid(); }
    uint32_t src_h() const { return at<12>().as_uint32(); }
    bool has_dst_x() const { return at<13>().valid(); }
    uint32_t dst_x() const { return at<13>().as_uint32(); }
    bool has_dst_y() const { return at<14>().valid(); }
    uint32_t dst_y() const { return at<14>().as_uint32(); }
    bool has_dst_w() const { return at<15>().valid(); }
    uint32_t dst_w() const { return at<15>().as_uint32(); }
    bool has_dst_h() const { return at<16>().valid(); }
    uint32_t dst_h() const { return at<16>().as_uint32(); }
  };
  void set_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_play_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mixer(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_stage(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_format(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_img_w(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_img_h(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_src_x(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_src_y(uint32_t value) {
    AppendVarInt(10, value);
  }
  void set_src_w(uint32_t value) {
    AppendVarInt(11, value);
  }
  void set_src_h(uint32_t value) {
    AppendVarInt(12, value);
  }
  void set_dst_x(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_dst_y(uint32_t value) {
    AppendVarInt(14, value);
  }
  void set_dst_w(uint32_t value) {
    AppendVarInt(15, value);
  }
  void set_dst_h(uint32_t value) {
    AppendVarInt(16, value);
  }
};

class PERFETTO_EXPORT MdpPerfSetOtFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kPnumFieldNumber = 1,
    kXinIdFieldNumber = 2,
    kRdLimFieldNumber = 3,
    kIsVbifRtFieldNumber = 4,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_pnum() const { return at<1>().valid(); }
    uint32_t pnum() const { return at<1>().as_uint32(); }
    bool has_xin_id() const { return at<2>().valid(); }
    uint32_t xin_id() const { return at<2>().as_uint32(); }
    bool has_rd_lim() const { return at<3>().valid(); }
    uint32_t rd_lim() const { return at<3>().as_uint32(); }
    bool has_is_vbif_rt() const { return at<4>().valid(); }
    uint32_t is_vbif_rt() const { return at<4>().as_uint32(); }
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_xin_id(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_rd_lim(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_is_vbif_rt(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class PERFETTO_EXPORT MdpCommitFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kClkRateFieldNumber = 3,
    kBandwidthFieldNumber = 4,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_num() const { return at<1>().valid(); }
    uint32_t num() const { return at<1>().as_uint32(); }
    bool has_play_cnt() const { return at<2>().valid(); }
    uint32_t play_cnt() const { return at<2>().as_uint32(); }
    bool has_clk_rate() const { return at<3>().valid(); }
    uint32_t clk_rate() const { return at<3>().as_uint32(); }
    bool has_bandwidth() const { return at<4>().valid(); }
    uint64_t bandwidth() const { return at<4>().as_uint64(); }
  };
  void set_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_play_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_clk_rate(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_bandwidth(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class PERFETTO_EXPORT MdpCmdKickoffFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kKickoffCntFieldNumber = 2,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_ctl_num() const { return at<1>().valid(); }
    uint32_t ctl_num() const { return at<1>().as_uint32(); }
    bool has_kickoff_cnt() const { return at<2>().valid(); }
    int32_t kickoff_cnt() const { return at<2>().as_int32(); }
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_kickoff_cnt(int32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
