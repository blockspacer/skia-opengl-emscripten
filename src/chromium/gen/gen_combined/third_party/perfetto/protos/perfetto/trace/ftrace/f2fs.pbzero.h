// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PERFETTO_TRACE_FTRACE_F2FS_PROTO_H_
#define PERFETTO_PROTOS_PERFETTO_TRACE_FTRACE_F2FS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/base/export.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/message.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class PERFETTO_EXPORT F2fsWriteEndFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_pos() const { return at<3>().valid(); }
    int64_t pos() const { return at<3>().as_int64(); }
    bool has_len() const { return at<4>().valid(); }
    uint32_t len() const { return at<4>().as_uint32(); }
    bool has_copied() const { return at<5>().valid(); }
    uint32_t copied() const { return at<5>().as_uint32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_copied(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT F2fsWriteCheckpointFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kIsUmountFieldNumber = 2,
    kMsgFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_is_umount() const { return at<2>().valid(); }
    uint32_t is_umount() const { return at<2>().as_uint32(); }
    bool has_msg() const { return at<3>().valid(); }
    ::protozero::ConstChars msg() const { return at<3>().as_string(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_is_umount(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_msg(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_msg(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
};

class PERFETTO_EXPORT F2fsWriteBeginFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_pos() const { return at<3>().valid(); }
    int64_t pos() const { return at<3>().as_int64(); }
    bool has_len() const { return at<4>().valid(); }
    uint32_t len() const { return at<4>().as_uint32(); }
    bool has_flags() const { return at<5>().valid(); }
    uint32_t flags() const { return at<5>().as_uint32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT F2fsVmPageMkwriteFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDirFieldNumber = 4,
    kIndexFieldNumber = 5,
    kDirtyFieldNumber = 6,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_type() const { return at<3>().valid(); }
    int32_t type() const { return at<3>().as_int32(); }
    bool has_dir() const { return at<4>().valid(); }
    int32_t dir() const { return at<4>().as_int32(); }
    bool has_index() const { return at<5>().valid(); }
    uint64_t index() const { return at<5>().as_uint64(); }
    bool has_dirty() const { return at<6>().valid(); }
    int32_t dirty() const { return at<6>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_dir(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_dirty(int32_t value) {
    AppendVarInt(6, value);
  }
};

class PERFETTO_EXPORT F2fsUnlinkExitFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_ret() const { return at<3>().valid(); }
    int32_t ret() const { return at<3>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT F2fsUnlinkEnterFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kNameFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_size() const { return at<3>().valid(); }
    int64_t size() const { return at<3>().as_int64(); }
    bool has_blocks() const { return at<4>().valid(); }
    uint64_t blocks() const { return at<4>().as_uint64(); }
    bool has_name() const { return at<5>().valid(); }
    ::protozero::ConstChars name() const { return at<5>().as_string(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_name(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

class PERFETTO_EXPORT F2fsTruncatePartialNodesFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kDepthFieldNumber = 4,
    kErrFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_nid() const { return at<3>().valid(); }
    uint32_t nid() const { return at<3>().as_uint32(); }
    bool has_depth() const { return at<4>().valid(); }
    int32_t depth() const { return at<4>().as_int32(); }
    bool has_err() const { return at<5>().valid(); }
    int32_t err() const { return at<5>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_depth(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_err(int32_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT F2fsTruncateNodesExitFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_ret() const { return at<3>().valid(); }
    int32_t ret() const { return at<3>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT F2fsTruncateNodesEnterFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kBlkAddrFieldNumber = 4,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_nid() const { return at<3>().valid(); }
    uint32_t nid() const { return at<3>().as_uint32(); }
    bool has_blk_addr() const { return at<4>().valid(); }
    uint32_t blk_addr() const { return at<4>().as_uint32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_blk_addr(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class PERFETTO_EXPORT F2fsTruncateNodeFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kBlkAddrFieldNumber = 4,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_nid() const { return at<3>().valid(); }
    uint32_t nid() const { return at<3>().as_uint32(); }
    bool has_blk_addr() const { return at<4>().valid(); }
    uint32_t blk_addr() const { return at<4>().as_uint32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_blk_addr(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class PERFETTO_EXPORT F2fsTruncateInodeBlocksExitFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_ret() const { return at<3>().valid(); }
    int32_t ret() const { return at<3>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT F2fsTruncateInodeBlocksEnterFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kFromFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_size() const { return at<3>().valid(); }
    int64_t size() const { return at<3>().as_int64(); }
    bool has_blocks() const { return at<4>().valid(); }
    uint64_t blocks() const { return at<4>().as_uint64(); }
    bool has_from() const { return at<5>().valid(); }
    uint64_t from() const { return at<5>().as_uint64(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_from(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT F2fsTruncateDataBlocksRangeFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kOfsFieldNumber = 4,
    kFreeFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_nid() const { return at<3>().valid(); }
    uint32_t nid() const { return at<3>().as_uint32(); }
    bool has_ofs() const { return at<4>().valid(); }
    uint32_t ofs() const { return at<4>().as_uint32(); }
    bool has_free() const { return at<5>().valid(); }
    int32_t free() const { return at<5>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_ofs(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_free(int32_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT F2fsTruncateBlocksExitFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_ret() const { return at<3>().valid(); }
    int32_t ret() const { return at<3>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT F2fsTruncateBlocksEnterFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kFromFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_size() const { return at<3>().valid(); }
    int64_t size() const { return at<3>().as_int64(); }
    bool has_blocks() const { return at<4>().valid(); }
    uint64_t blocks() const { return at<4>().as_uint64(); }
    bool has_from() const { return at<5>().valid(); }
    uint64_t from() const { return at<5>().as_uint64(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_from(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT F2fsTruncateFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_pino() const { return at<3>().valid(); }
    uint64_t pino() const { return at<3>().as_uint64(); }
    bool has_mode() const { return at<4>().valid(); }
    uint32_t mode() const { return at<4>().as_uint32(); }
    bool has_size() const { return at<5>().valid(); }
    int64_t size() const { return at<5>().as_int64(); }
    bool has_nlink() const { return at<6>().valid(); }
    uint32_t nlink() const { return at<6>().as_uint32(); }
    bool has_blocks() const { return at<7>().valid(); }
    uint64_t blocks() const { return at<7>().as_uint64(); }
    bool has_advise() const { return at<8>().valid(); }
    uint32_t advise() const { return at<8>().as_uint32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_nlink(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_advise(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class PERFETTO_EXPORT F2fsSyncFsFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kDirtyFieldNumber = 2,
    kWaitFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_dirty() const { return at<2>().valid(); }
    int32_t dirty() const { return at<2>().as_int32(); }
    bool has_wait() const { return at<3>().valid(); }
    int32_t wait() const { return at<3>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_dirty(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_wait(int32_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT F2fsSyncFileExitFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNeedCpFieldNumber = 3,
    kDatasyncFieldNumber = 4,
    kRetFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_need_cp() const { return at<3>().valid(); }
    uint32_t need_cp() const { return at<3>().as_uint32(); }
    bool has_datasync() const { return at<4>().valid(); }
    int32_t datasync() const { return at<4>().as_int32(); }
    bool has_ret() const { return at<5>().valid(); }
    int32_t ret() const { return at<5>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_need_cp(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_datasync(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT F2fsSyncFileEnterFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_pino() const { return at<3>().valid(); }
    uint64_t pino() const { return at<3>().as_uint64(); }
    bool has_mode() const { return at<4>().valid(); }
    uint32_t mode() const { return at<4>().as_uint32(); }
    bool has_size() const { return at<5>().valid(); }
    int64_t size() const { return at<5>().as_int64(); }
    bool has_nlink() const { return at<6>().valid(); }
    uint32_t nlink() const { return at<6>().as_uint32(); }
    bool has_blocks() const { return at<7>().valid(); }
    uint64_t blocks() const { return at<7>().as_uint64(); }
    bool has_advise() const { return at<8>().valid(); }
    uint32_t advise() const { return at<8>().as_uint32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_nlink(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_advise(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class PERFETTO_EXPORT F2fsSubmitWritePageFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kIndexFieldNumber = 4,
    kBlockFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_type() const { return at<3>().valid(); }
    int32_t type() const { return at<3>().as_int32(); }
    bool has_index() const { return at<4>().valid(); }
    uint64_t index() const { return at<4>().as_uint64(); }
    bool has_block() const { return at<5>().valid(); }
    uint32_t block() const { return at<5>().as_uint32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_block(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT F2fsSetPageDirtyFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDirFieldNumber = 4,
    kIndexFieldNumber = 5,
    kDirtyFieldNumber = 6,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_type() const { return at<3>().valid(); }
    int32_t type() const { return at<3>().as_int32(); }
    bool has_dir() const { return at<4>().valid(); }
    int32_t dir() const { return at<4>().as_int32(); }
    bool has_index() const { return at<5>().valid(); }
    uint64_t index() const { return at<5>().as_uint64(); }
    bool has_dirty() const { return at<6>().valid(); }
    int32_t dirty() const { return at<6>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_dir(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_dirty(int32_t value) {
    AppendVarInt(6, value);
  }
};

class PERFETTO_EXPORT F2fsReserveNewBlockFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kNidFieldNumber = 2,
    kOfsInNodeFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_nid() const { return at<2>().valid(); }
    uint32_t nid() const { return at<2>().as_uint32(); }
    bool has_ofs_in_node() const { return at<3>().valid(); }
    uint32_t ofs_in_node() const { return at<3>().as_uint32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_ofs_in_node(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT F2fsReadpageFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kBlkaddrFieldNumber = 4,
    kTypeFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_index() const { return at<3>().valid(); }
    uint64_t index() const { return at<3>().as_uint64(); }
    bool has_blkaddr() const { return at<4>().valid(); }
    uint64_t blkaddr() const { return at<4>().as_uint64(); }
    bool has_type() const { return at<5>().valid(); }
    int32_t type() const { return at<5>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_blkaddr(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(5, value);
  }
};

class PERFETTO_EXPORT F2fsNewInodeFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_ret() const { return at<3>().valid(); }
    int32_t ret() const { return at<3>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT F2fsIgetExitFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_ret() const { return at<3>().valid(); }
    int32_t ret() const { return at<3>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class PERFETTO_EXPORT F2fsIgetFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_pino() const { return at<3>().valid(); }
    uint64_t pino() const { return at<3>().as_uint64(); }
    bool has_mode() const { return at<4>().valid(); }
    uint32_t mode() const { return at<4>().as_uint32(); }
    bool has_size() const { return at<5>().valid(); }
    int64_t size() const { return at<5>().as_int64(); }
    bool has_nlink() const { return at<6>().valid(); }
    uint32_t nlink() const { return at<6>().as_uint32(); }
    bool has_blocks() const { return at<7>().valid(); }
    uint64_t blocks() const { return at<7>().as_uint64(); }
    bool has_advise() const { return at<8>().valid(); }
    uint32_t advise() const { return at<8>().as_uint32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_nlink(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_advise(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class PERFETTO_EXPORT F2fsGetVictimFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kTypeFieldNumber = 2,
    kGcTypeFieldNumber = 3,
    kAllocModeFieldNumber = 4,
    kGcModeFieldNumber = 5,
    kVictimFieldNumber = 6,
    kOfsUnitFieldNumber = 7,
    kPreVictimFieldNumber = 8,
    kPrefreeFieldNumber = 9,
    kFreeFieldNumber = 10,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_type() const { return at<2>().valid(); }
    int32_t type() const { return at<2>().as_int32(); }
    bool has_gc_type() const { return at<3>().valid(); }
    int32_t gc_type() const { return at<3>().as_int32(); }
    bool has_alloc_mode() const { return at<4>().valid(); }
    int32_t alloc_mode() const { return at<4>().as_int32(); }
    bool has_gc_mode() const { return at<5>().valid(); }
    int32_t gc_mode() const { return at<5>().as_int32(); }
    bool has_victim() const { return at<6>().valid(); }
    uint32_t victim() const { return at<6>().as_uint32(); }
    bool has_ofs_unit() const { return at<7>().valid(); }
    uint32_t ofs_unit() const { return at<7>().as_uint32(); }
    bool has_pre_victim() const { return at<8>().valid(); }
    uint32_t pre_victim() const { return at<8>().as_uint32(); }
    bool has_prefree() const { return at<9>().valid(); }
    uint32_t prefree() const { return at<9>().as_uint32(); }
    bool has_free() const { return at<10>().valid(); }
    uint32_t free() const { return at<10>().as_uint32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_gc_type(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_alloc_mode(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_gc_mode(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_victim(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_ofs_unit(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_pre_victim(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_prefree(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_free(uint32_t value) {
    AppendVarInt(10, value);
  }
};

class PERFETTO_EXPORT F2fsGetDataBlockFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIblockFieldNumber = 3,
    kBhStartFieldNumber = 4,
    kBhSizeFieldNumber = 5,
    kRetFieldNumber = 6,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_iblock() const { return at<3>().valid(); }
    uint64_t iblock() const { return at<3>().as_uint64(); }
    bool has_bh_start() const { return at<4>().valid(); }
    uint64_t bh_start() const { return at<4>().as_uint64(); }
    bool has_bh_size() const { return at<5>().valid(); }
    uint64_t bh_size() const { return at<5>().as_uint64(); }
    bool has_ret() const { return at<6>().valid(); }
    int32_t ret() const { return at<6>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_iblock(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_bh_start(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_bh_size(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(6, value);
  }
};

class PERFETTO_EXPORT F2fsFallocateFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kModeFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLenFieldNumber = 5,
    kSizeFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kRetFieldNumber = 8,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_mode() const { return at<3>().valid(); }
    int32_t mode() const { return at<3>().as_int32(); }
    bool has_offset() const { return at<4>().valid(); }
    int64_t offset() const { return at<4>().as_int64(); }
    bool has_len() const { return at<5>().valid(); }
    int64_t len() const { return at<5>().as_int64(); }
    bool has_size() const { return at<6>().valid(); }
    int64_t size() const { return at<6>().as_int64(); }
    bool has_blocks() const { return at<7>().valid(); }
    uint64_t blocks() const { return at<7>().as_uint64(); }
    bool has_ret() const { return at<8>().valid(); }
    int32_t ret() const { return at<8>().as_int32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_mode(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(8, value);
  }
};

class PERFETTO_EXPORT F2fsEvictInodeFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_ino() const { return at<2>().valid(); }
    uint64_t ino() const { return at<2>().as_uint64(); }
    bool has_pino() const { return at<3>().valid(); }
    uint64_t pino() const { return at<3>().as_uint64(); }
    bool has_mode() const { return at<4>().valid(); }
    uint32_t mode() const { return at<4>().as_uint32(); }
    bool has_size() const { return at<5>().valid(); }
    int64_t size() const { return at<5>().as_int64(); }
    bool has_nlink() const { return at<6>().valid(); }
    uint32_t nlink() const { return at<6>().as_uint32(); }
    bool has_blocks() const { return at<7>().valid(); }
    uint64_t blocks() const { return at<7>().as_uint64(); }
    bool has_advise() const { return at<8>().valid(); }
    uint32_t advise() const { return at<8>().as_uint32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_nlink(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_advise(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class PERFETTO_EXPORT F2fsDoSubmitBioFtraceEvent : public ::protozero::Message {
 public:
  enum : int32_t {
    kDevFieldNumber = 1,
    kBtypeFieldNumber = 2,
    kSyncFieldNumber = 3,
    kSectorFieldNumber = 4,
    kSizeFieldNumber = 5,
  };
  class Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_REPEATED_FIELDS=*/false> {
   public:
    Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
    bool has_dev() const { return at<1>().valid(); }
    uint64_t dev() const { return at<1>().as_uint64(); }
    bool has_btype() const { return at<2>().valid(); }
    int32_t btype() const { return at<2>().as_int32(); }
    bool has_sync() const { return at<3>().valid(); }
    uint32_t sync() const { return at<3>().as_uint32(); }
    bool has_sector() const { return at<4>().valid(); }
    uint64_t sector() const { return at<4>().as_uint64(); }
    bool has_size() const { return at<5>().valid(); }
    uint32_t size() const { return at<5>().as_uint32(); }
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_btype(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_sync(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_size(uint32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
