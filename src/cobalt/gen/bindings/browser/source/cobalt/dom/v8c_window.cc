

// Copyright 2019 The Cobalt Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// clang-format off

// This file has been auto-generated by bindings/code_generator_cobalt.py. DO NOT MODIFY!
// Auto-generated from template: bindings/v8c/templates/interface.cc.template

#include "cobalt/dom/v8c_window.h"

#include "base/trace_event/trace_event.h"
#include "cobalt/base/polymorphic_downcast.h"
#include "cobalt/script/global_environment.h"
#include "cobalt/script/script_value.h"
#include "cobalt/script/value_handle.h"
#include "cobalt/audio/audio_buffer.h"
#include "cobalt/audio/audio_buffer_source_node.h"
#include "cobalt/audio/audio_context.h"
#include "cobalt/audio/audio_destination_node.h"
#include "cobalt/audio/audio_node.h"
#include "cobalt/audio/v8c_audio_buffer.h"
#include "cobalt/audio/v8c_audio_buffer_source_node.h"
#include "cobalt/audio/v8c_audio_context.h"
#include "cobalt/audio/v8c_audio_destination_node.h"
#include "cobalt/audio/v8c_audio_node.h"
#include "cobalt/cssom/css.h"
#include "cobalt/cssom/css_condition_rule.h"
#include "cobalt/cssom/css_font_face_rule.h"
#include "cobalt/cssom/css_grouping_rule.h"
#include "cobalt/cssom/css_keyframe_rule.h"
#include "cobalt/cssom/css_keyframes_rule.h"
#include "cobalt/cssom/css_media_rule.h"
#include "cobalt/cssom/css_rule.h"
#include "cobalt/cssom/css_rule_list.h"
#include "cobalt/cssom/css_style_declaration.h"
#include "cobalt/cssom/css_style_rule.h"
#include "cobalt/cssom/css_style_sheet.h"
#include "cobalt/cssom/media_list.h"
#include "cobalt/cssom/style_sheet.h"
#include "cobalt/cssom/style_sheet_list.h"
#include "cobalt/cssom/v8c_css.h"
#include "cobalt/cssom/v8c_css_condition_rule.h"
#include "cobalt/cssom/v8c_css_font_face_rule.h"
#include "cobalt/cssom/v8c_css_grouping_rule.h"
#include "cobalt/cssom/v8c_css_keyframe_rule.h"
#include "cobalt/cssom/v8c_css_keyframes_rule.h"
#include "cobalt/cssom/v8c_css_media_rule.h"
#include "cobalt/cssom/v8c_css_rule.h"
#include "cobalt/cssom/v8c_css_rule_list.h"
#include "cobalt/cssom/v8c_css_style_declaration.h"
#include "cobalt/cssom/v8c_css_style_rule.h"
#include "cobalt/cssom/v8c_css_style_sheet.h"
#include "cobalt/cssom/v8c_media_list.h"
#include "cobalt/cssom/v8c_style_sheet.h"
#include "cobalt/cssom/v8c_style_sheet_list.h"
#include "cobalt/debug/backend/css_agent.h"
#include "cobalt/debug/backend/debug_backend.h"
#include "cobalt/debug/backend/v8c_css_agent.h"
#include "cobalt/debug/backend/v8c_debug_backend.h"
#include "cobalt/debug/console/debug_hub.h"
#include "cobalt/debug/console/debugger_event_target.h"
#include "cobalt/debug/console/v8c_debug_hub.h"
#include "cobalt/debug/console/v8c_debugger_event_target.h"
#include "cobalt/dom/animation_event.h"
#include "cobalt/dom/attr.h"
#include "cobalt/dom/audio_track.h"
#include "cobalt/dom/audio_track_list.h"
#include "cobalt/dom/blob.h"
#include "cobalt/dom/c_val_key_list.h"
#include "cobalt/dom/c_val_view.h"
#include "cobalt/dom/camera_3d.h"
#include "cobalt/dom/captions/system_caption_settings.h"
#include "cobalt/dom/captions/v8c_system_caption_settings.h"
#include "cobalt/dom/cdata_section.h"
#include "cobalt/dom/character_data.h"
#include "cobalt/dom/comment.h"
#include "cobalt/dom/console.h"
#include "cobalt/dom/crypto.h"
#include "cobalt/dom/custom_event.h"
#include "cobalt/dom/device_orientation_event.h"
#include "cobalt/dom/document.h"
#include "cobalt/dom/document_timeline.h"
#include "cobalt/dom/document_type.h"
#include "cobalt/dom/dom_exception.h"
#include "cobalt/dom/dom_implementation.h"
#include "cobalt/dom/dom_parser.h"
#include "cobalt/dom/dom_rect.h"
#include "cobalt/dom/dom_rect_list.h"
#include "cobalt/dom/dom_rect_read_only.h"
#include "cobalt/dom/dom_string_map.h"
#include "cobalt/dom/dom_token_list.h"
#include "cobalt/dom/element.h"
#include "cobalt/dom/eme/media_encrypted_event.h"
#include "cobalt/dom/eme/media_key_message_event.h"
#include "cobalt/dom/eme/media_key_session.h"
#include "cobalt/dom/eme/media_key_status_map.h"
#include "cobalt/dom/eme/media_key_system_access.h"
#include "cobalt/dom/eme/media_keys.h"
#include "cobalt/dom/eme/v8c_media_encrypted_event.h"
#include "cobalt/dom/eme/v8c_media_key_message_event.h"
#include "cobalt/dom/eme/v8c_media_key_session.h"
#include "cobalt/dom/eme/v8c_media_key_status_map.h"
#include "cobalt/dom/eme/v8c_media_key_system_access.h"
#include "cobalt/dom/eme/v8c_media_keys.h"
#include "cobalt/dom/error_event.h"
#include "cobalt/dom/event.h"
#include "cobalt/dom/event_listener.h"
#include "cobalt/dom/event_target.h"
#include "cobalt/dom/focus_event.h"
#include "cobalt/dom/history.h"
#include "cobalt/dom/html_anchor_element.h"
#include "cobalt/dom/html_body_element.h"
#include "cobalt/dom/html_br_element.h"
#include "cobalt/dom/html_collection.h"
#include "cobalt/dom/html_div_element.h"
#include "cobalt/dom/html_element.h"
#include "cobalt/dom/html_head_element.h"
#include "cobalt/dom/html_heading_element.h"
#include "cobalt/dom/html_html_element.h"
#include "cobalt/dom/html_image_element.h"
#include "cobalt/dom/html_link_element.h"
#include "cobalt/dom/html_media_element.h"
#include "cobalt/dom/html_meta_element.h"
#include "cobalt/dom/html_paragraph_element.h"
#include "cobalt/dom/html_script_element.h"
#include "cobalt/dom/html_span_element.h"
#include "cobalt/dom/html_style_element.h"
#include "cobalt/dom/html_title_element.h"
#include "cobalt/dom/html_unknown_element.h"
#include "cobalt/dom/html_video_element.h"
#include "cobalt/dom/input_event.h"
#include "cobalt/dom/keyboard_event.h"
#include "cobalt/dom/location.h"
#include "cobalt/dom/media_error.h"
#include "cobalt/dom/media_query_list.h"
#include "cobalt/dom/media_source.h"
#include "cobalt/dom/memory_info.h"
#include "cobalt/dom/message_event.h"
#include "cobalt/dom/mime_type_array.h"
#include "cobalt/dom/mouse_event.h"
#include "cobalt/dom/mutation_observer.h"
#include "cobalt/dom/mutation_record.h"
#include "cobalt/dom/named_node_map.h"
#include "cobalt/dom/navigator.h"
#include "cobalt/dom/node.h"
#include "cobalt/dom/node_list.h"
#include "cobalt/dom/on_error_event_listener.h"
#include "cobalt/dom/on_screen_keyboard.h"
#include "cobalt/dom/performance.h"
#include "cobalt/dom/performance_timing.h"
#include "cobalt/dom/plugin_array.h"
#include "cobalt/dom/pointer_event.h"
#include "cobalt/dom/progress_event.h"
#include "cobalt/dom/screen.h"
#include "cobalt/dom/screenshot.h"
#include "cobalt/dom/security_policy_violation_event.h"
#include "cobalt/dom/source_buffer.h"
#include "cobalt/dom/source_buffer_list.h"
#include "cobalt/dom/storage.h"
#include "cobalt/dom/storage_event.h"
#include "cobalt/dom/test_runner.h"
#include "cobalt/dom/text.h"
#include "cobalt/dom/time_ranges.h"
#include "cobalt/dom/track_default.h"
#include "cobalt/dom/track_default_list.h"
#include "cobalt/dom/track_event.h"
#include "cobalt/dom/transition_event.h"
#include "cobalt/dom/ui_event.h"
#include "cobalt/dom/url.h"
#include "cobalt/dom/v8c_animation_event.h"
#include "cobalt/dom/v8c_attr.h"
#include "cobalt/dom/v8c_audio_track.h"
#include "cobalt/dom/v8c_audio_track_list.h"
#include "cobalt/dom/v8c_blob.h"
#include "cobalt/dom/v8c_c_val_key_list.h"
#include "cobalt/dom/v8c_c_val_view.h"
#include "cobalt/dom/v8c_camera_3d.h"
#include "cobalt/dom/v8c_cdata_section.h"
#include "cobalt/dom/v8c_character_data.h"
#include "cobalt/dom/v8c_comment.h"
#include "cobalt/dom/v8c_console.h"
#include "cobalt/dom/v8c_crypto.h"
#include "cobalt/dom/v8c_custom_event.h"
#include "cobalt/dom/v8c_device_orientation_event.h"
#include "cobalt/dom/v8c_document.h"
#include "cobalt/dom/v8c_document_timeline.h"
#include "cobalt/dom/v8c_document_type.h"
#include "cobalt/dom/v8c_dom_exception.h"
#include "cobalt/dom/v8c_dom_implementation.h"
#include "cobalt/dom/v8c_dom_parser.h"
#include "cobalt/dom/v8c_dom_rect.h"
#include "cobalt/dom/v8c_dom_rect_list.h"
#include "cobalt/dom/v8c_dom_rect_read_only.h"
#include "cobalt/dom/v8c_dom_string_map.h"
#include "cobalt/dom/v8c_dom_token_list.h"
#include "cobalt/dom/v8c_element.h"
#include "cobalt/dom/v8c_error_event.h"
#include "cobalt/dom/v8c_event.h"
#include "cobalt/dom/v8c_event_listener.h"
#include "cobalt/dom/v8c_event_target.h"
#include "cobalt/dom/v8c_focus_event.h"
#include "cobalt/dom/v8c_history.h"
#include "cobalt/dom/v8c_html_anchor_element.h"
#include "cobalt/dom/v8c_html_body_element.h"
#include "cobalt/dom/v8c_html_br_element.h"
#include "cobalt/dom/v8c_html_collection.h"
#include "cobalt/dom/v8c_html_div_element.h"
#include "cobalt/dom/v8c_html_element.h"
#include "cobalt/dom/v8c_html_head_element.h"
#include "cobalt/dom/v8c_html_heading_element.h"
#include "cobalt/dom/v8c_html_html_element.h"
#include "cobalt/dom/v8c_html_image_element.h"
#include "cobalt/dom/v8c_html_link_element.h"
#include "cobalt/dom/v8c_html_media_element.h"
#include "cobalt/dom/v8c_html_meta_element.h"
#include "cobalt/dom/v8c_html_paragraph_element.h"
#include "cobalt/dom/v8c_html_script_element.h"
#include "cobalt/dom/v8c_html_span_element.h"
#include "cobalt/dom/v8c_html_style_element.h"
#include "cobalt/dom/v8c_html_title_element.h"
#include "cobalt/dom/v8c_html_unknown_element.h"
#include "cobalt/dom/v8c_html_video_element.h"
#include "cobalt/dom/v8c_input_event.h"
#include "cobalt/dom/v8c_keyboard_event.h"
#include "cobalt/dom/v8c_location.h"
#include "cobalt/dom/v8c_media_error.h"
#include "cobalt/dom/v8c_media_query_list.h"
#include "cobalt/dom/v8c_media_source.h"
#include "cobalt/dom/v8c_memory_info.h"
#include "cobalt/dom/v8c_message_event.h"
#include "cobalt/dom/v8c_mime_type_array.h"
#include "cobalt/dom/v8c_mouse_event.h"
#include "cobalt/dom/v8c_mutation_observer.h"
#include "cobalt/dom/v8c_mutation_record.h"
#include "cobalt/dom/v8c_named_node_map.h"
#include "cobalt/dom/v8c_navigator.h"
#include "cobalt/dom/v8c_node.h"
#include "cobalt/dom/v8c_node_list.h"
#include "cobalt/dom/v8c_on_error_event_listener.h"
#include "cobalt/dom/v8c_on_screen_keyboard.h"
#include "cobalt/dom/v8c_performance.h"
#include "cobalt/dom/v8c_performance_timing.h"
#include "cobalt/dom/v8c_plugin_array.h"
#include "cobalt/dom/v8c_pointer_event.h"
#include "cobalt/dom/v8c_progress_event.h"
#include "cobalt/dom/v8c_screen.h"
#include "cobalt/dom/v8c_screenshot.h"
#include "cobalt/dom/v8c_security_policy_violation_event.h"
#include "cobalt/dom/v8c_source_buffer.h"
#include "cobalt/dom/v8c_source_buffer_list.h"
#include "cobalt/dom/v8c_storage.h"
#include "cobalt/dom/v8c_storage_event.h"
#include "cobalt/dom/v8c_test_runner.h"
#include "cobalt/dom/v8c_text.h"
#include "cobalt/dom/v8c_time_ranges.h"
#include "cobalt/dom/v8c_track_default.h"
#include "cobalt/dom/v8c_track_default_list.h"
#include "cobalt/dom/v8c_track_event.h"
#include "cobalt/dom/v8c_transition_event.h"
#include "cobalt/dom/v8c_ui_event.h"
#include "cobalt/dom/v8c_url.h"
#include "cobalt/dom/v8c_video_playback_quality.h"
#include "cobalt/dom/v8c_video_track.h"
#include "cobalt/dom/v8c_video_track_list.h"
#include "cobalt/dom/v8c_wheel_event.h"
#include "cobalt/dom/v8c_window.h"
#include "cobalt/dom/v8c_xml_document.h"
#include "cobalt/dom/v8c_xml_serializer.h"
#include "cobalt/dom/video_playback_quality.h"
#include "cobalt/dom/video_track.h"
#include "cobalt/dom/video_track_list.h"
#include "cobalt/dom/wheel_event.h"
#include "cobalt/dom/window.h"
#include "cobalt/dom/xml_document.h"
#include "cobalt/dom/xml_serializer.h"
#include "cobalt/fetch/fetch_internal.h"
#include "cobalt/fetch/v8c_fetch_internal.h"
#include "cobalt/h5vcc/dial/dial_http_request.h"
#include "cobalt/h5vcc/dial/dial_http_response.h"
#include "cobalt/h5vcc/dial/dial_server.h"
#include "cobalt/h5vcc/dial/v8c_dial_http_request.h"
#include "cobalt/h5vcc/dial/v8c_dial_http_response.h"
#include "cobalt/h5vcc/dial/v8c_dial_server.h"
#include "cobalt/h5vcc/h5vcc.h"
#include "cobalt/h5vcc/h5vcc_accessibility.h"
#include "cobalt/h5vcc/h5vcc_account_info.h"
#include "cobalt/h5vcc/h5vcc_account_manager.h"
#include "cobalt/h5vcc/h5vcc_audio_config.h"
#include "cobalt/h5vcc/h5vcc_audio_config_array.h"
#include "cobalt/h5vcc/h5vcc_crash_log.h"
#include "cobalt/h5vcc/h5vcc_deep_link_event_target.h"
#include "cobalt/h5vcc/h5vcc_platform_service.h"
#include "cobalt/h5vcc/h5vcc_runtime.h"
#include "cobalt/h5vcc/h5vcc_runtime_event_target.h"
#include "cobalt/h5vcc/h5vcc_settings.h"
#include "cobalt/h5vcc/h5vcc_sso.h"
#include "cobalt/h5vcc/h5vcc_storage.h"
#include "cobalt/h5vcc/h5vcc_system.h"
#include "cobalt/h5vcc/h5vcc_trace_event.h"
#include "cobalt/h5vcc/v8c_h5vcc.h"
#include "cobalt/h5vcc/v8c_h5vcc_accessibility.h"
#include "cobalt/h5vcc/v8c_h5vcc_account_info.h"
#include "cobalt/h5vcc/v8c_h5vcc_account_manager.h"
#include "cobalt/h5vcc/v8c_h5vcc_audio_config.h"
#include "cobalt/h5vcc/v8c_h5vcc_audio_config_array.h"
#include "cobalt/h5vcc/v8c_h5vcc_crash_log.h"
#include "cobalt/h5vcc/v8c_h5vcc_deep_link_event_target.h"
#include "cobalt/h5vcc/v8c_h5vcc_platform_service.h"
#include "cobalt/h5vcc/v8c_h5vcc_runtime.h"
#include "cobalt/h5vcc/v8c_h5vcc_runtime_event_target.h"
#include "cobalt/h5vcc/v8c_h5vcc_settings.h"
#include "cobalt/h5vcc/v8c_h5vcc_sso.h"
#include "cobalt/h5vcc/v8c_h5vcc_storage.h"
#include "cobalt/h5vcc/v8c_h5vcc_system.h"
#include "cobalt/h5vcc/v8c_h5vcc_trace_event.h"
#include "cobalt/media_capture/blob_event.h"
#include "cobalt/media_capture/media_device_info.h"
#include "cobalt/media_capture/media_devices.h"
#include "cobalt/media_capture/media_recorder.h"
#include "cobalt/media_capture/v8c_blob_event.h"
#include "cobalt/media_capture/v8c_media_device_info.h"
#include "cobalt/media_capture/v8c_media_devices.h"
#include "cobalt/media_capture/v8c_media_recorder.h"
#include "cobalt/media_session/media_metadata.h"
#include "cobalt/media_session/media_session.h"
#include "cobalt/media_session/media_session_action_details.h"
#include "cobalt/media_session/v8c_media_metadata.h"
#include "cobalt/media_session/v8c_media_session.h"
#include "cobalt/media_session/v8c_media_session_action_details.h"
#include "cobalt/media_stream/media_stream.h"
#include "cobalt/media_stream/media_stream_track.h"
#include "cobalt/media_stream/v8c_media_stream.h"
#include "cobalt/media_stream/v8c_media_stream_track.h"
#include "cobalt/speech/speech_recognition.h"
#include "cobalt/speech/speech_recognition_alternative.h"
#include "cobalt/speech/speech_recognition_error.h"
#include "cobalt/speech/speech_recognition_event.h"
#include "cobalt/speech/speech_recognition_result.h"
#include "cobalt/speech/speech_recognition_result_list.h"
#include "cobalt/speech/speech_synthesis.h"
#include "cobalt/speech/speech_synthesis_error_event.h"
#include "cobalt/speech/speech_synthesis_event.h"
#include "cobalt/speech/speech_synthesis_utterance.h"
#include "cobalt/speech/speech_synthesis_voice.h"
#include "cobalt/speech/v8c_speech_recognition.h"
#include "cobalt/speech/v8c_speech_recognition_alternative.h"
#include "cobalt/speech/v8c_speech_recognition_error.h"
#include "cobalt/speech/v8c_speech_recognition_event.h"
#include "cobalt/speech/v8c_speech_recognition_result.h"
#include "cobalt/speech/v8c_speech_recognition_result_list.h"
#include "cobalt/speech/v8c_speech_synthesis.h"
#include "cobalt/speech/v8c_speech_synthesis_error_event.h"
#include "cobalt/speech/v8c_speech_synthesis_event.h"
#include "cobalt/speech/v8c_speech_synthesis_utterance.h"
#include "cobalt/speech/v8c_speech_synthesis_voice.h"
#include "cobalt/web_animations/animatable.h"
#include "cobalt/web_animations/animation.h"
#include "cobalt/web_animations/animation_effect_read_only.h"
#include "cobalt/web_animations/animation_effect_timing_read_only.h"
#include "cobalt/web_animations/animation_timeline.h"
#include "cobalt/web_animations/keyframe.h"
#include "cobalt/web_animations/keyframe_effect_read_only.h"
#include "cobalt/web_animations/v8c_animatable.h"
#include "cobalt/web_animations/v8c_animation.h"
#include "cobalt/web_animations/v8c_animation_effect_read_only.h"
#include "cobalt/web_animations/v8c_animation_effect_timing_read_only.h"
#include "cobalt/web_animations/v8c_animation_timeline.h"
#include "cobalt/web_animations/v8c_keyframe.h"
#include "cobalt/web_animations/v8c_keyframe_effect_read_only.h"
#include "cobalt/webdriver/script_executor.h"
#include "cobalt/webdriver/script_executor_params.h"
#include "cobalt/webdriver/script_executor_result.h"
#include "cobalt/webdriver/v8c_script_executor.h"
#include "cobalt/webdriver/v8c_script_executor_params.h"
#include "cobalt/webdriver/v8c_script_executor_result.h"
#include "cobalt/websocket/close_event.h"
#include "cobalt/websocket/v8c_close_event.h"
#include "cobalt/websocket/v8c_web_socket.h"
#include "cobalt/websocket/web_socket.h"
#include "cobalt/xhr/v8c_xml_http_request.h"
#include "cobalt/xhr/v8c_xml_http_request_event_target.h"
#include "cobalt/xhr/v8c_xml_http_request_upload.h"
#include "cobalt/xhr/xml_http_request.h"
#include "cobalt/xhr/xml_http_request_event_target.h"
#include "cobalt/xhr/xml_http_request_upload.h"

#include "v8c_gen_type_conversion.h"

#include "cobalt/script/callback_interface_traits.h"
#include "cobalt/script/v8c/v8c_array_buffer.h"
#include "cobalt/script/v8c/v8c_array_buffer_view.h"
#include "cobalt/script/v8c/callback_function_conversion.h"
#include "cobalt/script/v8c/conversion_helpers.h"
#include "cobalt/script/v8c/entry_scope.h"
#include "cobalt/script/v8c/helpers.h"
#include "cobalt/script/v8c/native_promise.h"
#include "cobalt/script/v8c/type_traits.h"
#include "cobalt/script/v8c/v8c_typed_arrays.h"
#include "cobalt/script/v8c/v8c_data_view.h"
#include "cobalt/script/v8c/v8c_callback_function.h"
#include "cobalt/script/v8c/v8c_callback_interface_holder.h"
#include "cobalt/script/v8c/v8c_engine.h"
#include "cobalt/script/v8c/v8c_exception_state.h"
#include "cobalt/script/v8c/v8c_global_environment.h"
#include "cobalt/script/v8c/v8c_property_enumerator.h"
#include "cobalt/script/v8c/v8c_value_handle.h"
#include "cobalt/script/v8c/wrapper_private.h"
#include "v8/include/v8.h"


namespace {
using cobalt::dom::Window;
using cobalt::dom::V8cWindow;
using cobalt::audio::AudioBuffer;
using cobalt::audio::AudioBufferSourceNode;
using cobalt::audio::AudioContext;
using cobalt::audio::AudioDestinationNode;
using cobalt::audio::AudioNode;
using cobalt::audio::V8cAudioBuffer;
using cobalt::audio::V8cAudioBufferSourceNode;
using cobalt::audio::V8cAudioContext;
using cobalt::audio::V8cAudioDestinationNode;
using cobalt::audio::V8cAudioNode;
using cobalt::cssom::CSS;
using cobalt::cssom::CSSConditionRule;
using cobalt::cssom::CSSFontFaceRule;
using cobalt::cssom::CSSGroupingRule;
using cobalt::cssom::CSSKeyframeRule;
using cobalt::cssom::CSSKeyframesRule;
using cobalt::cssom::CSSMediaRule;
using cobalt::cssom::CSSRule;
using cobalt::cssom::CSSRuleList;
using cobalt::cssom::CSSStyleDeclaration;
using cobalt::cssom::CSSStyleRule;
using cobalt::cssom::CSSStyleSheet;
using cobalt::cssom::MediaList;
using cobalt::cssom::StyleSheet;
using cobalt::cssom::StyleSheetList;
using cobalt::cssom::V8cCSS;
using cobalt::cssom::V8cCSSConditionRule;
using cobalt::cssom::V8cCSSFontFaceRule;
using cobalt::cssom::V8cCSSGroupingRule;
using cobalt::cssom::V8cCSSKeyframeRule;
using cobalt::cssom::V8cCSSKeyframesRule;
using cobalt::cssom::V8cCSSMediaRule;
using cobalt::cssom::V8cCSSRule;
using cobalt::cssom::V8cCSSRuleList;
using cobalt::cssom::V8cCSSStyleDeclaration;
using cobalt::cssom::V8cCSSStyleRule;
using cobalt::cssom::V8cCSSStyleSheet;
using cobalt::cssom::V8cMediaList;
using cobalt::cssom::V8cStyleSheet;
using cobalt::cssom::V8cStyleSheetList;
#if defined(ENABLE_DEBUGGER)
using cobalt::debug::backend::CSSAgent;
#endif  // defined(ENABLE_DEBUGGER)
#if defined(ENABLE_DEBUGGER)
using cobalt::debug::backend::DebugBackend;
#endif  // defined(ENABLE_DEBUGGER)
#if defined(ENABLE_DEBUGGER)
using cobalt::debug::backend::V8cCSSAgent;
#endif  // defined(ENABLE_DEBUGGER)
#if defined(ENABLE_DEBUGGER)
using cobalt::debug::backend::V8cDebugBackend;
#endif  // defined(ENABLE_DEBUGGER)
#if defined(ENABLE_DEBUGGER)
using cobalt::debug::console::DebugHub;
#endif  // defined(ENABLE_DEBUGGER)
#if defined(ENABLE_DEBUGGER)
using cobalt::debug::console::DebuggerEventTarget;
#endif  // defined(ENABLE_DEBUGGER)
#if defined(ENABLE_DEBUGGER)
using cobalt::debug::console::V8cDebugHub;
#endif  // defined(ENABLE_DEBUGGER)
#if defined(ENABLE_DEBUGGER)
using cobalt::debug::console::V8cDebuggerEventTarget;
#endif  // defined(ENABLE_DEBUGGER)
using cobalt::dom::AnimationEvent;
using cobalt::dom::Attr;
using cobalt::dom::AudioTrack;
using cobalt::dom::AudioTrackList;
using cobalt::dom::Blob;
using cobalt::dom::CDATASection;
using cobalt::dom::CValKeyList;
using cobalt::dom::CValView;
using cobalt::dom::Camera3D;
using cobalt::dom::CharacterData;
using cobalt::dom::Comment;
using cobalt::dom::Console;
using cobalt::dom::Crypto;
using cobalt::dom::CustomEvent;
using cobalt::dom::DOMException;
using cobalt::dom::DOMImplementation;
using cobalt::dom::DOMParser;
using cobalt::dom::DOMRect;
using cobalt::dom::DOMRectList;
using cobalt::dom::DOMRectReadOnly;
using cobalt::dom::DOMStringMap;
using cobalt::dom::DOMTokenList;
using cobalt::dom::DeviceOrientationEvent;
using cobalt::dom::Document;
using cobalt::dom::DocumentTimeline;
using cobalt::dom::DocumentType;
using cobalt::dom::Element;
using cobalt::dom::ErrorEvent;
using cobalt::dom::Event;
using cobalt::dom::EventListener;
using cobalt::dom::EventTarget;
using cobalt::dom::FocusEvent;
using cobalt::dom::HTMLAnchorElement;
using cobalt::dom::HTMLBRElement;
using cobalt::dom::HTMLBodyElement;
using cobalt::dom::HTMLCollection;
using cobalt::dom::HTMLDivElement;
using cobalt::dom::HTMLElement;
using cobalt::dom::HTMLHeadElement;
using cobalt::dom::HTMLHeadingElement;
using cobalt::dom::HTMLHtmlElement;
using cobalt::dom::HTMLImageElement;
using cobalt::dom::HTMLLinkElement;
using cobalt::dom::HTMLMediaElement;
using cobalt::dom::HTMLMetaElement;
using cobalt::dom::HTMLParagraphElement;
using cobalt::dom::HTMLScriptElement;
using cobalt::dom::HTMLSpanElement;
using cobalt::dom::HTMLStyleElement;
using cobalt::dom::HTMLTitleElement;
using cobalt::dom::HTMLUnknownElement;
using cobalt::dom::HTMLVideoElement;
using cobalt::dom::History;
using cobalt::dom::InputEvent;
using cobalt::dom::KeyboardEvent;
using cobalt::dom::Location;
using cobalt::dom::MediaError;
using cobalt::dom::MediaQueryList;
using cobalt::dom::MediaSource;
using cobalt::dom::MemoryInfo;
using cobalt::dom::MessageEvent;
using cobalt::dom::MimeTypeArray;
using cobalt::dom::MouseEvent;
using cobalt::dom::MutationObserver;
using cobalt::dom::MutationRecord;
using cobalt::dom::NamedNodeMap;
using cobalt::dom::Navigator;
using cobalt::dom::Node;
using cobalt::dom::NodeList;
using cobalt::dom::OnErrorEventListener;
#if defined(COBALT_ENABLE_ON_SCREEN_KEYBOARD)
using cobalt::dom::OnScreenKeyboard;
#endif  // defined(COBALT_ENABLE_ON_SCREEN_KEYBOARD)
using cobalt::dom::Performance;
using cobalt::dom::PerformanceTiming;
using cobalt::dom::PluginArray;
using cobalt::dom::PointerEvent;
using cobalt::dom::ProgressEvent;
using cobalt::dom::Screen;
using cobalt::dom::Screenshot;
using cobalt::dom::SecurityPolicyViolationEvent;
using cobalt::dom::SourceBuffer;
using cobalt::dom::SourceBufferList;
using cobalt::dom::Storage;
using cobalt::dom::StorageEvent;
#if defined(ENABLE_TEST_RUNNER)
using cobalt::dom::TestRunner;
#endif  // defined(ENABLE_TEST_RUNNER)
using cobalt::dom::Text;
using cobalt::dom::TimeRanges;
using cobalt::dom::TrackDefault;
using cobalt::dom::TrackDefaultList;
using cobalt::dom::TrackEvent;
using cobalt::dom::TransitionEvent;
using cobalt::dom::UIEvent;
using cobalt::dom::URL;
using cobalt::dom::V8cAnimationEvent;
using cobalt::dom::V8cAttr;
using cobalt::dom::V8cAudioTrack;
using cobalt::dom::V8cAudioTrackList;
using cobalt::dom::V8cBlob;
using cobalt::dom::V8cCDATASection;
using cobalt::dom::V8cCValKeyList;
using cobalt::dom::V8cCValView;
using cobalt::dom::V8cCamera3D;
using cobalt::dom::V8cCharacterData;
using cobalt::dom::V8cComment;
using cobalt::dom::V8cConsole;
using cobalt::dom::V8cCrypto;
using cobalt::dom::V8cCustomEvent;
using cobalt::dom::V8cDOMException;
using cobalt::dom::V8cDOMImplementation;
using cobalt::dom::V8cDOMParser;
using cobalt::dom::V8cDOMRect;
using cobalt::dom::V8cDOMRectList;
using cobalt::dom::V8cDOMRectReadOnly;
using cobalt::dom::V8cDOMStringMap;
using cobalt::dom::V8cDOMTokenList;
using cobalt::dom::V8cDeviceOrientationEvent;
using cobalt::dom::V8cDocument;
using cobalt::dom::V8cDocumentTimeline;
using cobalt::dom::V8cDocumentType;
using cobalt::dom::V8cElement;
using cobalt::dom::V8cErrorEvent;
using cobalt::dom::V8cEvent;
using cobalt::dom::V8cEventListener;
using cobalt::dom::V8cEventTarget;
using cobalt::dom::V8cFocusEvent;
using cobalt::dom::V8cHTMLAnchorElement;
using cobalt::dom::V8cHTMLBRElement;
using cobalt::dom::V8cHTMLBodyElement;
using cobalt::dom::V8cHTMLCollection;
using cobalt::dom::V8cHTMLDivElement;
using cobalt::dom::V8cHTMLElement;
using cobalt::dom::V8cHTMLHeadElement;
using cobalt::dom::V8cHTMLHeadingElement;
using cobalt::dom::V8cHTMLHtmlElement;
using cobalt::dom::V8cHTMLImageElement;
using cobalt::dom::V8cHTMLLinkElement;
using cobalt::dom::V8cHTMLMediaElement;
using cobalt::dom::V8cHTMLMetaElement;
using cobalt::dom::V8cHTMLParagraphElement;
using cobalt::dom::V8cHTMLScriptElement;
using cobalt::dom::V8cHTMLSpanElement;
using cobalt::dom::V8cHTMLStyleElement;
using cobalt::dom::V8cHTMLTitleElement;
using cobalt::dom::V8cHTMLUnknownElement;
using cobalt::dom::V8cHTMLVideoElement;
using cobalt::dom::V8cHistory;
using cobalt::dom::V8cInputEvent;
using cobalt::dom::V8cKeyboardEvent;
using cobalt::dom::V8cLocation;
using cobalt::dom::V8cMediaError;
using cobalt::dom::V8cMediaQueryList;
using cobalt::dom::V8cMediaSource;
using cobalt::dom::V8cMemoryInfo;
using cobalt::dom::V8cMessageEvent;
using cobalt::dom::V8cMimeTypeArray;
using cobalt::dom::V8cMouseEvent;
using cobalt::dom::V8cMutationObserver;
using cobalt::dom::V8cMutationRecord;
using cobalt::dom::V8cNamedNodeMap;
using cobalt::dom::V8cNavigator;
using cobalt::dom::V8cNode;
using cobalt::dom::V8cNodeList;
using cobalt::dom::V8cOnErrorEventListener;
#if defined(COBALT_ENABLE_ON_SCREEN_KEYBOARD)
using cobalt::dom::V8cOnScreenKeyboard;
#endif  // defined(COBALT_ENABLE_ON_SCREEN_KEYBOARD)
using cobalt::dom::V8cPerformance;
using cobalt::dom::V8cPerformanceTiming;
using cobalt::dom::V8cPluginArray;
using cobalt::dom::V8cPointerEvent;
using cobalt::dom::V8cProgressEvent;
using cobalt::dom::V8cScreen;
using cobalt::dom::V8cScreenshot;
using cobalt::dom::V8cSecurityPolicyViolationEvent;
using cobalt::dom::V8cSourceBuffer;
using cobalt::dom::V8cSourceBufferList;
using cobalt::dom::V8cStorage;
using cobalt::dom::V8cStorageEvent;
#if defined(ENABLE_TEST_RUNNER)
using cobalt::dom::V8cTestRunner;
#endif  // defined(ENABLE_TEST_RUNNER)
using cobalt::dom::V8cText;
using cobalt::dom::V8cTimeRanges;
using cobalt::dom::V8cTrackDefault;
using cobalt::dom::V8cTrackDefaultList;
using cobalt::dom::V8cTrackEvent;
using cobalt::dom::V8cTransitionEvent;
using cobalt::dom::V8cUIEvent;
using cobalt::dom::V8cURL;
using cobalt::dom::V8cVideoPlaybackQuality;
using cobalt::dom::V8cVideoTrack;
using cobalt::dom::V8cVideoTrackList;
using cobalt::dom::V8cWheelEvent;
using cobalt::dom::V8cWindow;
using cobalt::dom::V8cXMLDocument;
using cobalt::dom::V8cXMLSerializer;
using cobalt::dom::VideoPlaybackQuality;
using cobalt::dom::VideoTrack;
using cobalt::dom::VideoTrackList;
using cobalt::dom::WheelEvent;
using cobalt::dom::Window;
using cobalt::dom::XMLDocument;
using cobalt::dom::XMLSerializer;
using cobalt::dom::captions::SystemCaptionSettings;
using cobalt::dom::captions::V8cSystemCaptionSettings;
using cobalt::dom::eme::MediaEncryptedEvent;
using cobalt::dom::eme::MediaKeyMessageEvent;
using cobalt::dom::eme::MediaKeySession;
using cobalt::dom::eme::MediaKeyStatusMap;
using cobalt::dom::eme::MediaKeySystemAccess;
using cobalt::dom::eme::MediaKeys;
using cobalt::dom::eme::V8cMediaEncryptedEvent;
using cobalt::dom::eme::V8cMediaKeyMessageEvent;
using cobalt::dom::eme::V8cMediaKeySession;
using cobalt::dom::eme::V8cMediaKeyStatusMap;
using cobalt::dom::eme::V8cMediaKeySystemAccess;
using cobalt::dom::eme::V8cMediaKeys;
using cobalt::fetch::FetchInternal;
using cobalt::fetch::V8cFetchInternal;
using cobalt::h5vcc::H5vcc;
using cobalt::h5vcc::H5vccAccessibility;
using cobalt::h5vcc::H5vccAccountInfo;
#if defined(COBALT_ENABLE_ACCOUNT_MANAGER)
using cobalt::h5vcc::H5vccAccountManager;
#endif  // defined(COBALT_ENABLE_ACCOUNT_MANAGER)
using cobalt::h5vcc::H5vccAudioConfig;
using cobalt::h5vcc::H5vccAudioConfigArray;
#if defined(COBALT_ENABLE_CRASH_LOG)
using cobalt::h5vcc::H5vccCrashLog;
#endif  // defined(COBALT_ENABLE_CRASH_LOG)
using cobalt::h5vcc::H5vccDeepLinkEventTarget;
using cobalt::h5vcc::H5vccPlatformService;
using cobalt::h5vcc::H5vccRuntime;
using cobalt::h5vcc::H5vccRuntimeEventTarget;
using cobalt::h5vcc::H5vccSettings;
#if defined(COBALT_ENABLE_SSO)
using cobalt::h5vcc::H5vccSso;
#endif  // defined(COBALT_ENABLE_SSO)
using cobalt::h5vcc::H5vccStorage;
using cobalt::h5vcc::H5vccSystem;
using cobalt::h5vcc::H5vccTraceEvent;
using cobalt::h5vcc::V8cH5vcc;
using cobalt::h5vcc::V8cH5vccAccessibility;
using cobalt::h5vcc::V8cH5vccAccountInfo;
#if defined(COBALT_ENABLE_ACCOUNT_MANAGER)
using cobalt::h5vcc::V8cH5vccAccountManager;
#endif  // defined(COBALT_ENABLE_ACCOUNT_MANAGER)
using cobalt::h5vcc::V8cH5vccAudioConfig;
using cobalt::h5vcc::V8cH5vccAudioConfigArray;
#if defined(COBALT_ENABLE_CRASH_LOG)
using cobalt::h5vcc::V8cH5vccCrashLog;
#endif  // defined(COBALT_ENABLE_CRASH_LOG)
using cobalt::h5vcc::V8cH5vccDeepLinkEventTarget;
using cobalt::h5vcc::V8cH5vccPlatformService;
using cobalt::h5vcc::V8cH5vccRuntime;
using cobalt::h5vcc::V8cH5vccRuntimeEventTarget;
using cobalt::h5vcc::V8cH5vccSettings;
#if defined(COBALT_ENABLE_SSO)
using cobalt::h5vcc::V8cH5vccSso;
#endif  // defined(COBALT_ENABLE_SSO)
using cobalt::h5vcc::V8cH5vccStorage;
using cobalt::h5vcc::V8cH5vccSystem;
using cobalt::h5vcc::V8cH5vccTraceEvent;
#if defined(DIAL_SERVER)
using cobalt::h5vcc::dial::DialHttpRequest;
#endif  // defined(DIAL_SERVER)
#if defined(DIAL_SERVER)
using cobalt::h5vcc::dial::DialHttpResponse;
#endif  // defined(DIAL_SERVER)
#if defined(DIAL_SERVER)
using cobalt::h5vcc::dial::DialServer;
#endif  // defined(DIAL_SERVER)
#if defined(DIAL_SERVER)
using cobalt::h5vcc::dial::V8cDialHttpRequest;
#endif  // defined(DIAL_SERVER)
#if defined(DIAL_SERVER)
using cobalt::h5vcc::dial::V8cDialHttpResponse;
#endif  // defined(DIAL_SERVER)
#if defined(DIAL_SERVER)
using cobalt::h5vcc::dial::V8cDialServer;
#endif  // defined(DIAL_SERVER)
using cobalt::media_capture::BlobEvent;
using cobalt::media_capture::MediaDeviceInfo;
using cobalt::media_capture::MediaDevices;
using cobalt::media_capture::MediaRecorder;
using cobalt::media_capture::V8cBlobEvent;
using cobalt::media_capture::V8cMediaDeviceInfo;
using cobalt::media_capture::V8cMediaDevices;
using cobalt::media_capture::V8cMediaRecorder;
using cobalt::media_session::MediaMetadata;
using cobalt::media_session::MediaSession;
using cobalt::media_session::MediaSessionActionDetails;
using cobalt::media_session::V8cMediaMetadata;
using cobalt::media_session::V8cMediaSession;
using cobalt::media_session::V8cMediaSessionActionDetails;
using cobalt::media_stream::MediaStream;
using cobalt::media_stream::MediaStreamTrack;
using cobalt::media_stream::V8cMediaStream;
using cobalt::media_stream::V8cMediaStreamTrack;
using cobalt::speech::SpeechRecognition;
using cobalt::speech::SpeechRecognitionAlternative;
using cobalt::speech::SpeechRecognitionError;
using cobalt::speech::SpeechRecognitionEvent;
using cobalt::speech::SpeechRecognitionResult;
using cobalt::speech::SpeechRecognitionResultList;
using cobalt::speech::SpeechSynthesis;
using cobalt::speech::SpeechSynthesisErrorEvent;
using cobalt::speech::SpeechSynthesisEvent;
using cobalt::speech::SpeechSynthesisUtterance;
using cobalt::speech::SpeechSynthesisVoice;
using cobalt::speech::V8cSpeechRecognition;
using cobalt::speech::V8cSpeechRecognitionAlternative;
using cobalt::speech::V8cSpeechRecognitionError;
using cobalt::speech::V8cSpeechRecognitionEvent;
using cobalt::speech::V8cSpeechRecognitionResult;
using cobalt::speech::V8cSpeechRecognitionResultList;
using cobalt::speech::V8cSpeechSynthesis;
using cobalt::speech::V8cSpeechSynthesisErrorEvent;
using cobalt::speech::V8cSpeechSynthesisEvent;
using cobalt::speech::V8cSpeechSynthesisUtterance;
using cobalt::speech::V8cSpeechSynthesisVoice;
using cobalt::web_animations::Animatable;
using cobalt::web_animations::Animation;
using cobalt::web_animations::AnimationEffectReadOnly;
using cobalt::web_animations::AnimationEffectTimingReadOnly;
using cobalt::web_animations::AnimationTimeline;
using cobalt::web_animations::Keyframe;
using cobalt::web_animations::KeyframeEffectReadOnly;
using cobalt::web_animations::V8cAnimatable;
using cobalt::web_animations::V8cAnimation;
using cobalt::web_animations::V8cAnimationEffectReadOnly;
using cobalt::web_animations::V8cAnimationEffectTimingReadOnly;
using cobalt::web_animations::V8cAnimationTimeline;
using cobalt::web_animations::V8cKeyframe;
using cobalt::web_animations::V8cKeyframeEffectReadOnly;
#if defined(ENABLE_WEBDRIVER)
using cobalt::webdriver::ScriptExecutor;
#endif  // defined(ENABLE_WEBDRIVER)
#if defined(ENABLE_WEBDRIVER)
using cobalt::webdriver::ScriptExecutorParams;
#endif  // defined(ENABLE_WEBDRIVER)
#if defined(ENABLE_WEBDRIVER)
using cobalt::webdriver::ScriptExecutorResult;
#endif  // defined(ENABLE_WEBDRIVER)
#if defined(ENABLE_WEBDRIVER)
using cobalt::webdriver::V8cScriptExecutor;
#endif  // defined(ENABLE_WEBDRIVER)
#if defined(ENABLE_WEBDRIVER)
using cobalt::webdriver::V8cScriptExecutorParams;
#endif  // defined(ENABLE_WEBDRIVER)
#if defined(ENABLE_WEBDRIVER)
using cobalt::webdriver::V8cScriptExecutorResult;
#endif  // defined(ENABLE_WEBDRIVER)
using cobalt::websocket::CloseEvent;
using cobalt::websocket::V8cCloseEvent;
using cobalt::websocket::V8cWebSocket;
using cobalt::websocket::WebSocket;
using cobalt::xhr::V8cXMLHttpRequest;
using cobalt::xhr::V8cXMLHttpRequestEventTarget;
using cobalt::xhr::V8cXMLHttpRequestUpload;
using cobalt::xhr::XMLHttpRequest;
using cobalt::xhr::XMLHttpRequestEventTarget;
using cobalt::xhr::XMLHttpRequestUpload;
using cobalt::script::CallbackInterfaceTraits;
using cobalt::script::GlobalEnvironment;
using cobalt::script::ScriptValue;
using cobalt::script::ValueHandle;
using cobalt::script::ValueHandle;
using cobalt::script::ValueHandleHolder;
using cobalt::script::Wrappable;

using cobalt::script::v8c::EntryScope;
using cobalt::script::v8c::EscapableEntryScope;
using cobalt::script::v8c::FromJSValue;
using cobalt::script::v8c::kConversionFlagClamped;
using cobalt::script::v8c::kConversionFlagNullable;
using cobalt::script::v8c::kConversionFlagObjectOnly;
using cobalt::script::v8c::kConversionFlagRestricted;
using cobalt::script::v8c::kConversionFlagTreatNullAsEmptyString;
using cobalt::script::v8c::kConversionFlagTreatUndefinedAsEmptyString;
using cobalt::script::v8c::kNoConversionFlags;
using cobalt::script::v8c::NewInternalString;
using cobalt::script::v8c::ToJSValue;
using cobalt::script::v8c::TypeTraits;
using cobalt::script::v8c::V8cExceptionState;
using cobalt::script::v8c::V8cGlobalEnvironment;
using cobalt::script::v8c::V8cPropertyEnumerator;
using cobalt::script::v8c::WrapperFactory;
using cobalt::script::v8c::WrapperPrivate;
}  // namespace

namespace cobalt {
namespace dom {


namespace {

const int kInterfaceUniqueId = 221;





void IndexedPropertyGetterCallback(
    uint32_t index,
    const v8::PropertyCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  if (index >= impl->length()) {
    // |index| is out of bounds, so return undefined.
    return;
  }

  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->AnonymousIndexedGetter(index),
              &result_value);
  }
  info.GetReturnValue().Set(result_value);
}

void IndexedPropertyDescriptorCallback(
    uint32_t index, const v8::PropertyCallbackInfo<v8::Value>& info) {
  // TODO: Figure out under what conditions this gets called.  It's not
  // getting called in our tests.
  NOTIMPLEMENTED();
}

void IndexedPropertyEnumeratorCallback(
    const v8::PropertyCallbackInfo<v8::Array>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  const uint32_t length = impl->length();
  v8::Local<v8::Array> array = v8::Array::New(isolate, length);
  for (uint32_t i = 0; i < length; ++i) {
    array->Set(i, v8::Integer::New(isolate, i));
  }
  info.GetReturnValue().Set(array);
}

void IndexedPropertyDefinerCallback(
    uint32_t index, const v8::PropertyDescriptor& desc,
    const v8::PropertyCallbackInfo<v8::Value>& info) {
  // TODO: Figure out under what conditions this gets called.  It's not
  // getting called in our tests.
  NOTIMPLEMENTED();
}





void DummyConstructor(const v8::FunctionCallbackInfo<v8::Value>& info) {
  V8cExceptionState exception(info.GetIsolate());
  exception.SetSimpleException(
      script::kTypeError, "Window is not constructible.");
}



void windowAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->window(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void selfAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->self(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void documentAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->document(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void locationAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->location(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void locationAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  { // Begin scope of scoped_refptr<Location> forwarded_impl.
    scoped_refptr<Location> forwarded_impl =
       impl->location();
    if (!forwarded_impl) {
      NOTREACHED();
      return;
    }
    if (!exception_state.is_exception_set()) {
  TypeTraits<std::string >::ConversionType value;
  FromJSValue(isolate, v8_value, kNoConversionFlags, &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  forwarded_impl->set_href(value);
  result_value = v8::Undefined(isolate);
  return;
}
    return;
  } // End scope of scoped_refptr<Location> forwarded_impl.
}


void historyAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->history(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void framesAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->frames(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void lengthAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->length(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void topAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->top(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void openerAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->opener(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void parentAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->parent(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void navigatorAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->navigator(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void consoleAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->console(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void camera3DAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->camera_3d(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}


#if defined(ENABLE_TEST_RUNNER)

void testRunnerAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->test_runner(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}


#endif  // ENABLE_TEST_RUNNER

void cryptoAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->crypto(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void onblurAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onblur(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onblurAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onblur(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onclickAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onclick(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onclickAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onclick(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onerrorAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onerror(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onerrorAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<OnErrorEventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onerror(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onfocusAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onfocus(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onfocusAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onfocus(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onkeydownAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onkeydown(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onkeydownAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onkeydown(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onkeypressAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onkeypress(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onkeypressAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onkeypress(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onkeyupAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onkeyup(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onkeyupAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onkeyup(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onloadAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onload(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onloadAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onload(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onloadeddataAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onloadeddata(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onloadeddataAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onloadeddata(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onloadedmetadataAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onloadedmetadata(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onloadedmetadataAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onloadedmetadata(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onloadstartAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onloadstart(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onloadstartAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onloadstart(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onmousedownAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onmousedown(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onmousedownAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onmousedown(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onmouseenterAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onmouseenter(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onmouseenterAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onmouseenter(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onmouseleaveAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onmouseleave(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onmouseleaveAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onmouseleave(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onmousemoveAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onmousemove(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onmousemoveAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onmousemove(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onmouseoutAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onmouseout(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onmouseoutAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onmouseout(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onmouseoverAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onmouseover(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onmouseoverAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onmouseover(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onmouseupAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onmouseup(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onmouseupAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onmouseup(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onpauseAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onpause(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onpauseAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onpause(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onplayAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onplay(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onplayAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onplay(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onplayingAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onplaying(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onplayingAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onplaying(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onresizeAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onresize(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onresizeAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onresize(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onscrollAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onscroll(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onscrollAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onscroll(value);
  result_value = v8::Undefined(isolate);
  return;
}


void ontransitionendAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->ontransitionend(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void ontransitionendAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_ontransitionend(value);
  result_value = v8::Undefined(isolate);
  return;
}


void ongotpointercaptureAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->ongotpointercapture(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void ongotpointercaptureAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_ongotpointercapture(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onlostpointercaptureAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onlostpointercapture(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onlostpointercaptureAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onlostpointercapture(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onpointerdownAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onpointerdown(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onpointerdownAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onpointerdown(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onpointerenterAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onpointerenter(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onpointerenterAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onpointerenter(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onpointerleaveAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onpointerleave(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onpointerleaveAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onpointerleave(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onpointermoveAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onpointermove(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onpointermoveAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onpointermove(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onpointeroutAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onpointerout(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onpointeroutAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onpointerout(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onpointeroverAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onpointerover(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onpointeroverAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onpointerover(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onpointerupAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onpointerup(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onpointerupAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onpointerup(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onprogressAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onprogress(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onprogressAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onprogress(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onratechangeAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onratechange(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onratechangeAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onratechange(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onseekedAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onseeked(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onseekedAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onseeked(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onseekingAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onseeking(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onseekingAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onseeking(value);
  result_value = v8::Undefined(isolate);
  return;
}


void ontimeupdateAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->ontimeupdate(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void ontimeupdateAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_ontimeupdate(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onvolumechangeAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onvolumechange(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onvolumechangeAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onvolumechange(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onwaitingAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onwaiting(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onwaitingAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onwaiting(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onwheelAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onwheel(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onwheelAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onwheel(value);
  result_value = v8::Undefined(isolate);
  return;
}


void speechSynthesisAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->speech_synthesis(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void performanceAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->performance(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void screenAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->screen(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void innerWidthAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->inner_width(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void innerHeightAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->inner_height(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void screenXAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->screen_x(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void screenYAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->screen_y(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void outerWidthAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->outer_width(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void outerHeightAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->outer_height(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void devicePixelRatioAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->device_pixel_ratio(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}



void onunloadAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onunload(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onunloadAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onunload(value);
  result_value = v8::Undefined(isolate);
  return;
}


void onbeforeunloadAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->onbeforeunload(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}

void onbeforeunloadAttributeSetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  v8::Local<v8::Value> v8_value = info[0];

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  TypeTraits<::cobalt::script::CallbackInterfaceTraits<EventListener > >::ConversionType value;
  FromJSValue(isolate, v8_value, (kConversionFlagNullable), &exception_state,
              &value);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->set_onbeforeunload(value);
  result_value = v8::Undefined(isolate);
  return;
}


void localStorageAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->local_storage(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}


#if defined(COBALT_ENABLE_ON_SCREEN_KEYBOARD)

void onScreenKeyboardAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->on_screen_keyboard(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}


#endif  // COBALT_ENABLE_ON_SCREEN_KEYBOARD

void sessionStorageAttributeGetter(
    const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();


  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();


  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->session_storage(),
              &result_value);
  }
  if (exception_state.is_exception_set()) {
    return;
  }
  info.GetReturnValue().Set(result_value);
}


#if defined(COBALT_ENABLE_ACCOUNT_MANAGER)

// Nothing for {'getter_function_name': 'h5vcc_account_manager', 'conditional': 'COBALT_ENABLE_ACCOUNT_MANAGER', 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccAccountManager', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_account_manager', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccAccountManager', 'type': 'scoped_refptr<H5vccAccountManager>'}.  We will just give them the v8::FunctionTemplate.
#endif  // COBALT_ENABLE_ACCOUNT_MANAGER
#if defined(COBALT_ENABLE_CRASH_LOG)

// Nothing for {'getter_function_name': 'h5vcc_crash_log', 'conditional': 'COBALT_ENABLE_CRASH_LOG', 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccCrashLog', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_crash_log', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccCrashLog', 'type': 'scoped_refptr<H5vccCrashLog>'}.  We will just give them the v8::FunctionTemplate.
#endif  // COBALT_ENABLE_CRASH_LOG
#if defined(COBALT_ENABLE_ON_SCREEN_KEYBOARD)

// Nothing for {'getter_function_name': 'on_screen_keyboard', 'conditional': 'COBALT_ENABLE_ON_SCREEN_KEYBOARD', 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'OnScreenKeyboard', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_on_screen_keyboard', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'OnScreenKeyboard', 'type': 'scoped_refptr<OnScreenKeyboard>'}.  We will just give them the v8::FunctionTemplate.
#endif  // COBALT_ENABLE_ON_SCREEN_KEYBOARD
#if defined(COBALT_ENABLE_SSO)

// Nothing for {'getter_function_name': 'h5vcc_sso', 'conditional': 'COBALT_ENABLE_SSO', 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccSso', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_sso', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccSso', 'type': 'scoped_refptr<H5vccSso>'}.  We will just give them the v8::FunctionTemplate.
#endif  // COBALT_ENABLE_SSO
#if defined(DIAL_SERVER)

// Nothing for {'getter_function_name': 'dial_http_request', 'conditional': 'DIAL_SERVER', 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DialHttpRequest', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_dial_http_request', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DialHttpRequest', 'type': 'scoped_refptr<DialHttpRequest>'}.  We will just give them the v8::FunctionTemplate.
#endif  // DIAL_SERVER
#if defined(DIAL_SERVER)

// Nothing for {'getter_function_name': 'dial_http_response', 'conditional': 'DIAL_SERVER', 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DialHttpResponse', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_dial_http_response', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DialHttpResponse', 'type': 'scoped_refptr<DialHttpResponse>'}.  We will just give them the v8::FunctionTemplate.
#endif  // DIAL_SERVER
#if defined(DIAL_SERVER)

// Nothing for {'getter_function_name': 'dial_server', 'conditional': 'DIAL_SERVER', 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DialServer', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_dial_server', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DialServer', 'type': 'scoped_refptr<DialServer>'}.  We will just give them the v8::FunctionTemplate.
#endif  // DIAL_SERVER
#if defined(ENABLE_DEBUGGER)

// Nothing for {'getter_function_name': 'css_agent', 'conditional': 'ENABLE_DEBUGGER', 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CSSAgent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_css_agent', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CSSAgent', 'type': 'scoped_refptr<CSSAgent>'}.  We will just give them the v8::FunctionTemplate.
#endif  // ENABLE_DEBUGGER
#if defined(ENABLE_DEBUGGER)

// Nothing for {'getter_function_name': 'debug_backend', 'conditional': 'ENABLE_DEBUGGER', 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DebugBackend', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_debug_backend', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DebugBackend', 'type': 'scoped_refptr<DebugBackend>'}.  We will just give them the v8::FunctionTemplate.
#endif  // ENABLE_DEBUGGER
#if defined(ENABLE_DEBUGGER)

// Nothing for {'getter_function_name': 'debug_hub', 'conditional': 'ENABLE_DEBUGGER', 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DebugHub', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_debug_hub', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DebugHub', 'type': 'scoped_refptr<DebugHub>'}.  We will just give them the v8::FunctionTemplate.
#endif  // ENABLE_DEBUGGER
#if defined(ENABLE_DEBUGGER)

// Nothing for {'getter_function_name': 'debugger_event_target', 'conditional': 'ENABLE_DEBUGGER', 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DebuggerEventTarget', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_debugger_event_target', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DebuggerEventTarget', 'type': 'scoped_refptr<DebuggerEventTarget>'}.  We will just give them the v8::FunctionTemplate.
#endif  // ENABLE_DEBUGGER
#if defined(ENABLE_TEST_RUNNER)

// Nothing for {'getter_function_name': 'test_runner', 'conditional': 'ENABLE_TEST_RUNNER', 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'TestRunner', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_test_runner', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'TestRunner', 'type': 'scoped_refptr<TestRunner>'}.  We will just give them the v8::FunctionTemplate.
#endif  // ENABLE_TEST_RUNNER

// Nothing for {'getter_function_name': 'animatable', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Animatable', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_animatable', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Animatable', 'type': 'scoped_refptr<Animatable>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'animation', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Animation', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_animation', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Animation', 'type': 'scoped_refptr<Animation>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'animation_effect_read_only', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'AnimationEffectReadOnly', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_animation_effect_read_only', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'AnimationEffectReadOnly', 'type': 'scoped_refptr<AnimationEffectReadOnly>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'animation_effect_timing_read_only', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'AnimationEffectTimingReadOnly', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_animation_effect_timing_read_only', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'AnimationEffectTimingReadOnly', 'type': 'scoped_refptr<AnimationEffectTimingReadOnly>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'animation_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'AnimationEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_animation_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'AnimationEvent', 'type': 'scoped_refptr<AnimationEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'animation_timeline', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'AnimationTimeline', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_animation_timeline', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'AnimationTimeline', 'type': 'scoped_refptr<AnimationTimeline>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'attr', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Attr', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_attr', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Attr', 'type': 'scoped_refptr<Attr>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'audio_buffer', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'AudioBuffer', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_audio_buffer', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'AudioBuffer', 'type': 'scoped_refptr<AudioBuffer>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'audio_buffer_source_node', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'AudioBufferSourceNode', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_audio_buffer_source_node', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'AudioBufferSourceNode', 'type': 'scoped_refptr<AudioBufferSourceNode>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'audio_context', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'AudioContext', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_audio_context', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'AudioContext', 'type': 'scoped_refptr<AudioContext>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'audio_destination_node', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'AudioDestinationNode', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_audio_destination_node', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'AudioDestinationNode', 'type': 'scoped_refptr<AudioDestinationNode>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'audio_node', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'AudioNode', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_audio_node', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'AudioNode', 'type': 'scoped_refptr<AudioNode>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'audio_track', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'AudioTrack', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_audio_track', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'AudioTrack', 'type': 'scoped_refptr<AudioTrack>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'audio_track_list', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'AudioTrackList', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_audio_track_list', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'AudioTrackList', 'type': 'scoped_refptr<AudioTrackList>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'blob', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Blob', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_blob', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Blob', 'type': 'scoped_refptr<Blob>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'blob_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'BlobEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_blob_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'BlobEvent', 'type': 'scoped_refptr<BlobEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'cdata_section', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CDATASection', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_cdata_section', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CDATASection', 'type': 'scoped_refptr<CDATASection>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'css_condition_rule', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CSSConditionRule', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_css_condition_rule', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CSSConditionRule', 'type': 'scoped_refptr<CSSConditionRule>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'css', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CSS', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_css', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CSS', 'type': 'scoped_refptr<CSS>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'css_font_face_rule', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CSSFontFaceRule', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_css_font_face_rule', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CSSFontFaceRule', 'type': 'scoped_refptr<CSSFontFaceRule>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'css_grouping_rule', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CSSGroupingRule', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_css_grouping_rule', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CSSGroupingRule', 'type': 'scoped_refptr<CSSGroupingRule>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'css_keyframe_rule', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CSSKeyframeRule', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_css_keyframe_rule', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CSSKeyframeRule', 'type': 'scoped_refptr<CSSKeyframeRule>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'css_keyframes_rule', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CSSKeyframesRule', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_css_keyframes_rule', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CSSKeyframesRule', 'type': 'scoped_refptr<CSSKeyframesRule>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'css_media_rule', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CSSMediaRule', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_css_media_rule', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CSSMediaRule', 'type': 'scoped_refptr<CSSMediaRule>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'css_rule', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CSSRule', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_css_rule', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CSSRule', 'type': 'scoped_refptr<CSSRule>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'css_rule_list', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CSSRuleList', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_css_rule_list', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CSSRuleList', 'type': 'scoped_refptr<CSSRuleList>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'css_style_declaration', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CSSStyleDeclaration', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_css_style_declaration', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CSSStyleDeclaration', 'type': 'scoped_refptr<CSSStyleDeclaration>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'css_style_rule', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CSSStyleRule', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_css_style_rule', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CSSStyleRule', 'type': 'scoped_refptr<CSSStyleRule>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'css_style_sheet', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CSSStyleSheet', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_css_style_sheet', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CSSStyleSheet', 'type': 'scoped_refptr<CSSStyleSheet>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'c_val_key_list', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CValKeyList', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_c_val_key_list', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CValKeyList', 'type': 'scoped_refptr<CValKeyList>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'c_val_view', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CValView', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_c_val_view', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CValView', 'type': 'scoped_refptr<CValView>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'camera_3d', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Camera3D', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_camera_3d', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Camera3D', 'type': 'scoped_refptr<Camera3D>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'character_data', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CharacterData', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_character_data', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CharacterData', 'type': 'scoped_refptr<CharacterData>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'close_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CloseEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_close_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CloseEvent', 'type': 'scoped_refptr<CloseEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'comment', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Comment', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_comment', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Comment', 'type': 'scoped_refptr<Comment>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'console', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Console', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_console', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Console', 'type': 'scoped_refptr<Console>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'crypto', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Crypto', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_crypto', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Crypto', 'type': 'scoped_refptr<Crypto>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'custom_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'CustomEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_custom_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'CustomEvent', 'type': 'scoped_refptr<CustomEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'dom_exception', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DOMException', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_dom_exception', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DOMException', 'type': 'scoped_refptr<DOMException>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'dom_implementation', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DOMImplementation', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_dom_implementation', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DOMImplementation', 'type': 'scoped_refptr<DOMImplementation>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'dom_parser', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DOMParser', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_dom_parser', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DOMParser', 'type': 'scoped_refptr<DOMParser>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'dom_rect', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DOMRect', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_dom_rect', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DOMRect', 'type': 'scoped_refptr<DOMRect>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'dom_rect_read_only', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DOMRectReadOnly', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_dom_rect_read_only', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DOMRectReadOnly', 'type': 'scoped_refptr<DOMRectReadOnly>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'dom_string_map', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DOMStringMap', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_dom_string_map', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DOMStringMap', 'type': 'scoped_refptr<DOMStringMap>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'dom_token_list', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DOMTokenList', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_dom_token_list', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DOMTokenList', 'type': 'scoped_refptr<DOMTokenList>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'device_orientation_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DeviceOrientationEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_device_orientation_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DeviceOrientationEvent', 'type': 'scoped_refptr<DeviceOrientationEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'document', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Document', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_document', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Document', 'type': 'scoped_refptr<Document>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'document_timeline', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DocumentTimeline', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_document_timeline', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DocumentTimeline', 'type': 'scoped_refptr<DocumentTimeline>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'document_type', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'DocumentType', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_document_type', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'DocumentType', 'type': 'scoped_refptr<DocumentType>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Element', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Element', 'type': 'scoped_refptr<Element>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'error_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'ErrorEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_error_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'ErrorEvent', 'type': 'scoped_refptr<ErrorEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Event', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Event', 'type': 'scoped_refptr<Event>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'event_target', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'EventTarget', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_event_target', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'EventTarget', 'type': 'scoped_refptr<EventTarget>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'fetch_internal', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'FetchInternal', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_fetch_internal', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'FetchInternal', 'type': 'scoped_refptr<FetchInternal>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'focus_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'FocusEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_focus_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'FocusEvent', 'type': 'scoped_refptr<FocusEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'h5vcc_accessibility', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccAccessibility', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_accessibility', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccAccessibility', 'type': 'scoped_refptr<H5vccAccessibility>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'h5vcc_account_info', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccAccountInfo', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_account_info', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccAccountInfo', 'type': 'scoped_refptr<H5vccAccountInfo>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'h5vcc_audio_config_array', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccAudioConfigArray', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_audio_config_array', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccAudioConfigArray', 'type': 'scoped_refptr<H5vccAudioConfigArray>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'h5vcc_audio_config', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccAudioConfig', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_audio_config', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccAudioConfig', 'type': 'scoped_refptr<H5vccAudioConfig>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'h5vcc', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vcc', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vcc', 'type': 'scoped_refptr<H5vcc>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'h5vcc_deep_link_event_target', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccDeepLinkEventTarget', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_deep_link_event_target', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccDeepLinkEventTarget', 'type': 'scoped_refptr<H5vccDeepLinkEventTarget>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'h5vcc_platform_service', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccPlatformService', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_platform_service', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccPlatformService', 'type': 'scoped_refptr<H5vccPlatformService>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'h5vcc_runtime', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccRuntime', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_runtime', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccRuntime', 'type': 'scoped_refptr<H5vccRuntime>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'h5vcc_runtime_event_target', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccRuntimeEventTarget', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_runtime_event_target', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccRuntimeEventTarget', 'type': 'scoped_refptr<H5vccRuntimeEventTarget>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'h5vcc_settings', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccSettings', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_settings', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccSettings', 'type': 'scoped_refptr<H5vccSettings>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'h5vcc_storage', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccStorage', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_storage', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccStorage', 'type': 'scoped_refptr<H5vccStorage>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'h5vcc_system', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccSystem', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_system', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccSystem', 'type': 'scoped_refptr<H5vccSystem>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'h5vcc_trace_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'H5vccTraceEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_h5vcc_trace_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'H5vccTraceEvent', 'type': 'scoped_refptr<H5vccTraceEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_anchor_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLAnchorElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_anchor_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLAnchorElement', 'type': 'scoped_refptr<HTMLAnchorElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_br_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLBRElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_br_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLBRElement', 'type': 'scoped_refptr<HTMLBRElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_body_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLBodyElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_body_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLBodyElement', 'type': 'scoped_refptr<HTMLBodyElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_collection', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLCollection', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_collection', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLCollection', 'type': 'scoped_refptr<HTMLCollection>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_div_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLDivElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_div_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLDivElement', 'type': 'scoped_refptr<HTMLDivElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLElement', 'type': 'scoped_refptr<HTMLElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_head_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLHeadElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_head_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLHeadElement', 'type': 'scoped_refptr<HTMLHeadElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_heading_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLHeadingElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_heading_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLHeadingElement', 'type': 'scoped_refptr<HTMLHeadingElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_html_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLHtmlElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_html_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLHtmlElement', 'type': 'scoped_refptr<HTMLHtmlElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_image_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLImageElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_image_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLImageElement', 'type': 'scoped_refptr<HTMLImageElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'image', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': True, 'idl_name': 'Image', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_image', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLImageElement', 'type': 'scoped_refptr<HTMLImageElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_link_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLLinkElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_link_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLLinkElement', 'type': 'scoped_refptr<HTMLLinkElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_media_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLMediaElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_media_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLMediaElement', 'type': 'scoped_refptr<HTMLMediaElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_meta_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLMetaElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_meta_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLMetaElement', 'type': 'scoped_refptr<HTMLMetaElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_paragraph_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLParagraphElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_paragraph_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLParagraphElement', 'type': 'scoped_refptr<HTMLParagraphElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_script_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLScriptElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_script_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLScriptElement', 'type': 'scoped_refptr<HTMLScriptElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_span_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLSpanElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_span_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLSpanElement', 'type': 'scoped_refptr<HTMLSpanElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_style_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLStyleElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_style_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLStyleElement', 'type': 'scoped_refptr<HTMLStyleElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_title_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLTitleElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_title_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLTitleElement', 'type': 'scoped_refptr<HTMLTitleElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_unknown_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLUnknownElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_unknown_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLUnknownElement', 'type': 'scoped_refptr<HTMLUnknownElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'html_video_element', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'HTMLVideoElement', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_html_video_element', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'HTMLVideoElement', 'type': 'scoped_refptr<HTMLVideoElement>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'history', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'History', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_history', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'History', 'type': 'scoped_refptr<History>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'input_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'InputEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_input_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'InputEvent', 'type': 'scoped_refptr<InputEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'keyboard_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'KeyboardEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_keyboard_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'KeyboardEvent', 'type': 'scoped_refptr<KeyboardEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'keyframe', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Keyframe', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_keyframe', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Keyframe', 'type': 'scoped_refptr<Keyframe>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'keyframe_effect_read_only', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'KeyframeEffectReadOnly', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_keyframe_effect_read_only', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'KeyframeEffectReadOnly', 'type': 'scoped_refptr<KeyframeEffectReadOnly>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'location', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Location', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_location', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Location', 'type': 'scoped_refptr<Location>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_device_info', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaDeviceInfo', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_device_info', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaDeviceInfo', 'type': 'scoped_refptr<MediaDeviceInfo>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_devices', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaDevices', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_devices', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaDevices', 'type': 'scoped_refptr<MediaDevices>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_encrypted_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaEncryptedEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_encrypted_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaEncryptedEvent', 'type': 'scoped_refptr<MediaEncryptedEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_error', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaError', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_error', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaError', 'type': 'scoped_refptr<MediaError>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_key_message_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaKeyMessageEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_key_message_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaKeyMessageEvent', 'type': 'scoped_refptr<MediaKeyMessageEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_key_session', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaKeySession', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_key_session', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaKeySession', 'type': 'scoped_refptr<MediaKeySession>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_key_status_map', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaKeyStatusMap', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_key_status_map', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaKeyStatusMap', 'type': 'scoped_refptr<MediaKeyStatusMap>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_key_system_access', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaKeySystemAccess', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_key_system_access', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaKeySystemAccess', 'type': 'scoped_refptr<MediaKeySystemAccess>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_keys', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaKeys', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_keys', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaKeys', 'type': 'scoped_refptr<MediaKeys>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_list', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaList', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_list', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaList', 'type': 'scoped_refptr<MediaList>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_metadata', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaMetadata', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_metadata', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaMetadata', 'type': 'scoped_refptr<MediaMetadata>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_query_list', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaQueryList', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_query_list', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaQueryList', 'type': 'scoped_refptr<MediaQueryList>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_recorder', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaRecorder', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_recorder', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaRecorder', 'type': 'scoped_refptr<MediaRecorder>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_session_action_details', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaSessionActionDetails', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_session_action_details', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaSessionActionDetails', 'type': 'scoped_refptr<MediaSessionActionDetails>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_session', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaSession', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_session', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaSession', 'type': 'scoped_refptr<MediaSession>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_source', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaSource', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_source', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaSource', 'type': 'scoped_refptr<MediaSource>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_stream', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaStream', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_stream', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaStream', 'type': 'scoped_refptr<MediaStream>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'media_stream_track', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MediaStreamTrack', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_media_stream_track', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MediaStreamTrack', 'type': 'scoped_refptr<MediaStreamTrack>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'message_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MessageEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_message_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MessageEvent', 'type': 'scoped_refptr<MessageEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'mime_type_array', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MimeTypeArray', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_mime_type_array', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MimeTypeArray', 'type': 'scoped_refptr<MimeTypeArray>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'mouse_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MouseEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_mouse_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MouseEvent', 'type': 'scoped_refptr<MouseEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'mutation_observer', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MutationObserver', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_mutation_observer', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MutationObserver', 'type': 'scoped_refptr<MutationObserver>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'mutation_record', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'MutationRecord', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_mutation_record', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'MutationRecord', 'type': 'scoped_refptr<MutationRecord>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'named_node_map', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'NamedNodeMap', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_named_node_map', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'NamedNodeMap', 'type': 'scoped_refptr<NamedNodeMap>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'navigator', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Navigator', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_navigator', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Navigator', 'type': 'scoped_refptr<Navigator>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'node', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Node', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_node', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Node', 'type': 'scoped_refptr<Node>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'node_list', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'NodeList', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_node_list', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'NodeList', 'type': 'scoped_refptr<NodeList>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'performance', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Performance', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_performance', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Performance', 'type': 'scoped_refptr<Performance>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'performance_timing', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'PerformanceTiming', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_performance_timing', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'PerformanceTiming', 'type': 'scoped_refptr<PerformanceTiming>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'plugin_array', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'PluginArray', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_plugin_array', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'PluginArray', 'type': 'scoped_refptr<PluginArray>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'pointer_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'PointerEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_pointer_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'PointerEvent', 'type': 'scoped_refptr<PointerEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'progress_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'ProgressEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_progress_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'ProgressEvent', 'type': 'scoped_refptr<ProgressEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'screen', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Screen', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_screen', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Screen', 'type': 'scoped_refptr<Screen>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'screenshot', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Screenshot', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_screenshot', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Screenshot', 'type': 'scoped_refptr<Screenshot>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'security_policy_violation_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SecurityPolicyViolationEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_security_policy_violation_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SecurityPolicyViolationEvent', 'type': 'scoped_refptr<SecurityPolicyViolationEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'source_buffer', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SourceBuffer', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_source_buffer', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SourceBuffer', 'type': 'scoped_refptr<SourceBuffer>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'source_buffer_list', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SourceBufferList', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_source_buffer_list', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SourceBufferList', 'type': 'scoped_refptr<SourceBufferList>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'speech_recognition_alternative', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SpeechRecognitionAlternative', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_speech_recognition_alternative', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SpeechRecognitionAlternative', 'type': 'scoped_refptr<SpeechRecognitionAlternative>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'speech_recognition', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SpeechRecognition', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_speech_recognition', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SpeechRecognition', 'type': 'scoped_refptr<SpeechRecognition>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'speech_recognition_error', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SpeechRecognitionError', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_speech_recognition_error', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SpeechRecognitionError', 'type': 'scoped_refptr<SpeechRecognitionError>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'speech_recognition_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SpeechRecognitionEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_speech_recognition_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SpeechRecognitionEvent', 'type': 'scoped_refptr<SpeechRecognitionEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'speech_recognition_result', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SpeechRecognitionResult', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_speech_recognition_result', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SpeechRecognitionResult', 'type': 'scoped_refptr<SpeechRecognitionResult>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'speech_recognition_result_list', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SpeechRecognitionResultList', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_speech_recognition_result_list', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SpeechRecognitionResultList', 'type': 'scoped_refptr<SpeechRecognitionResultList>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'speech_synthesis', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SpeechSynthesis', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_speech_synthesis', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SpeechSynthesis', 'type': 'scoped_refptr<SpeechSynthesis>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'speech_synthesis_error_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SpeechSynthesisErrorEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_speech_synthesis_error_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SpeechSynthesisErrorEvent', 'type': 'scoped_refptr<SpeechSynthesisErrorEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'speech_synthesis_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SpeechSynthesisEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_speech_synthesis_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SpeechSynthesisEvent', 'type': 'scoped_refptr<SpeechSynthesisEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'speech_synthesis_utterance', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SpeechSynthesisUtterance', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_speech_synthesis_utterance', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SpeechSynthesisUtterance', 'type': 'scoped_refptr<SpeechSynthesisUtterance>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'speech_synthesis_voice', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SpeechSynthesisVoice', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_speech_synthesis_voice', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SpeechSynthesisVoice', 'type': 'scoped_refptr<SpeechSynthesisVoice>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'storage', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Storage', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_storage', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Storage', 'type': 'scoped_refptr<Storage>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'storage_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'StorageEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_storage_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'StorageEvent', 'type': 'scoped_refptr<StorageEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'style_sheet', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'StyleSheet', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_style_sheet', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'StyleSheet', 'type': 'scoped_refptr<StyleSheet>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'style_sheet_list', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'StyleSheetList', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_style_sheet_list', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'StyleSheetList', 'type': 'scoped_refptr<StyleSheetList>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'system_caption_settings', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'SystemCaptionSettings', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_system_caption_settings', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'SystemCaptionSettings', 'type': 'scoped_refptr<SystemCaptionSettings>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'text', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Text', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_text', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Text', 'type': 'scoped_refptr<Text>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'time_ranges', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'TimeRanges', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_time_ranges', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'TimeRanges', 'type': 'scoped_refptr<TimeRanges>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'track_default', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'TrackDefault', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_track_default', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'TrackDefault', 'type': 'scoped_refptr<TrackDefault>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'track_default_list', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'TrackDefaultList', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_track_default_list', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'TrackDefaultList', 'type': 'scoped_refptr<TrackDefaultList>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'track_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'TrackEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_track_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'TrackEvent', 'type': 'scoped_refptr<TrackEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'transition_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'TransitionEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_transition_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'TransitionEvent', 'type': 'scoped_refptr<TransitionEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'ui_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'UIEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_ui_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'UIEvent', 'type': 'scoped_refptr<UIEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'url', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'URL', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_url', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'URL', 'type': 'scoped_refptr<URL>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'video_playback_quality', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'VideoPlaybackQuality', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_video_playback_quality', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'VideoPlaybackQuality', 'type': 'scoped_refptr<VideoPlaybackQuality>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'video_track', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'VideoTrack', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_video_track', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'VideoTrack', 'type': 'scoped_refptr<VideoTrack>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'video_track_list', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'VideoTrackList', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_video_track_list', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'VideoTrackList', 'type': 'scoped_refptr<VideoTrackList>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'web_socket', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'WebSocket', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_web_socket', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'WebSocket', 'type': 'scoped_refptr<WebSocket>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'wheel_event', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'WheelEvent', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_wheel_event', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'WheelEvent', 'type': 'scoped_refptr<WheelEvent>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'window', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'Window', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_window', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'Window', 'type': 'scoped_refptr<Window>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'xml_document', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'XMLDocument', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_xml_document', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'XMLDocument', 'type': 'scoped_refptr<XMLDocument>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'xml_http_request', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'XMLHttpRequest', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_xml_http_request', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'XMLHttpRequest', 'type': 'scoped_refptr<XMLHttpRequest>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'xml_http_request_event_target', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'XMLHttpRequestEventTarget', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_xml_http_request_event_target', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'XMLHttpRequestEventTarget', 'type': 'scoped_refptr<XMLHttpRequestEventTarget>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'xml_http_request_upload', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'XMLHttpRequestUpload', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_xml_http_request_upload', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'XMLHttpRequestUpload', 'type': 'scoped_refptr<XMLHttpRequestUpload>'}.  We will just give them the v8::FunctionTemplate.

// Nothing for {'getter_function_name': 'xml_serializer', 'conditional': None, 'on_prototype': False, 'unsupported': False, 'is_read_only': False, 'is_named_constructor_attribute': False, 'idl_name': 'XMLSerializer', 'is_static': False, 'call_with': None, 'on_instance': True, 'is_constructor_attribute': True, 'raises_exception': False, 'setter_function_name': 'set_xml_serializer', 'on_interface': False, 'has_setter': True, 'conversion_flags': 'kNoConversionFlags', 'interface_name': 'XMLSerializer', 'type': 'scoped_refptr<XMLSerializer>'}.  We will just give them the v8::FunctionTemplate.


void atobMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  const size_t kMinArguments = 1;
  if (info.Length() < kMinArguments) {
    exception_state.SetSimpleException(script::kInvalidNumberOfArguments);
    return;
  }
  // Non-optional arguments
  TypeTraits<std::string >::ConversionType encodedString;
  DCHECK_LT(0, info.Length());
  v8::Local<v8::Value> non_optional_value0 = info[0];
  FromJSValue(isolate,
              non_optional_value0,
              kNoConversionFlags,
              &exception_state, &encodedString);
  if (exception_state.is_exception_set()) {
    return;
  }

  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->Atob(encodedString, &exception_state),
              &result_value);
  }
  if (!exception_state.is_exception_set()) {
    info.GetReturnValue().Set(result_value);
  }

}



void btoaMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  const size_t kMinArguments = 1;
  if (info.Length() < kMinArguments) {
    exception_state.SetSimpleException(script::kInvalidNumberOfArguments);
    return;
  }
  // Non-optional arguments
  TypeTraits<std::string >::ConversionType stringToEncode;
  DCHECK_LT(0, info.Length());
  v8::Local<v8::Value> non_optional_value0 = info[0];
  FromJSValue(isolate,
              non_optional_value0,
              kNoConversionFlags,
              &exception_state, &stringToEncode);
  if (exception_state.is_exception_set()) {
    return;
  }

  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->Btoa(stringToEncode, &exception_state),
              &result_value);
  }
  if (!exception_state.is_exception_set()) {
    info.GetReturnValue().Set(result_value);
  }

}



void cancelAnimationFrameMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  const size_t kMinArguments = 1;
  if (info.Length() < kMinArguments) {
    exception_state.SetSimpleException(script::kInvalidNumberOfArguments);
    return;
  }
  // Non-optional arguments
  TypeTraits<int32_t >::ConversionType handle;
  DCHECK_LT(0, info.Length());
  v8::Local<v8::Value> non_optional_value0 = info[0];
  FromJSValue(isolate,
              non_optional_value0,
              kNoConversionFlags,
              &exception_state, &handle);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->CancelAnimationFrame(handle);
  result_value = v8::Undefined(isolate);

}



void clearIntervalMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  const size_t kMinArguments = 1;
  if (info.Length() < kMinArguments) {
    exception_state.SetSimpleException(script::kInvalidNumberOfArguments);
    return;
  }
  // Non-optional arguments
  TypeTraits<int32_t >::ConversionType handle;
  DCHECK_LT(0, info.Length());
  v8::Local<v8::Value> non_optional_value0 = info[0];
  FromJSValue(isolate,
              non_optional_value0,
              kNoConversionFlags,
              &exception_state, &handle);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->ClearInterval(handle);
  result_value = v8::Undefined(isolate);

}



void clearTimeoutMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  const size_t kMinArguments = 1;
  if (info.Length() < kMinArguments) {
    exception_state.SetSimpleException(script::kInvalidNumberOfArguments);
    return;
  }
  // Non-optional arguments
  TypeTraits<int32_t >::ConversionType handle;
  DCHECK_LT(0, info.Length());
  v8::Local<v8::Value> non_optional_value0 = info[0];
  FromJSValue(isolate,
              non_optional_value0,
              kNoConversionFlags,
              &exception_state, &handle);
  if (exception_state.is_exception_set()) {
    return;
  }

  impl->ClearTimeout(handle);
  result_value = v8::Undefined(isolate);

}



void closeMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();

  impl->Close();
  result_value = v8::Undefined(isolate);

}



void gcMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  V8cGlobalEnvironment* callwith_global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);

  impl->Gc(callwith_global_environment->GetEnvironmentSettings());
  result_value = v8::Undefined(isolate);

}



void getComputedStyleMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  const size_t kMinArguments = 1;
  if (info.Length() < kMinArguments) {
    exception_state.SetSimpleException(script::kInvalidNumberOfArguments);
    return;
  }
  // Non-optional arguments
  TypeTraits<scoped_refptr<Element> >::ConversionType elt;
  // Optional arguments
  TypeTraits<std::string >::ConversionType pseudoElt;
  DCHECK_LT(0, info.Length());
  v8::Local<v8::Value> non_optional_value0 = info[0];
  FromJSValue(isolate,
              non_optional_value0,
              kNoConversionFlags,
              &exception_state, &elt);
  if (exception_state.is_exception_set()) {
    return;
  }
  size_t num_set_arguments = 1;
  if (info.Length() > 1) {
    v8::Local<v8::Value> optional_value0 = info[1];
    FromJSValue(isolate,
                optional_value0,
                kNoConversionFlags,
                &exception_state,
                &pseudoElt);
    if (exception_state.is_exception_set()) {
      return;
    }
    ++num_set_arguments;
  }
  switch (num_set_arguments) {
    case 1:
      {
          if (!exception_state.is_exception_set()) {
            ToJSValue(isolate,
                      impl->GetComputedStyle(elt),
                      &result_value);
          }
          if (!exception_state.is_exception_set()) {
            info.GetReturnValue().Set(result_value);
          }
      }
      break;
    case 2:
      {
          if (!exception_state.is_exception_set()) {
            ToJSValue(isolate,
                      impl->GetComputedStyle(elt, pseudoElt),
                      &result_value);
          }
          if (!exception_state.is_exception_set()) {
            info.GetReturnValue().Set(result_value);
          }
      }
      break;
    default:
      NOTREACHED();
      return;
  }
}



void matchMediaMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  const size_t kMinArguments = 1;
  if (info.Length() < kMinArguments) {
    exception_state.SetSimpleException(script::kInvalidNumberOfArguments);
    return;
  }
  // Non-optional arguments
  TypeTraits<std::string >::ConversionType query;
  DCHECK_LT(0, info.Length());
  v8::Local<v8::Value> non_optional_value0 = info[0];
  FromJSValue(isolate,
              non_optional_value0,
              kNoConversionFlags,
              &exception_state, &query);
  if (exception_state.is_exception_set()) {
    return;
  }

  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->MatchMedia(query),
              &result_value);
  }
  if (!exception_state.is_exception_set()) {
    info.GetReturnValue().Set(result_value);
  }

}



void minimizeMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();

  impl->Minimize();
  result_value = v8::Undefined(isolate);

}



void requestAnimationFrameMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  const size_t kMinArguments = 1;
  if (info.Length() < kMinArguments) {
    exception_state.SetSimpleException(script::kInvalidNumberOfArguments);
    return;
  }
  // Non-optional arguments
  TypeTraits<Window::FrameRequestCallback >::ConversionType callback;
  DCHECK_LT(0, info.Length());
  v8::Local<v8::Value> non_optional_value0 = info[0];
  FromJSValue(isolate,
              non_optional_value0,
              kNoConversionFlags,
              &exception_state, &callback);
  if (exception_state.is_exception_set()) {
    return;
  }

  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->RequestAnimationFrame(callback),
              &result_value);
  }
  if (!exception_state.is_exception_set()) {
    info.GetReturnValue().Set(result_value);
  }

}



void screenshotMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();

  if (!exception_state.is_exception_set()) {
    ToJSValue(isolate,
              impl->Screenshot(),
              &result_value);
  }
  if (!exception_state.is_exception_set()) {
    info.GetReturnValue().Set(result_value);
  }

}



void setIntervalMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  const size_t kMinArguments = 1;
  if (info.Length() < kMinArguments) {
    exception_state.SetSimpleException(script::kInvalidNumberOfArguments);
    return;
  }
  // Non-optional arguments
  TypeTraits<Window::TimerCallback >::ConversionType handler;
  // Optional arguments
  TypeTraits<int32_t >::ConversionType timeout;
  DCHECK_LT(0, info.Length());
  v8::Local<v8::Value> non_optional_value0 = info[0];
  FromJSValue(isolate,
              non_optional_value0,
              kNoConversionFlags,
              &exception_state, &handler);
  if (exception_state.is_exception_set()) {
    return;
  }
  size_t num_set_arguments = 1;
  if (info.Length() > 1) {
    v8::Local<v8::Value> optional_value0 = info[1];
    FromJSValue(isolate,
                optional_value0,
                kNoConversionFlags,
                &exception_state,
                &timeout);
    if (exception_state.is_exception_set()) {
      return;
    }
    ++num_set_arguments;
  }
  switch (num_set_arguments) {
    case 1:
      {
          if (!exception_state.is_exception_set()) {
            ToJSValue(isolate,
                      impl->SetInterval(handler),
                      &result_value);
          }
          if (!exception_state.is_exception_set()) {
            info.GetReturnValue().Set(result_value);
          }
      }
      break;
    case 2:
      {
          if (!exception_state.is_exception_set()) {
            ToJSValue(isolate,
                      impl->SetInterval(handler, timeout),
                      &result_value);
          }
          if (!exception_state.is_exception_set()) {
            info.GetReturnValue().Set(result_value);
          }
      }
      break;
    default:
      NOTREACHED();
      return;
  }
}



void setTimeoutMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Object> object = info.Holder();
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  WrapperFactory* wrapper_factory = global_environment->wrapper_factory();
  if (!WrapperPrivate::HasWrapperPrivate(object) ||
      !V8cWindow::GetTemplate(isolate)->HasInstance(object)) {
    V8cExceptionState exception(isolate);
    exception.SetSimpleException(script::kDoesNotImplementInterface);
    return;
  }
  V8cExceptionState exception_state{isolate};
  v8::Local<v8::Value> result_value;

  WrapperPrivate* wrapper_private =
      WrapperPrivate::GetFromWrapperObject(object);
  if (!wrapper_private) {
    NOTIMPLEMENTED();
    return;
  }
  Window* impl =
      wrapper_private->wrappable<Window>().get();
  const size_t kMinArguments = 1;
  if (info.Length() < kMinArguments) {
    exception_state.SetSimpleException(script::kInvalidNumberOfArguments);
    return;
  }
  // Non-optional arguments
  TypeTraits<Window::TimerCallback >::ConversionType handler;
  // Optional arguments
  TypeTraits<int32_t >::ConversionType timeout;
  DCHECK_LT(0, info.Length());
  v8::Local<v8::Value> non_optional_value0 = info[0];
  FromJSValue(isolate,
              non_optional_value0,
              kNoConversionFlags,
              &exception_state, &handler);
  if (exception_state.is_exception_set()) {
    return;
  }
  size_t num_set_arguments = 1;
  if (info.Length() > 1) {
    v8::Local<v8::Value> optional_value0 = info[1];
    FromJSValue(isolate,
                optional_value0,
                kNoConversionFlags,
                &exception_state,
                &timeout);
    if (exception_state.is_exception_set()) {
      return;
    }
    ++num_set_arguments;
  }
  switch (num_set_arguments) {
    case 1:
      {
          if (!exception_state.is_exception_set()) {
            ToJSValue(isolate,
                      impl->SetTimeout(handler),
                      &result_value);
          }
          if (!exception_state.is_exception_set()) {
            info.GetReturnValue().Set(result_value);
          }
      }
      break;
    case 2:
      {
          if (!exception_state.is_exception_set()) {
            ToJSValue(isolate,
                      impl->SetTimeout(handler, timeout),
                      &result_value);
          }
          if (!exception_state.is_exception_set()) {
            info.GetReturnValue().Set(result_value);
          }
      }
      break;
    default:
      NOTREACHED();
      return;
  }
}



void InitializeTemplate(v8::Isolate* isolate) {
  // https://heycam.github.io/webidl/#interface-object
  // 3.6.1. Interface object
  //
  // The interface object for a given interface is a built-in function object.
  // It has properties that correspond to the constants and static operations
  // defined on that interface, as described in sections 3.6.6 Constants and
  // 3.6.8 Operations.
  //
  // If the interface is declared with a [Constructor] extended attribute,
  // then the interface object can be called as a constructor to create an
  // object that implements that interface. Calling that interface as a
  // function will throw an exception.
  //
  // Interface objects whose interfaces are not declared with a [Constructor]
  // extended attribute will throw when called, both as a function and as a
  // constructor.
  //
  // An interface object for a non-callback interface has an associated object
  // called the interface prototype object. This object has properties that
  // correspond to the regular attributes and regular operations defined on
  // the interface, and is described in more detail in 3.6.3 Interface
  // prototype object.
  v8::Local<v8::FunctionTemplate> function_template =
      v8::FunctionTemplate::New(
          isolate,
          DummyConstructor,
          v8::Local<v8::Value>(),
          v8::Local<v8::Signature>(),
          0);
  function_template->SetClassName(NewInternalString(isolate, "Window"));
  function_template->ReadOnlyPrototype();

  v8::Local<v8::ObjectTemplate> prototype_template = function_template->PrototypeTemplate();
  v8::Local<v8::ObjectTemplate> instance_template = function_template->InstanceTemplate();
  instance_template->SetInternalFieldCount(WrapperPrivate::kInternalFieldCount);

  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  global_environment->AddInterfaceData(kInterfaceUniqueId, function_template);

  {
    // An interface can be defined to inherit from another interface. If the
    // identifier of the interface is followed by a U+003A COLON (":") character
    // and an identifier, then that identifier identifies the inherited
    // interface. An object that implements an interface that inherits from
    // another also implements that inherited interface. The object therefore
    // will also have members that correspond to the interface members from the
    // inherited interface.
    v8::Local<v8::FunctionTemplate> parent_template = V8cEventTarget::GetTemplate(isolate);
    function_template->Inherit(parent_template);
    static_assert(
        std::is_base_of<EventTarget, Window>::value,
        "Expected Window to have C++ parent class "
        "EventTarget, because that is its WebIDL parent.");
  }

  // https://heycam.github.io/webidl/#es-constants
  // 3.6.6. Constants
  //
  // For each exposed constant defined on an interface A, there must be a
  // corresponding property. The property has the following characteristics:

  // https://heycam.github.io/webidl/#es-attributes
  // 3.6.7. Attributes
  //
  // For each exposed attribute of the interface there must exist a
  // corresponding property. The characteristics of this property are as
  // follows:
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Image");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Image");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLImageElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "window");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, windowAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "self");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, selfAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "document");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, documentAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "location");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, locationAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, locationAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "history");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, historyAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "frames");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, framesAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "length");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, lengthAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "top");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, topAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "opener");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, openerAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "parent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, parentAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "navigator");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, navigatorAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "console");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, consoleAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "camera3D");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, camera3DAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
#if defined(ENABLE_TEST_RUNNER)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "testRunner");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, testRunnerAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
#endif  // ENABLE_TEST_RUNNER
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "crypto");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, cryptoAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onblur");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onblurAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onblurAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onclick");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onclickAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onclickAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onerror");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onerrorAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onerrorAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onfocus");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onfocusAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onfocusAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onkeydown");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onkeydownAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onkeydownAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onkeypress");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onkeypressAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onkeypressAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onkeyup");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onkeyupAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onkeyupAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onload");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onloadAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onloadAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onloadeddata");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onloadeddataAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onloadeddataAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onloadedmetadata");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onloadedmetadataAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onloadedmetadataAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onloadstart");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onloadstartAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onloadstartAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onmousedown");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onmousedownAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onmousedownAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onmouseenter");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onmouseenterAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onmouseenterAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onmouseleave");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onmouseleaveAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onmouseleaveAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onmousemove");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onmousemoveAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onmousemoveAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onmouseout");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onmouseoutAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onmouseoutAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onmouseover");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onmouseoverAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onmouseoverAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onmouseup");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onmouseupAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onmouseupAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onpause");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onpauseAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onpauseAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onplay");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onplayAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onplayAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onplaying");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onplayingAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onplayingAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onresize");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onresizeAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onresizeAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onscroll");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onscrollAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onscrollAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "ontransitionend");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, ontransitionendAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, ontransitionendAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "ongotpointercapture");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, ongotpointercaptureAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, ongotpointercaptureAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onlostpointercapture");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onlostpointercaptureAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onlostpointercaptureAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onpointerdown");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onpointerdownAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onpointerdownAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onpointerenter");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onpointerenterAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onpointerenterAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onpointerleave");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onpointerleaveAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onpointerleaveAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onpointermove");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onpointermoveAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onpointermoveAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onpointerout");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onpointeroutAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onpointeroutAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onpointerover");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onpointeroverAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onpointeroverAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onpointerup");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onpointerupAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onpointerupAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onprogress");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onprogressAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onprogressAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onratechange");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onratechangeAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onratechangeAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onseeked");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onseekedAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onseekedAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onseeking");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onseekingAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onseekingAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "ontimeupdate");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, ontimeupdateAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, ontimeupdateAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onvolumechange");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onvolumechangeAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onvolumechangeAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onwaiting");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onwaitingAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onwaitingAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onwheel");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onwheelAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onwheelAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "speechSynthesis");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, speechSynthesisAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "performance");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, performanceAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "screen");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, screenAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "innerWidth");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, innerWidthAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "innerHeight");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, innerHeightAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "screenX");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, screenXAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "screenY");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, screenYAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "outerWidth");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, outerWidthAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "outerHeight");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, outerHeightAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "devicePixelRatio");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, devicePixelRatioAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onunload");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onunloadAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onunloadAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onbeforeunload");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onbeforeunloadAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter =
        v8::FunctionTemplate::New(isolate, onbeforeunloadAttributeSetter);

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "localStorage");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, localStorageAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
#if defined(COBALT_ENABLE_ON_SCREEN_KEYBOARD)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "onScreenKeyboard");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, onScreenKeyboardAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
#endif  // COBALT_ENABLE_ON_SCREEN_KEYBOARD
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "sessionStorage");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    v8::Local<v8::FunctionTemplate> getter =
        v8::FunctionTemplate::New(isolate, sessionStorageAttributeGetter);
    v8::Local<v8::FunctionTemplate> setter;

    // The location of the property is determined as follows:
    // Otherwise, if the attribute is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        SetAccessorProperty(
            name,
            getter,
            setter,
            attributes);

  }
#if defined(COBALT_ENABLE_ACCOUNT_MANAGER)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccAccountManager");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccAccountManager");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccAccountManager::GetTemplate(isolate)
      );
    }

  }
#endif  // COBALT_ENABLE_ACCOUNT_MANAGER
#if defined(COBALT_ENABLE_CRASH_LOG)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccCrashLog");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccCrashLog");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccCrashLog::GetTemplate(isolate)
      );
    }

  }
#endif  // COBALT_ENABLE_CRASH_LOG
#if defined(COBALT_ENABLE_ON_SCREEN_KEYBOARD)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "OnScreenKeyboard");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "OnScreenKeyboard");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cOnScreenKeyboard::GetTemplate(isolate)
      );
    }

  }
#endif  // COBALT_ENABLE_ON_SCREEN_KEYBOARD
#if defined(COBALT_ENABLE_SSO)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccSso");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccSso");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccSso::GetTemplate(isolate)
      );
    }

  }
#endif  // COBALT_ENABLE_SSO
#if defined(DIAL_SERVER)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DialHttpRequest");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DialHttpRequest");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDialHttpRequest::GetTemplate(isolate)
      );
    }

  }
#endif  // DIAL_SERVER
#if defined(DIAL_SERVER)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DialHttpResponse");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DialHttpResponse");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDialHttpResponse::GetTemplate(isolate)
      );
    }

  }
#endif  // DIAL_SERVER
#if defined(DIAL_SERVER)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DialServer");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DialServer");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDialServer::GetTemplate(isolate)
      );
    }

  }
#endif  // DIAL_SERVER
#if defined(ENABLE_DEBUGGER)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CSSAgent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CSSAgent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCSSAgent::GetTemplate(isolate)
      );
    }

  }
#endif  // ENABLE_DEBUGGER
#if defined(ENABLE_DEBUGGER)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DebugBackend");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DebugBackend");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDebugBackend::GetTemplate(isolate)
      );
    }

  }
#endif  // ENABLE_DEBUGGER
#if defined(ENABLE_DEBUGGER)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DebugHub");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DebugHub");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDebugHub::GetTemplate(isolate)
      );
    }

  }
#endif  // ENABLE_DEBUGGER
#if defined(ENABLE_DEBUGGER)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DebuggerEventTarget");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DebuggerEventTarget");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDebuggerEventTarget::GetTemplate(isolate)
      );
    }

  }
#endif  // ENABLE_DEBUGGER
#if defined(ENABLE_TEST_RUNNER)
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "TestRunner");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "TestRunner");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cTestRunner::GetTemplate(isolate)
      );
    }

  }
#endif  // ENABLE_TEST_RUNNER
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Animatable");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Animatable");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAnimatable::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Animation");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Animation");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAnimation::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "AnimationEffectReadOnly");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "AnimationEffectReadOnly");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAnimationEffectReadOnly::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "AnimationEffectTimingReadOnly");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "AnimationEffectTimingReadOnly");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAnimationEffectTimingReadOnly::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "AnimationEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "AnimationEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAnimationEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "AnimationTimeline");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "AnimationTimeline");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAnimationTimeline::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Attr");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Attr");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAttr::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "AudioBuffer");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "AudioBuffer");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAudioBuffer::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "AudioBufferSourceNode");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "AudioBufferSourceNode");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAudioBufferSourceNode::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "AudioContext");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "AudioContext");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAudioContext::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "AudioDestinationNode");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "AudioDestinationNode");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAudioDestinationNode::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "AudioNode");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "AudioNode");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAudioNode::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "AudioTrack");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "AudioTrack");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAudioTrack::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "AudioTrackList");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "AudioTrackList");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cAudioTrackList::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Blob");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Blob");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cBlob::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "BlobEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "BlobEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cBlobEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CDATASection");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CDATASection");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCDATASection::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CSSConditionRule");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CSSConditionRule");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCSSConditionRule::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CSS");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CSS");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCSS::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CSSFontFaceRule");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CSSFontFaceRule");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCSSFontFaceRule::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CSSGroupingRule");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CSSGroupingRule");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCSSGroupingRule::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CSSKeyframeRule");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CSSKeyframeRule");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCSSKeyframeRule::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CSSKeyframesRule");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CSSKeyframesRule");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCSSKeyframesRule::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CSSMediaRule");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CSSMediaRule");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCSSMediaRule::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CSSRule");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CSSRule");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCSSRule::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CSSRuleList");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CSSRuleList");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCSSRuleList::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CSSStyleDeclaration");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CSSStyleDeclaration");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCSSStyleDeclaration::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CSSStyleRule");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CSSStyleRule");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCSSStyleRule::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CSSStyleSheet");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CSSStyleSheet");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCSSStyleSheet::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CValKeyList");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CValKeyList");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCValKeyList::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CValView");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CValView");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCValView::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Camera3D");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Camera3D");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCamera3D::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CharacterData");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CharacterData");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCharacterData::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CloseEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CloseEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCloseEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Comment");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Comment");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cComment::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Console");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Console");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cConsole::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Crypto");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Crypto");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCrypto::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "CustomEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "CustomEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cCustomEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DOMException");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DOMException");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDOMException::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DOMImplementation");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DOMImplementation");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDOMImplementation::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DOMParser");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DOMParser");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDOMParser::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DOMRect");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DOMRect");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDOMRect::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DOMRectReadOnly");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DOMRectReadOnly");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDOMRectReadOnly::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DOMStringMap");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DOMStringMap");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDOMStringMap::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DOMTokenList");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DOMTokenList");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDOMTokenList::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DeviceOrientationEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DeviceOrientationEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDeviceOrientationEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Document");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Document");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDocument::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DocumentTimeline");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DocumentTimeline");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDocumentTimeline::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "DocumentType");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "DocumentType");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cDocumentType::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Element");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Element");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "ErrorEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "ErrorEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cErrorEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Event");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Event");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "EventTarget");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "EventTarget");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cEventTarget::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "FetchInternal");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "FetchInternal");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cFetchInternal::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "FocusEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "FocusEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cFocusEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccAccessibility");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccAccessibility");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccAccessibility::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccAccountInfo");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccAccountInfo");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccAccountInfo::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccAudioConfigArray");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccAudioConfigArray");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccAudioConfigArray::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccAudioConfig");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccAudioConfig");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccAudioConfig::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vcc");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vcc");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vcc::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccDeepLinkEventTarget");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccDeepLinkEventTarget");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccDeepLinkEventTarget::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccPlatformService");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccPlatformService");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccPlatformService::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccRuntime");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccRuntime");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccRuntime::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccRuntimeEventTarget");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccRuntimeEventTarget");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccRuntimeEventTarget::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccSettings");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccSettings");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccSettings::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccStorage");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccStorage");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccStorage::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccSystem");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccSystem");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccSystem::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "H5vccTraceEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "H5vccTraceEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cH5vccTraceEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLAnchorElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLAnchorElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLAnchorElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLBRElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLBRElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLBRElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLBodyElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLBodyElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLBodyElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLCollection");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLCollection");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLCollection::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLDivElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLDivElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLDivElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLHeadElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLHeadElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLHeadElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLHeadingElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLHeadingElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLHeadingElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLHtmlElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLHtmlElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLHtmlElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLImageElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLImageElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLImageElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLLinkElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLLinkElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLLinkElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLMediaElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLMediaElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLMediaElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLMetaElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLMetaElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLMetaElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLParagraphElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLParagraphElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLParagraphElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLScriptElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLScriptElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLScriptElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLSpanElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLSpanElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLSpanElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLStyleElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLStyleElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLStyleElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLTitleElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLTitleElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLTitleElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLUnknownElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLUnknownElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLUnknownElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "HTMLVideoElement");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "HTMLVideoElement");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHTMLVideoElement::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "History");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "History");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cHistory::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "InputEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "InputEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cInputEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "KeyboardEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "KeyboardEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cKeyboardEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Keyframe");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Keyframe");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cKeyframe::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "KeyframeEffectReadOnly");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "KeyframeEffectReadOnly");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cKeyframeEffectReadOnly::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Location");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Location");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cLocation::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaDeviceInfo");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaDeviceInfo");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaDeviceInfo::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaDevices");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaDevices");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaDevices::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaEncryptedEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaEncryptedEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaEncryptedEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaError");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaError");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaError::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaKeyMessageEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaKeyMessageEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaKeyMessageEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaKeySession");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaKeySession");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaKeySession::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaKeyStatusMap");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaKeyStatusMap");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaKeyStatusMap::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaKeySystemAccess");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaKeySystemAccess");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaKeySystemAccess::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaKeys");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaKeys");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaKeys::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaList");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaList");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaList::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaMetadata");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaMetadata");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaMetadata::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaQueryList");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaQueryList");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaQueryList::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaRecorder");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaRecorder");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaRecorder::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaSessionActionDetails");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaSessionActionDetails");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaSessionActionDetails::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaSession");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaSession");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaSession::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaSource");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaSource");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaSource::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaStream");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaStream");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaStream::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MediaStreamTrack");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MediaStreamTrack");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMediaStreamTrack::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MessageEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MessageEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMessageEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MimeTypeArray");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MimeTypeArray");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMimeTypeArray::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MouseEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MouseEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMouseEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MutationObserver");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MutationObserver");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMutationObserver::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "MutationRecord");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "MutationRecord");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cMutationRecord::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "NamedNodeMap");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "NamedNodeMap");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cNamedNodeMap::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Navigator");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Navigator");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cNavigator::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Node");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Node");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cNode::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "NodeList");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "NodeList");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cNodeList::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Performance");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Performance");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cPerformance::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "PerformanceTiming");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "PerformanceTiming");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cPerformanceTiming::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "PluginArray");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "PluginArray");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cPluginArray::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "PointerEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "PointerEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cPointerEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "ProgressEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "ProgressEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cProgressEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Screen");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Screen");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cScreen::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Screenshot");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Screenshot");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cScreenshot::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SecurityPolicyViolationEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SecurityPolicyViolationEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSecurityPolicyViolationEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SourceBuffer");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SourceBuffer");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSourceBuffer::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SourceBufferList");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SourceBufferList");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSourceBufferList::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SpeechRecognitionAlternative");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SpeechRecognitionAlternative");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSpeechRecognitionAlternative::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SpeechRecognition");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SpeechRecognition");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSpeechRecognition::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SpeechRecognitionError");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SpeechRecognitionError");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSpeechRecognitionError::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SpeechRecognitionEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SpeechRecognitionEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSpeechRecognitionEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SpeechRecognitionResult");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SpeechRecognitionResult");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSpeechRecognitionResult::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SpeechRecognitionResultList");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SpeechRecognitionResultList");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSpeechRecognitionResultList::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SpeechSynthesis");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SpeechSynthesis");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSpeechSynthesis::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SpeechSynthesisErrorEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SpeechSynthesisErrorEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSpeechSynthesisErrorEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SpeechSynthesisEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SpeechSynthesisEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSpeechSynthesisEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SpeechSynthesisUtterance");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SpeechSynthesisUtterance");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSpeechSynthesisUtterance::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SpeechSynthesisVoice");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SpeechSynthesisVoice");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSpeechSynthesisVoice::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Storage");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Storage");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cStorage::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "StorageEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "StorageEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cStorageEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "StyleSheet");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "StyleSheet");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cStyleSheet::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "StyleSheetList");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "StyleSheetList");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cStyleSheetList::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "SystemCaptionSettings");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "SystemCaptionSettings");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cSystemCaptionSettings::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Text");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Text");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cText::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "TimeRanges");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "TimeRanges");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cTimeRanges::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "TrackDefault");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "TrackDefault");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cTrackDefault::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "TrackDefaultList");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "TrackDefaultList");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cTrackDefaultList::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "TrackEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "TrackEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cTrackEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "TransitionEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "TransitionEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cTransitionEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "UIEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "UIEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cUIEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "URL");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "URL");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cURL::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "VideoPlaybackQuality");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "VideoPlaybackQuality");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cVideoPlaybackQuality::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "VideoTrack");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "VideoTrack");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cVideoTrack::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "VideoTrackList");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "VideoTrackList");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cVideoTrackList::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "WebSocket");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "WebSocket");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cWebSocket::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "WheelEvent");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "WheelEvent");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cWheelEvent::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "Window");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "Window");
      instance_template->Set(
          name,
          function_template
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "XMLDocument");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "XMLDocument");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cXMLDocument::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "XMLHttpRequest");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "XMLHttpRequest");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cXMLHttpRequest::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "XMLHttpRequestEventTarget");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "XMLHttpRequestEventTarget");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cXMLHttpRequestEventTarget::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "XMLHttpRequestUpload");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "XMLHttpRequestUpload");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cXMLHttpRequestUpload::GetTemplate(isolate)
      );
    }

  }
  {
    // The name of the property is the identifier of the attribute.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "XMLSerializer");

    // The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]:
    // true, [[Configurable]]: configurable }, where: configurable is false if
    // the attribute was declared with the [Unforgeable] extended attribute and
    // true otherwise;
    bool configurable = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        configurable ? v8::None : v8::DontDelete);

    // G is the attribute getter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property;
    // and
    //
    // S is the attribute setter created given the attribute, the interface, and
    // the relevant Realm of the object that is the location of the property.
    {
      v8::Local<v8::String> name = NewInternalString(
          isolate,
          "XMLSerializer");
      instance_template->Set(
          name,
          // Note that we use "attribute.interface_name", and not
          // "attribute.idl_name", because of named constructors.
          V8cXMLSerializer::GetTemplate(isolate)
      );
    }

  }

  // https://heycam.github.io/webidl/#es-operations
  // 3.6.8. Operations
  //
  // For each unique identifier of an exposed operation defined on the
  // interface, there must exist a corresponding property, unless the effective
  // overload set for that identifier and operation and with an argument count
  // of 0 has no entries.
  //
  // The characteristics of this property are as follows:
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "atob");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, atobMethod);
    method_template->RemovePrototype();
    method_template->SetLength(1);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "btoa");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, btoaMethod);
    method_template->RemovePrototype();
    method_template->SetLength(1);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "cancelAnimationFrame");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, cancelAnimationFrameMethod);
    method_template->RemovePrototype();
    method_template->SetLength(1);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "clearInterval");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, clearIntervalMethod);
    method_template->RemovePrototype();
    method_template->SetLength(1);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "clearTimeout");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, clearTimeoutMethod);
    method_template->RemovePrototype();
    method_template->SetLength(1);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "close");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, closeMethod);
    method_template->RemovePrototype();
    method_template->SetLength(0);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "gc");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, gcMethod);
    method_template->RemovePrototype();
    method_template->SetLength(0);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "getComputedStyle");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, getComputedStyleMethod);
    method_template->RemovePrototype();
    method_template->SetLength(1);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "matchMedia");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, matchMediaMethod);
    method_template->RemovePrototype();
    method_template->SetLength(1);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "minimize");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, minimizeMethod);
    method_template->RemovePrototype();
    method_template->SetLength(0);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "requestAnimationFrame");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, requestAnimationFrameMethod);
    method_template->RemovePrototype();
    method_template->SetLength(1);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "screenshot");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, screenshotMethod);
    method_template->RemovePrototype();
    method_template->SetLength(0);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "setInterval");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, setIntervalMethod);
    method_template->RemovePrototype();
    method_template->SetLength(1);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }
  {
    // The name of the property is the identifier.
    v8::Local<v8::String> name = NewInternalString(
        isolate,
        "setTimeout");

    // The property has attributes { [[Writable]]: B, [[Enumerable]]: true,
    // [[Configurable]]: B }, where B is false if the operation is unforgeable
    // on the interface, and true otherwise.
    bool B = true;
    v8::PropertyAttribute attributes = static_cast<v8::PropertyAttribute>(
        B ? v8::None : (v8::ReadOnly | v8::DontDelete));

    v8::Local<v8::FunctionTemplate> method_template =
        v8::FunctionTemplate::New(isolate, setTimeoutMethod);
    method_template->RemovePrototype();
    method_template->SetLength(1);

    // The location of the property is determined as follows:
    // Otherwise, if the operation is unforgeable on the interface or if the
    // interface was declared with the [Global] extended attribute, then the
    // property exists on every object that implements the interface.
    instance_template->
        Set(name, method_template);

    // The value of the property is the result of creating an operation function
    // given the operation, the interface, and the relevant Realm of the object
    // that is the location of the property.

    // Note: that is, even if an includes statement was used to make an
    // operation available on the interface, we pass in the interface which
    // includes the interface mixin, and not the interface mixin on which the
    // operation was originally declared.
  }

  // https://heycam.github.io/webidl/#es-stringifier
  // 3.6.8.2. Stringifiers
  prototype_template->Set(
      v8::Symbol::GetToStringTag(isolate),
      NewInternalString(isolate, "Window"),
      static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontEnum));




  {
    v8::IndexedPropertyHandlerConfiguration indexed_property_handler_configuration = {
      IndexedPropertyGetterCallback,
      nullptr,
      IndexedPropertyDescriptorCallback,
      nullptr,
      IndexedPropertyEnumeratorCallback,
      IndexedPropertyDefinerCallback
    };
    instance_template->SetHandler(indexed_property_handler_configuration);
  }

}

}  // namespace


// The global interface is special.  Just give them the global object proxy.
v8::Local<v8::Object> V8cWindow::CreateWrapper(
    v8::Isolate* isolate, const scoped_refptr<Wrappable>&) {
  return isolate->GetCurrentContext()->Global();
}


v8::Local<v8::FunctionTemplate> V8cWindow::GetTemplate(v8::Isolate* isolate) {
  V8cGlobalEnvironment* global_environment = V8cGlobalEnvironment::GetFromIsolate(isolate);
  if (!global_environment->HasInterfaceData(kInterfaceUniqueId)) {
    InitializeTemplate(isolate);
  }
  return global_environment->GetInterfaceData(kInterfaceUniqueId);
}


}  // namespace dom
}  // namespace cobalt


namespace cobalt {
namespace script {
namespace v8c {

template <typename GlobalInterface>
void V8cGlobalEnvironment::CreateGlobalObject(
    const scoped_refptr<GlobalInterface>& global_interface,
    EnvironmentSettings* environment_settings) {
  TRACE_EVENT0("cobalt::script", "V8cGlobalEnvironment::CreateGlobalObject()");
  // Intentionally not an |EntryScope|, since the context doesn't exist yet.
  v8::Isolate::Scope isolate_scope(isolate_);
  v8::HandleScope handle_scope(isolate_);
  v8::Local<v8::ObjectTemplate> global_object_template = V8cWindow::GetTemplate(isolate_)->InstanceTemplate();

  v8::Local<v8::Context> context =
      v8::Context::New(isolate_, nullptr, global_object_template);
  context_.Reset(isolate_, context);
  v8::Context::Scope context_scope(context);

  global_wrappable_ = global_interface;

  DCHECK(!environment_settings_);
  DCHECK(environment_settings);
  environment_settings_ = environment_settings;
  EvaluateAutomatics();

  v8::Local<v8::Object> global_object = context->Global();
  new WrapperPrivate(isolate_, global_interface, global_object);

  auto actual_global_object = global_object->GetPrototype()->ToObject();
  new WrapperPrivate(isolate_, global_interface, actual_global_object);

  wrapper_factory_->RegisterWrappableType(
      Animatable::AnimatableWrappableType(),
      base::Bind(V8cAnimatable::CreateWrapper),
      base::Bind(V8cAnimatable::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Animation::AnimationWrappableType(),
      base::Bind(V8cAnimation::CreateWrapper),
      base::Bind(V8cAnimation::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      AnimationEffectReadOnly::AnimationEffectReadOnlyWrappableType(),
      base::Bind(V8cAnimationEffectReadOnly::CreateWrapper),
      base::Bind(V8cAnimationEffectReadOnly::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      AnimationEffectTimingReadOnly::AnimationEffectTimingReadOnlyWrappableType(),
      base::Bind(V8cAnimationEffectTimingReadOnly::CreateWrapper),
      base::Bind(V8cAnimationEffectTimingReadOnly::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      AnimationEvent::AnimationEventWrappableType(),
      base::Bind(V8cAnimationEvent::CreateWrapper),
      base::Bind(V8cAnimationEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      AnimationTimeline::AnimationTimelineWrappableType(),
      base::Bind(V8cAnimationTimeline::CreateWrapper),
      base::Bind(V8cAnimationTimeline::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Attr::AttrWrappableType(),
      base::Bind(V8cAttr::CreateWrapper),
      base::Bind(V8cAttr::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      AudioBuffer::AudioBufferWrappableType(),
      base::Bind(V8cAudioBuffer::CreateWrapper),
      base::Bind(V8cAudioBuffer::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      AudioBufferSourceNode::AudioBufferSourceNodeWrappableType(),
      base::Bind(V8cAudioBufferSourceNode::CreateWrapper),
      base::Bind(V8cAudioBufferSourceNode::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      AudioContext::AudioContextWrappableType(),
      base::Bind(V8cAudioContext::CreateWrapper),
      base::Bind(V8cAudioContext::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      AudioDestinationNode::AudioDestinationNodeWrappableType(),
      base::Bind(V8cAudioDestinationNode::CreateWrapper),
      base::Bind(V8cAudioDestinationNode::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      AudioNode::AudioNodeWrappableType(),
      base::Bind(V8cAudioNode::CreateWrapper),
      base::Bind(V8cAudioNode::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      AudioTrack::AudioTrackWrappableType(),
      base::Bind(V8cAudioTrack::CreateWrapper),
      base::Bind(V8cAudioTrack::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      AudioTrackList::AudioTrackListWrappableType(),
      base::Bind(V8cAudioTrackList::CreateWrapper),
      base::Bind(V8cAudioTrackList::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Blob::BlobWrappableType(),
      base::Bind(V8cBlob::CreateWrapper),
      base::Bind(V8cBlob::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      BlobEvent::BlobEventWrappableType(),
      base::Bind(V8cBlobEvent::CreateWrapper),
      base::Bind(V8cBlobEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CDATASection::CDATASectionWrappableType(),
      base::Bind(V8cCDATASection::CreateWrapper),
      base::Bind(V8cCDATASection::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CSS::CSSWrappableType(),
      base::Bind(V8cCSS::CreateWrapper),
      base::Bind(V8cCSS::GetTemplate));
#if defined(ENABLE_DEBUGGER)
  wrapper_factory_->RegisterWrappableType(
      CSSAgent::CSSAgentWrappableType(),
      base::Bind(V8cCSSAgent::CreateWrapper),
      base::Bind(V8cCSSAgent::GetTemplate));
#endif  // defined(ENABLE_DEBUGGER)
  wrapper_factory_->RegisterWrappableType(
      CSSConditionRule::CSSConditionRuleWrappableType(),
      base::Bind(V8cCSSConditionRule::CreateWrapper),
      base::Bind(V8cCSSConditionRule::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CSSFontFaceRule::CSSFontFaceRuleWrappableType(),
      base::Bind(V8cCSSFontFaceRule::CreateWrapper),
      base::Bind(V8cCSSFontFaceRule::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CSSGroupingRule::CSSGroupingRuleWrappableType(),
      base::Bind(V8cCSSGroupingRule::CreateWrapper),
      base::Bind(V8cCSSGroupingRule::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CSSKeyframeRule::CSSKeyframeRuleWrappableType(),
      base::Bind(V8cCSSKeyframeRule::CreateWrapper),
      base::Bind(V8cCSSKeyframeRule::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CSSKeyframesRule::CSSKeyframesRuleWrappableType(),
      base::Bind(V8cCSSKeyframesRule::CreateWrapper),
      base::Bind(V8cCSSKeyframesRule::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CSSMediaRule::CSSMediaRuleWrappableType(),
      base::Bind(V8cCSSMediaRule::CreateWrapper),
      base::Bind(V8cCSSMediaRule::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CSSRule::CSSRuleWrappableType(),
      base::Bind(V8cCSSRule::CreateWrapper),
      base::Bind(V8cCSSRule::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CSSRuleList::CSSRuleListWrappableType(),
      base::Bind(V8cCSSRuleList::CreateWrapper),
      base::Bind(V8cCSSRuleList::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CSSStyleDeclaration::CSSStyleDeclarationWrappableType(),
      base::Bind(V8cCSSStyleDeclaration::CreateWrapper),
      base::Bind(V8cCSSStyleDeclaration::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CSSStyleRule::CSSStyleRuleWrappableType(),
      base::Bind(V8cCSSStyleRule::CreateWrapper),
      base::Bind(V8cCSSStyleRule::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CSSStyleSheet::CSSStyleSheetWrappableType(),
      base::Bind(V8cCSSStyleSheet::CreateWrapper),
      base::Bind(V8cCSSStyleSheet::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CValKeyList::CValKeyListWrappableType(),
      base::Bind(V8cCValKeyList::CreateWrapper),
      base::Bind(V8cCValKeyList::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CValView::CValViewWrappableType(),
      base::Bind(V8cCValView::CreateWrapper),
      base::Bind(V8cCValView::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Camera3D::Camera3DWrappableType(),
      base::Bind(V8cCamera3D::CreateWrapper),
      base::Bind(V8cCamera3D::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CharacterData::CharacterDataWrappableType(),
      base::Bind(V8cCharacterData::CreateWrapper),
      base::Bind(V8cCharacterData::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CloseEvent::CloseEventWrappableType(),
      base::Bind(V8cCloseEvent::CreateWrapper),
      base::Bind(V8cCloseEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Comment::CommentWrappableType(),
      base::Bind(V8cComment::CreateWrapper),
      base::Bind(V8cComment::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Console::ConsoleWrappableType(),
      base::Bind(V8cConsole::CreateWrapper),
      base::Bind(V8cConsole::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Crypto::CryptoWrappableType(),
      base::Bind(V8cCrypto::CreateWrapper),
      base::Bind(V8cCrypto::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      CustomEvent::CustomEventWrappableType(),
      base::Bind(V8cCustomEvent::CreateWrapper),
      base::Bind(V8cCustomEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      DOMException::DOMExceptionWrappableType(),
      base::Bind(V8cDOMException::CreateWrapper),
      base::Bind(V8cDOMException::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      DOMImplementation::DOMImplementationWrappableType(),
      base::Bind(V8cDOMImplementation::CreateWrapper),
      base::Bind(V8cDOMImplementation::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      DOMParser::DOMParserWrappableType(),
      base::Bind(V8cDOMParser::CreateWrapper),
      base::Bind(V8cDOMParser::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      DOMRect::DOMRectWrappableType(),
      base::Bind(V8cDOMRect::CreateWrapper),
      base::Bind(V8cDOMRect::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      DOMRectList::DOMRectListWrappableType(),
      base::Bind(V8cDOMRectList::CreateWrapper),
      base::Bind(V8cDOMRectList::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      DOMRectReadOnly::DOMRectReadOnlyWrappableType(),
      base::Bind(V8cDOMRectReadOnly::CreateWrapper),
      base::Bind(V8cDOMRectReadOnly::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      DOMStringMap::DOMStringMapWrappableType(),
      base::Bind(V8cDOMStringMap::CreateWrapper),
      base::Bind(V8cDOMStringMap::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      DOMTokenList::DOMTokenListWrappableType(),
      base::Bind(V8cDOMTokenList::CreateWrapper),
      base::Bind(V8cDOMTokenList::GetTemplate));
#if defined(ENABLE_DEBUGGER)
  wrapper_factory_->RegisterWrappableType(
      DebugBackend::DebugBackendWrappableType(),
      base::Bind(V8cDebugBackend::CreateWrapper),
      base::Bind(V8cDebugBackend::GetTemplate));
#endif  // defined(ENABLE_DEBUGGER)
#if defined(ENABLE_DEBUGGER)
  wrapper_factory_->RegisterWrappableType(
      DebugHub::DebugHubWrappableType(),
      base::Bind(V8cDebugHub::CreateWrapper),
      base::Bind(V8cDebugHub::GetTemplate));
#endif  // defined(ENABLE_DEBUGGER)
#if defined(ENABLE_DEBUGGER)
  wrapper_factory_->RegisterWrappableType(
      DebuggerEventTarget::DebuggerEventTargetWrappableType(),
      base::Bind(V8cDebuggerEventTarget::CreateWrapper),
      base::Bind(V8cDebuggerEventTarget::GetTemplate));
#endif  // defined(ENABLE_DEBUGGER)
  wrapper_factory_->RegisterWrappableType(
      DeviceOrientationEvent::DeviceOrientationEventWrappableType(),
      base::Bind(V8cDeviceOrientationEvent::CreateWrapper),
      base::Bind(V8cDeviceOrientationEvent::GetTemplate));
#if defined(DIAL_SERVER)
  wrapper_factory_->RegisterWrappableType(
      DialHttpRequest::DialHttpRequestWrappableType(),
      base::Bind(V8cDialHttpRequest::CreateWrapper),
      base::Bind(V8cDialHttpRequest::GetTemplate));
#endif  // defined(DIAL_SERVER)
#if defined(DIAL_SERVER)
  wrapper_factory_->RegisterWrappableType(
      DialHttpResponse::DialHttpResponseWrappableType(),
      base::Bind(V8cDialHttpResponse::CreateWrapper),
      base::Bind(V8cDialHttpResponse::GetTemplate));
#endif  // defined(DIAL_SERVER)
#if defined(DIAL_SERVER)
  wrapper_factory_->RegisterWrappableType(
      DialServer::DialServerWrappableType(),
      base::Bind(V8cDialServer::CreateWrapper),
      base::Bind(V8cDialServer::GetTemplate));
#endif  // defined(DIAL_SERVER)
  wrapper_factory_->RegisterWrappableType(
      Document::DocumentWrappableType(),
      base::Bind(V8cDocument::CreateWrapper),
      base::Bind(V8cDocument::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      DocumentTimeline::DocumentTimelineWrappableType(),
      base::Bind(V8cDocumentTimeline::CreateWrapper),
      base::Bind(V8cDocumentTimeline::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      DocumentType::DocumentTypeWrappableType(),
      base::Bind(V8cDocumentType::CreateWrapper),
      base::Bind(V8cDocumentType::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Element::ElementWrappableType(),
      base::Bind(V8cElement::CreateWrapper),
      base::Bind(V8cElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      ErrorEvent::ErrorEventWrappableType(),
      base::Bind(V8cErrorEvent::CreateWrapper),
      base::Bind(V8cErrorEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Event::EventWrappableType(),
      base::Bind(V8cEvent::CreateWrapper),
      base::Bind(V8cEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      EventTarget::EventTargetWrappableType(),
      base::Bind(V8cEventTarget::CreateWrapper),
      base::Bind(V8cEventTarget::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      FetchInternal::FetchInternalWrappableType(),
      base::Bind(V8cFetchInternal::CreateWrapper),
      base::Bind(V8cFetchInternal::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      FocusEvent::FocusEventWrappableType(),
      base::Bind(V8cFocusEvent::CreateWrapper),
      base::Bind(V8cFocusEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      H5vcc::H5vccWrappableType(),
      base::Bind(V8cH5vcc::CreateWrapper),
      base::Bind(V8cH5vcc::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      H5vccAccessibility::H5vccAccessibilityWrappableType(),
      base::Bind(V8cH5vccAccessibility::CreateWrapper),
      base::Bind(V8cH5vccAccessibility::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      H5vccAccountInfo::H5vccAccountInfoWrappableType(),
      base::Bind(V8cH5vccAccountInfo::CreateWrapper),
      base::Bind(V8cH5vccAccountInfo::GetTemplate));
#if defined(COBALT_ENABLE_ACCOUNT_MANAGER)
  wrapper_factory_->RegisterWrappableType(
      H5vccAccountManager::H5vccAccountManagerWrappableType(),
      base::Bind(V8cH5vccAccountManager::CreateWrapper),
      base::Bind(V8cH5vccAccountManager::GetTemplate));
#endif  // defined(COBALT_ENABLE_ACCOUNT_MANAGER)
  wrapper_factory_->RegisterWrappableType(
      H5vccAudioConfig::H5vccAudioConfigWrappableType(),
      base::Bind(V8cH5vccAudioConfig::CreateWrapper),
      base::Bind(V8cH5vccAudioConfig::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      H5vccAudioConfigArray::H5vccAudioConfigArrayWrappableType(),
      base::Bind(V8cH5vccAudioConfigArray::CreateWrapper),
      base::Bind(V8cH5vccAudioConfigArray::GetTemplate));
#if defined(COBALT_ENABLE_CRASH_LOG)
  wrapper_factory_->RegisterWrappableType(
      H5vccCrashLog::H5vccCrashLogWrappableType(),
      base::Bind(V8cH5vccCrashLog::CreateWrapper),
      base::Bind(V8cH5vccCrashLog::GetTemplate));
#endif  // defined(COBALT_ENABLE_CRASH_LOG)
  wrapper_factory_->RegisterWrappableType(
      H5vccDeepLinkEventTarget::H5vccDeepLinkEventTargetWrappableType(),
      base::Bind(V8cH5vccDeepLinkEventTarget::CreateWrapper),
      base::Bind(V8cH5vccDeepLinkEventTarget::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      H5vccPlatformService::H5vccPlatformServiceWrappableType(),
      base::Bind(V8cH5vccPlatformService::CreateWrapper),
      base::Bind(V8cH5vccPlatformService::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      H5vccRuntime::H5vccRuntimeWrappableType(),
      base::Bind(V8cH5vccRuntime::CreateWrapper),
      base::Bind(V8cH5vccRuntime::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      H5vccRuntimeEventTarget::H5vccRuntimeEventTargetWrappableType(),
      base::Bind(V8cH5vccRuntimeEventTarget::CreateWrapper),
      base::Bind(V8cH5vccRuntimeEventTarget::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      H5vccSettings::H5vccSettingsWrappableType(),
      base::Bind(V8cH5vccSettings::CreateWrapper),
      base::Bind(V8cH5vccSettings::GetTemplate));
#if defined(COBALT_ENABLE_SSO)
  wrapper_factory_->RegisterWrappableType(
      H5vccSso::H5vccSsoWrappableType(),
      base::Bind(V8cH5vccSso::CreateWrapper),
      base::Bind(V8cH5vccSso::GetTemplate));
#endif  // defined(COBALT_ENABLE_SSO)
  wrapper_factory_->RegisterWrappableType(
      H5vccStorage::H5vccStorageWrappableType(),
      base::Bind(V8cH5vccStorage::CreateWrapper),
      base::Bind(V8cH5vccStorage::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      H5vccSystem::H5vccSystemWrappableType(),
      base::Bind(V8cH5vccSystem::CreateWrapper),
      base::Bind(V8cH5vccSystem::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      H5vccTraceEvent::H5vccTraceEventWrappableType(),
      base::Bind(V8cH5vccTraceEvent::CreateWrapper),
      base::Bind(V8cH5vccTraceEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLAnchorElement::HTMLAnchorElementWrappableType(),
      base::Bind(V8cHTMLAnchorElement::CreateWrapper),
      base::Bind(V8cHTMLAnchorElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLBRElement::HTMLBRElementWrappableType(),
      base::Bind(V8cHTMLBRElement::CreateWrapper),
      base::Bind(V8cHTMLBRElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLBodyElement::HTMLBodyElementWrappableType(),
      base::Bind(V8cHTMLBodyElement::CreateWrapper),
      base::Bind(V8cHTMLBodyElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLCollection::HTMLCollectionWrappableType(),
      base::Bind(V8cHTMLCollection::CreateWrapper),
      base::Bind(V8cHTMLCollection::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLDivElement::HTMLDivElementWrappableType(),
      base::Bind(V8cHTMLDivElement::CreateWrapper),
      base::Bind(V8cHTMLDivElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLElement::HTMLElementWrappableType(),
      base::Bind(V8cHTMLElement::CreateWrapper),
      base::Bind(V8cHTMLElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLHeadElement::HTMLHeadElementWrappableType(),
      base::Bind(V8cHTMLHeadElement::CreateWrapper),
      base::Bind(V8cHTMLHeadElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLHeadingElement::HTMLHeadingElementWrappableType(),
      base::Bind(V8cHTMLHeadingElement::CreateWrapper),
      base::Bind(V8cHTMLHeadingElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLHtmlElement::HTMLHtmlElementWrappableType(),
      base::Bind(V8cHTMLHtmlElement::CreateWrapper),
      base::Bind(V8cHTMLHtmlElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLImageElement::HTMLImageElementWrappableType(),
      base::Bind(V8cHTMLImageElement::CreateWrapper),
      base::Bind(V8cHTMLImageElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLLinkElement::HTMLLinkElementWrappableType(),
      base::Bind(V8cHTMLLinkElement::CreateWrapper),
      base::Bind(V8cHTMLLinkElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLMediaElement::HTMLMediaElementWrappableType(),
      base::Bind(V8cHTMLMediaElement::CreateWrapper),
      base::Bind(V8cHTMLMediaElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLMetaElement::HTMLMetaElementWrappableType(),
      base::Bind(V8cHTMLMetaElement::CreateWrapper),
      base::Bind(V8cHTMLMetaElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLParagraphElement::HTMLParagraphElementWrappableType(),
      base::Bind(V8cHTMLParagraphElement::CreateWrapper),
      base::Bind(V8cHTMLParagraphElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLScriptElement::HTMLScriptElementWrappableType(),
      base::Bind(V8cHTMLScriptElement::CreateWrapper),
      base::Bind(V8cHTMLScriptElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLSpanElement::HTMLSpanElementWrappableType(),
      base::Bind(V8cHTMLSpanElement::CreateWrapper),
      base::Bind(V8cHTMLSpanElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLStyleElement::HTMLStyleElementWrappableType(),
      base::Bind(V8cHTMLStyleElement::CreateWrapper),
      base::Bind(V8cHTMLStyleElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLTitleElement::HTMLTitleElementWrappableType(),
      base::Bind(V8cHTMLTitleElement::CreateWrapper),
      base::Bind(V8cHTMLTitleElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLUnknownElement::HTMLUnknownElementWrappableType(),
      base::Bind(V8cHTMLUnknownElement::CreateWrapper),
      base::Bind(V8cHTMLUnknownElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      HTMLVideoElement::HTMLVideoElementWrappableType(),
      base::Bind(V8cHTMLVideoElement::CreateWrapper),
      base::Bind(V8cHTMLVideoElement::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      History::HistoryWrappableType(),
      base::Bind(V8cHistory::CreateWrapper),
      base::Bind(V8cHistory::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      InputEvent::InputEventWrappableType(),
      base::Bind(V8cInputEvent::CreateWrapper),
      base::Bind(V8cInputEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      KeyboardEvent::KeyboardEventWrappableType(),
      base::Bind(V8cKeyboardEvent::CreateWrapper),
      base::Bind(V8cKeyboardEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Keyframe::KeyframeWrappableType(),
      base::Bind(V8cKeyframe::CreateWrapper),
      base::Bind(V8cKeyframe::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      KeyframeEffectReadOnly::KeyframeEffectReadOnlyWrappableType(),
      base::Bind(V8cKeyframeEffectReadOnly::CreateWrapper),
      base::Bind(V8cKeyframeEffectReadOnly::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Location::LocationWrappableType(),
      base::Bind(V8cLocation::CreateWrapper),
      base::Bind(V8cLocation::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaDeviceInfo::MediaDeviceInfoWrappableType(),
      base::Bind(V8cMediaDeviceInfo::CreateWrapper),
      base::Bind(V8cMediaDeviceInfo::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaDevices::MediaDevicesWrappableType(),
      base::Bind(V8cMediaDevices::CreateWrapper),
      base::Bind(V8cMediaDevices::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaEncryptedEvent::MediaEncryptedEventWrappableType(),
      base::Bind(V8cMediaEncryptedEvent::CreateWrapper),
      base::Bind(V8cMediaEncryptedEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaError::MediaErrorWrappableType(),
      base::Bind(V8cMediaError::CreateWrapper),
      base::Bind(V8cMediaError::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaKeyMessageEvent::MediaKeyMessageEventWrappableType(),
      base::Bind(V8cMediaKeyMessageEvent::CreateWrapper),
      base::Bind(V8cMediaKeyMessageEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaKeySession::MediaKeySessionWrappableType(),
      base::Bind(V8cMediaKeySession::CreateWrapper),
      base::Bind(V8cMediaKeySession::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaKeyStatusMap::MediaKeyStatusMapWrappableType(),
      base::Bind(V8cMediaKeyStatusMap::CreateWrapper),
      base::Bind(V8cMediaKeyStatusMap::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaKeySystemAccess::MediaKeySystemAccessWrappableType(),
      base::Bind(V8cMediaKeySystemAccess::CreateWrapper),
      base::Bind(V8cMediaKeySystemAccess::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaKeys::MediaKeysWrappableType(),
      base::Bind(V8cMediaKeys::CreateWrapper),
      base::Bind(V8cMediaKeys::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaList::MediaListWrappableType(),
      base::Bind(V8cMediaList::CreateWrapper),
      base::Bind(V8cMediaList::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaMetadata::MediaMetadataWrappableType(),
      base::Bind(V8cMediaMetadata::CreateWrapper),
      base::Bind(V8cMediaMetadata::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaQueryList::MediaQueryListWrappableType(),
      base::Bind(V8cMediaQueryList::CreateWrapper),
      base::Bind(V8cMediaQueryList::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaRecorder::MediaRecorderWrappableType(),
      base::Bind(V8cMediaRecorder::CreateWrapper),
      base::Bind(V8cMediaRecorder::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaSession::MediaSessionWrappableType(),
      base::Bind(V8cMediaSession::CreateWrapper),
      base::Bind(V8cMediaSession::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaSessionActionDetails::MediaSessionActionDetailsWrappableType(),
      base::Bind(V8cMediaSessionActionDetails::CreateWrapper),
      base::Bind(V8cMediaSessionActionDetails::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaSource::MediaSourceWrappableType(),
      base::Bind(V8cMediaSource::CreateWrapper),
      base::Bind(V8cMediaSource::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaStream::MediaStreamWrappableType(),
      base::Bind(V8cMediaStream::CreateWrapper),
      base::Bind(V8cMediaStream::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MediaStreamTrack::MediaStreamTrackWrappableType(),
      base::Bind(V8cMediaStreamTrack::CreateWrapper),
      base::Bind(V8cMediaStreamTrack::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MemoryInfo::MemoryInfoWrappableType(),
      base::Bind(V8cMemoryInfo::CreateWrapper),
      base::Bind(V8cMemoryInfo::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MessageEvent::MessageEventWrappableType(),
      base::Bind(V8cMessageEvent::CreateWrapper),
      base::Bind(V8cMessageEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MimeTypeArray::MimeTypeArrayWrappableType(),
      base::Bind(V8cMimeTypeArray::CreateWrapper),
      base::Bind(V8cMimeTypeArray::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MouseEvent::MouseEventWrappableType(),
      base::Bind(V8cMouseEvent::CreateWrapper),
      base::Bind(V8cMouseEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MutationObserver::MutationObserverWrappableType(),
      base::Bind(V8cMutationObserver::CreateWrapper),
      base::Bind(V8cMutationObserver::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      MutationRecord::MutationRecordWrappableType(),
      base::Bind(V8cMutationRecord::CreateWrapper),
      base::Bind(V8cMutationRecord::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      NamedNodeMap::NamedNodeMapWrappableType(),
      base::Bind(V8cNamedNodeMap::CreateWrapper),
      base::Bind(V8cNamedNodeMap::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Navigator::NavigatorWrappableType(),
      base::Bind(V8cNavigator::CreateWrapper),
      base::Bind(V8cNavigator::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Node::NodeWrappableType(),
      base::Bind(V8cNode::CreateWrapper),
      base::Bind(V8cNode::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      NodeList::NodeListWrappableType(),
      base::Bind(V8cNodeList::CreateWrapper),
      base::Bind(V8cNodeList::GetTemplate));
#if defined(COBALT_ENABLE_ON_SCREEN_KEYBOARD)
  wrapper_factory_->RegisterWrappableType(
      OnScreenKeyboard::OnScreenKeyboardWrappableType(),
      base::Bind(V8cOnScreenKeyboard::CreateWrapper),
      base::Bind(V8cOnScreenKeyboard::GetTemplate));
#endif  // defined(COBALT_ENABLE_ON_SCREEN_KEYBOARD)
  wrapper_factory_->RegisterWrappableType(
      Performance::PerformanceWrappableType(),
      base::Bind(V8cPerformance::CreateWrapper),
      base::Bind(V8cPerformance::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      PerformanceTiming::PerformanceTimingWrappableType(),
      base::Bind(V8cPerformanceTiming::CreateWrapper),
      base::Bind(V8cPerformanceTiming::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      PluginArray::PluginArrayWrappableType(),
      base::Bind(V8cPluginArray::CreateWrapper),
      base::Bind(V8cPluginArray::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      PointerEvent::PointerEventWrappableType(),
      base::Bind(V8cPointerEvent::CreateWrapper),
      base::Bind(V8cPointerEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      ProgressEvent::ProgressEventWrappableType(),
      base::Bind(V8cProgressEvent::CreateWrapper),
      base::Bind(V8cProgressEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Screen::ScreenWrappableType(),
      base::Bind(V8cScreen::CreateWrapper),
      base::Bind(V8cScreen::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Screenshot::ScreenshotWrappableType(),
      base::Bind(V8cScreenshot::CreateWrapper),
      base::Bind(V8cScreenshot::GetTemplate));
#if defined(ENABLE_WEBDRIVER)
  wrapper_factory_->RegisterWrappableType(
      ScriptExecutor::ScriptExecutorWrappableType(),
      base::Bind(V8cScriptExecutor::CreateWrapper),
      base::Bind(V8cScriptExecutor::GetTemplate));
#endif  // defined(ENABLE_WEBDRIVER)
#if defined(ENABLE_WEBDRIVER)
  wrapper_factory_->RegisterWrappableType(
      ScriptExecutorParams::ScriptExecutorParamsWrappableType(),
      base::Bind(V8cScriptExecutorParams::CreateWrapper),
      base::Bind(V8cScriptExecutorParams::GetTemplate));
#endif  // defined(ENABLE_WEBDRIVER)
#if defined(ENABLE_WEBDRIVER)
  wrapper_factory_->RegisterWrappableType(
      ScriptExecutorResult::ScriptExecutorResultWrappableType(),
      base::Bind(V8cScriptExecutorResult::CreateWrapper),
      base::Bind(V8cScriptExecutorResult::GetTemplate));
#endif  // defined(ENABLE_WEBDRIVER)
  wrapper_factory_->RegisterWrappableType(
      SecurityPolicyViolationEvent::SecurityPolicyViolationEventWrappableType(),
      base::Bind(V8cSecurityPolicyViolationEvent::CreateWrapper),
      base::Bind(V8cSecurityPolicyViolationEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SourceBuffer::SourceBufferWrappableType(),
      base::Bind(V8cSourceBuffer::CreateWrapper),
      base::Bind(V8cSourceBuffer::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SourceBufferList::SourceBufferListWrappableType(),
      base::Bind(V8cSourceBufferList::CreateWrapper),
      base::Bind(V8cSourceBufferList::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SpeechRecognition::SpeechRecognitionWrappableType(),
      base::Bind(V8cSpeechRecognition::CreateWrapper),
      base::Bind(V8cSpeechRecognition::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SpeechRecognitionAlternative::SpeechRecognitionAlternativeWrappableType(),
      base::Bind(V8cSpeechRecognitionAlternative::CreateWrapper),
      base::Bind(V8cSpeechRecognitionAlternative::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SpeechRecognitionError::SpeechRecognitionErrorWrappableType(),
      base::Bind(V8cSpeechRecognitionError::CreateWrapper),
      base::Bind(V8cSpeechRecognitionError::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SpeechRecognitionEvent::SpeechRecognitionEventWrappableType(),
      base::Bind(V8cSpeechRecognitionEvent::CreateWrapper),
      base::Bind(V8cSpeechRecognitionEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SpeechRecognitionResult::SpeechRecognitionResultWrappableType(),
      base::Bind(V8cSpeechRecognitionResult::CreateWrapper),
      base::Bind(V8cSpeechRecognitionResult::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SpeechRecognitionResultList::SpeechRecognitionResultListWrappableType(),
      base::Bind(V8cSpeechRecognitionResultList::CreateWrapper),
      base::Bind(V8cSpeechRecognitionResultList::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SpeechSynthesis::SpeechSynthesisWrappableType(),
      base::Bind(V8cSpeechSynthesis::CreateWrapper),
      base::Bind(V8cSpeechSynthesis::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SpeechSynthesisErrorEvent::SpeechSynthesisErrorEventWrappableType(),
      base::Bind(V8cSpeechSynthesisErrorEvent::CreateWrapper),
      base::Bind(V8cSpeechSynthesisErrorEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SpeechSynthesisEvent::SpeechSynthesisEventWrappableType(),
      base::Bind(V8cSpeechSynthesisEvent::CreateWrapper),
      base::Bind(V8cSpeechSynthesisEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SpeechSynthesisUtterance::SpeechSynthesisUtteranceWrappableType(),
      base::Bind(V8cSpeechSynthesisUtterance::CreateWrapper),
      base::Bind(V8cSpeechSynthesisUtterance::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SpeechSynthesisVoice::SpeechSynthesisVoiceWrappableType(),
      base::Bind(V8cSpeechSynthesisVoice::CreateWrapper),
      base::Bind(V8cSpeechSynthesisVoice::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Storage::StorageWrappableType(),
      base::Bind(V8cStorage::CreateWrapper),
      base::Bind(V8cStorage::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      StorageEvent::StorageEventWrappableType(),
      base::Bind(V8cStorageEvent::CreateWrapper),
      base::Bind(V8cStorageEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      StyleSheet::StyleSheetWrappableType(),
      base::Bind(V8cStyleSheet::CreateWrapper),
      base::Bind(V8cStyleSheet::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      StyleSheetList::StyleSheetListWrappableType(),
      base::Bind(V8cStyleSheetList::CreateWrapper),
      base::Bind(V8cStyleSheetList::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      SystemCaptionSettings::SystemCaptionSettingsWrappableType(),
      base::Bind(V8cSystemCaptionSettings::CreateWrapper),
      base::Bind(V8cSystemCaptionSettings::GetTemplate));
#if defined(ENABLE_TEST_RUNNER)
  wrapper_factory_->RegisterWrappableType(
      TestRunner::TestRunnerWrappableType(),
      base::Bind(V8cTestRunner::CreateWrapper),
      base::Bind(V8cTestRunner::GetTemplate));
#endif  // defined(ENABLE_TEST_RUNNER)
  wrapper_factory_->RegisterWrappableType(
      Text::TextWrappableType(),
      base::Bind(V8cText::CreateWrapper),
      base::Bind(V8cText::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      TimeRanges::TimeRangesWrappableType(),
      base::Bind(V8cTimeRanges::CreateWrapper),
      base::Bind(V8cTimeRanges::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      TrackDefault::TrackDefaultWrappableType(),
      base::Bind(V8cTrackDefault::CreateWrapper),
      base::Bind(V8cTrackDefault::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      TrackDefaultList::TrackDefaultListWrappableType(),
      base::Bind(V8cTrackDefaultList::CreateWrapper),
      base::Bind(V8cTrackDefaultList::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      TrackEvent::TrackEventWrappableType(),
      base::Bind(V8cTrackEvent::CreateWrapper),
      base::Bind(V8cTrackEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      TransitionEvent::TransitionEventWrappableType(),
      base::Bind(V8cTransitionEvent::CreateWrapper),
      base::Bind(V8cTransitionEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      UIEvent::UIEventWrappableType(),
      base::Bind(V8cUIEvent::CreateWrapper),
      base::Bind(V8cUIEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      URL::URLWrappableType(),
      base::Bind(V8cURL::CreateWrapper),
      base::Bind(V8cURL::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      VideoPlaybackQuality::VideoPlaybackQualityWrappableType(),
      base::Bind(V8cVideoPlaybackQuality::CreateWrapper),
      base::Bind(V8cVideoPlaybackQuality::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      VideoTrack::VideoTrackWrappableType(),
      base::Bind(V8cVideoTrack::CreateWrapper),
      base::Bind(V8cVideoTrack::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      VideoTrackList::VideoTrackListWrappableType(),
      base::Bind(V8cVideoTrackList::CreateWrapper),
      base::Bind(V8cVideoTrackList::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      WebSocket::WebSocketWrappableType(),
      base::Bind(V8cWebSocket::CreateWrapper),
      base::Bind(V8cWebSocket::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      WheelEvent::WheelEventWrappableType(),
      base::Bind(V8cWheelEvent::CreateWrapper),
      base::Bind(V8cWheelEvent::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      Window::WindowWrappableType(),
      base::Bind(V8cWindow::CreateWrapper),
      base::Bind(V8cWindow::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      XMLDocument::XMLDocumentWrappableType(),
      base::Bind(V8cXMLDocument::CreateWrapper),
      base::Bind(V8cXMLDocument::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      XMLHttpRequest::XMLHttpRequestWrappableType(),
      base::Bind(V8cXMLHttpRequest::CreateWrapper),
      base::Bind(V8cXMLHttpRequest::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      XMLHttpRequestEventTarget::XMLHttpRequestEventTargetWrappableType(),
      base::Bind(V8cXMLHttpRequestEventTarget::CreateWrapper),
      base::Bind(V8cXMLHttpRequestEventTarget::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      XMLHttpRequestUpload::XMLHttpRequestUploadWrappableType(),
      base::Bind(V8cXMLHttpRequestUpload::CreateWrapper),
      base::Bind(V8cXMLHttpRequestUpload::GetTemplate));
  wrapper_factory_->RegisterWrappableType(
      XMLSerializer::XMLSerializerWrappableType(),
      base::Bind(V8cXMLSerializer::CreateWrapper),
      base::Bind(V8cXMLSerializer::GetTemplate));

}

}  // namespace v8c

template<>
void GlobalEnvironment::CreateGlobalObject<Window>(
    const scoped_refptr<Window>& global_interface,
    EnvironmentSettings* environment_settings) {
  base::polymorphic_downcast<v8c::V8cGlobalEnvironment*>(this)->CreateGlobalObject(global_interface, environment_settings);
}

}  // namespace script
}  // namespace cobalt


